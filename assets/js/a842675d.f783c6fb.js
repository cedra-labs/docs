"use strict";(self.webpackChunkcedra_docs=self.webpackChunkcedra_docs||[]).push([[36],{1005:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>u,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"guides/dex/multi-hop-routing","title":"Multi-hop Routing for Optimal Execution","description":"Not all token pairs have direct liquidity pools. Multi-hop routing enables trades between any two tokens by routing through intermediate pools, finding the best path for optimal execution. This tutorial teaches you how to implement and optimize multi-hop swaps on Cedra.","source":"@site/docs/guides/dex/multi-hop-routing.md","sourceDirName":"guides/dex","slug":"/guides/dex/multi-hop-routing","permalink":"/guides/dex/multi-hop-routing","draft":false,"unlisted":false,"editUrl":"https://github.com/cedra-labs/docs/edit/main/docs/guides/dex/multi-hop-routing.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Adding Price Protection Mechanisms","permalink":"/guides/dex/price-protection"},"next":{"title":"DEX Client Integration Guide","permalink":"/guides/dex/client-integration"}}');var r=n(4848),a=n(8453),s=n(5537),o=n(9329);const l={},u="Multi-hop Routing for Optimal Execution",d={},c=[{value:"What You&#39;ll Learn:",id:"what-youll-learn",level:4},{value:"The Liquidity Network Challenge",id:"the-liquidity-network-challenge",level:2},{value:"Reality in our DEX:",id:"reality-in-our-dex",level:4},{value:"Understanding the Multihop Module",id:"understanding-the-multihop-module",level:3},{value:"Execution Flow",id:"execution-flow",level:4},{value:"Why Atomic Execution Matters?",id:"why-atomic-execution-matters",level:4},{value:"Real-World Routing Strategies",id:"real-world-routing-strategies",level:2},{value:"When to Use Multi-hop",id:"when-to-use-multi-hop",level:3},{value:"Next steps",id:"next-steps",level:2},{value:"DEX Client Integration Guide",id:"dex-client-integration-guide",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"multi-hop-routing-for-optimal-execution",children:"Multi-hop Routing for Optimal Execution"})}),"\n",(0,r.jsx)(t.p,{children:"Not all token pairs have direct liquidity pools. Multi-hop routing enables trades between any two tokens by routing through intermediate pools, finding the best path for optimal execution. This tutorial teaches you how to implement and optimize multi-hop swaps on Cedra."}),"\n",(0,r.jsx)(t.h4,{id:"what-youll-learn",children:"What You'll Learn:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Why multi-hop routing is essential"}),"\n",(0,r.jsx)(t.li,{children:"Implementing two-hop and multi-hop swaps"}),"\n",(0,r.jsx)(t.li,{children:"Path finding algorithms"}),"\n",(0,r.jsx)(t.li,{children:"Gas optimization strategies"}),"\n",(0,r.jsx)(t.li,{children:"Real-world routing examples"}),"\n"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h2,{id:"the-liquidity-network-challenge",children:"The Liquidity Network Challenge"}),"\n",(0,r.jsx)(t.p,{children:"Imagine a DEX as a city where tokens are neighborhoods and liquidity pools are roads connecting them. In a perfect world, every neighborhood would have a direct road to every other neighborhood. But in reality, building and maintaining all these roads (liquidity pools) is impossibly expensive. With just 100 tokens, you'd need 4,950 separate pools to connect everything directly."}),"\n",(0,r.jsx)(t.p,{children:"Multi-hop routing solves this by finding paths through intermediate destinations. Just as you might drive through downtown to get from the suburbs to the airport, tokens can route through major pairs like ETH/USDC to reach their destination. This creates a hub-and-spoke model where major tokens act as liquidity highways, dramatically reducing the infrastructure needed while maintaining global connectivity."}),"\n",(0,r.jsx)(t.h4,{id:"reality-in-our-dex",children:"Reality in our DEX:"}),"\n",(0,r.jsx)(t.p,{children:"ETH/USDC: $10M liquidity (major highway)\nUSDC/DAI: $5M liquidity (stablecoin corridor)\nETH/WBTC: $3M liquidity (crypto blue chips)\nSMALL/ETH: $50k liquidity (community token)"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"User wants"}),": DAI \u2192 SMALL (no direct pool exists)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Solution"}),": DAI \u2192 USDC \u2192 ETH \u2192 SMALL (three hops through liquid paths)"]}),"\n"]}),"\n",(0,r.jsx)(t.admonition,{title:"Did You Know?",type:"note",children:(0,r.jsx)(t.p,{children:"The constant product formula was first implemented by Uniswap V1 in 2018. Despite its simplicity, it remains the foundation for most DEXs today, processing billions in daily volume."})}),"\n",(0,r.jsx)(t.h3,{id:"understanding-the-multihop-module",children:"Understanding the Multihop Module"}),"\n",(0,r.jsx)(t.p,{children:"It ebales token swaps through intermediate pools when direct pairs don't exist or have insufficient liquidity. By chaining multiple swaps in a single atomic transaction, users can trade between any tokens in the ecosystem while maintaining security guarantees - if any swap in the chain fails, the entire transaction reverts, protecting users from partial execution risks"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"public entry fun swap_exact_input_multihop(\n    user: &signer,\n    xy_lp_metadata: Object<Metadata>,  // First pool (X\u2192Y)\n    yz_lp_metadata: Object<Metadata>,  // Second pool (Y\u2192Z)\n    x: Object<Metadata>,               // Starting token\n    y: Object<Metadata>,               // Intermediate token\n    z: Object<Metadata>,               // Final token\n    amount_in: u64,                    // Input amount\n    min_amount_out: u64                // Minimum final output\n)\n"})}),"\n",(0,r.jsx)(t.admonition,{title:"View Source",type:"tip",children:(0,r.jsxs)(t.p,{children:["Complete multi-hop implementation: ",(0,r.jsx)(t.a,{href:"https://github.com/cedra-labs/move-contract-examples/blob/main/dex/sources/4-multihop.move#L12-L49",children:(0,r.jsx)(t.code,{children:"swap_exact_input_multihop"})})]})}),"\n",(0,r.jsx)(t.h4,{id:"execution-flow",children:"Execution Flow"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Calculate First Hop"}),": Determine Y tokens from X input"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Execute First Swap"}),": X \u2192 Y through first pool"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Calculate Second Hop"}),": Determine Z tokens from Y"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Validate Output"}),": Ensure final amount meets minimum"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Execute Second Swap"}),": Y \u2192 Z through second pool"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Let's dive deep into Step-by-Step Breakdown"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"// Step 1: Get first pool reserves\nlet (reserve_x1, reserve_y1) = swap::reserves(xy_lp_metadata);\n\n// Step 2: Calculate intermediate output\nlet amount_intermediate = math_amm::get_amount_out(\n    amount_in, \n    reserve_x1, \n    reserve_y1\n);\n\n// Step 3: Execute first swap (X \u2192 Y)\nswap::swap_exact_input(\n    user, \n    xy_lp_metadata,\n    x,\n    y,\n    amount_in,\n    0  // No minimum for intermediate swap\n);\n\n// Step 4: Get second pool reserves\nlet (reserve_y2, reserve_z2) = swap::reserves(yz_lp_metadata);\n\n// Step 5: Calculate final output\nlet amount_out = math_amm::get_amount_out(\n    amount_intermediate, \n    reserve_y2, \n    reserve_z2\n);\n\n// Step 6: Validate against minimum\nassert!(amount_out >= min_amount_out, ERROR_INSUFFICIENT_OUTPUT);\n\n// Step 7: Execute second swap (Y \u2192 Z)\nswap::swap_exact_input(\n    user, \n    yz_lp_metadata,\n    y,\n    z,\n    amount_intermediate,\n    min_amount_out\n);\n"})}),"\n",(0,r.jsx)(t.h4,{id:"why-atomic-execution-matters",children:"Why Atomic Execution Matters?"}),"\n",(0,r.jsx)(t.p,{children:"All swaps execute in a single transaction:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"No partial execution"}),": Either all succeed or all fail"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"No intermediate token risk"}),": User never holds Y tokens"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"MEV protection"}),": Can't be sandwiched between hops"]}),"\n"]}),"\n",(0,r.jsx)(t.hr,{}),"\n","\n",(0,r.jsx)(t.h2,{id:"real-world-routing-strategies",children:"Real-World Routing Strategies"}),"\n",(0,r.jsxs)(s.A,{children:[(0,r.jsxs)(o.A,{value:"stable",label:"Stablecoin Arbitrage",default:!0,children:[(0,r.jsx)(t.p,{children:"This strategy exploits fee differences between pools. When stablecoin pools have different fee tiers, routing through lower-fee pools can save significant costs, especially for large trades. The 0.2% saved might seem small, but on a $1M trade, that's $2,000 in savings."}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"// Route through low-fee stable pools\nfun efficient_stable_swap(user: &signer, amount_usdc: u64) {\n    // USDC \u2192 USDT \u2192 DAI through 0.05% pools\n    // Saves 0.2% vs direct 0.3% pool\n    multihop::swap_exact_input_multihop(\n        user,\n        usdc_usdt_pool,  // 0.05% fee tier\n        usdt_dai_pool,   // 0.05% fee tier\n        usdc_metadata,\n        usdt_metadata,\n        dai_metadata,\n        amount_usdc,\n        (amount_usdc * 999) / 1000  // Expect 0.1% loss max\n    );\n}\n"})})]}),(0,r.jsxs)(o.A,{value:"cross",label:"Cross-Market Swap",children:[(0,r.jsx)(t.p,{children:"Many tokens only have liquidity against ETH or USDC, creating isolated markets. This example shows how multi-hop routing breaks down these barriers, enabling any-to-any token swaps through bridge tokens."}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"// Access isolated markets through ETH bridge\nfun swap_usdc_to_small_token(user: &signer, usdc_amount: u64) {\n    // Calculate path: USDC \u2192 ETH \u2192 SMALL\n    let (usdc_reserves, eth_reserves) = swap::reserves(usdc_eth_pool);\n    let eth_amount = math_amm::get_amount_out(\n        usdc_amount, usdc_reserves, eth_reserves\n    );\n    \n    // Route through ETH to reach small cap token\n    multihop::swap_exact_input_multihop(\n        user,\n        usdc_eth_pool,\n        eth_small_pool,\n        usdc_metadata,\n        eth_metadata,\n        small_metadata,\n        usdc_amount,\n        calculate_min_output(eth_amount, 200) // 2% slippage\n    );\n}\n"})})]})]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h3,{id:"when-to-use-multi-hop",children:"When to Use Multi-hop"}),"\n",(0,r.jsx)(t.p,{children:"Use multi-hop when:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"No direct pool exists"}),"\n",(0,r.jsx)(t.li,{children:"Direct pool has low liquidity"}),"\n",(0,r.jsx)(t.li,{children:"Price improvement exceeds gas costs"}),"\n",(0,r.jsx)(t.li,{children:"Arbitrage opportunity exists"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Avoid multi-hop when:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Direct pool has deep liquidity"}),"\n",(0,r.jsx)(t.li,{children:"Small trade amounts (gas inefficient)"}),"\n",(0,r.jsx)(t.li,{children:"Time-sensitive trades"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Multi-hop routing transforms your DEX from isolated pools into an interconnected liquidity network."}),"\n",(0,r.jsx)(t.p,{children:"Your DEX now supports efficient trading between any token pair!"}),"\n",(0,r.jsx)(t.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,r.jsx)(t.p,{children:"You've mastered multi-hop routing:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Core Implementation"}),": Two-hop swaps with atomic execution"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Advanced Strategies"}),": Split routing, dynamic path finding"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Gas Optimization"}),": Batching, caching, optimistic execution"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Real Integration"}),": Production-ready router examples"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"dex-client-integration-guide",children:(0,r.jsx)(t.a,{href:"./client-integration",children:"DEX Client Integration Guide"})}),"\n",(0,r.jsx)(t.p,{children:"Create a TypeScript/React frontend that interacts with your DEX smart contracts."})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},5537:(e,t,n)=>{n.d(t,{A:()=>w});var i=n(6540),r=n(4164),a=n(5627),s=n(6347),o=n(372),l=n(604),u=n(1861),d=n(8749);function c(e){return i.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:t,children:n}=e;return(0,i.useMemo)((()=>{const e=t??function(e){return c(e).map((({props:{value:e,label:t,attributes:n,default:i}})=>({value:e,label:t,attributes:n,default:i})))}(n);return function(e){const t=(0,u.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function p({value:e,tabValues:t}){return t.some((t=>t.value===e))}function m({queryString:e=!1,groupId:t}){const n=(0,s.W6)(),r=function({queryString:e=!1,groupId:t}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:e,groupId:t});return[(0,l.aZ)(r),(0,i.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(n.location.search);t.set(r,e),n.replace({...n.location,search:t.toString()})}),[r,n])]}function g(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,a=h(e),[s,l]=(0,i.useState)((()=>function({defaultValue:e,tabValues:t}){if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const n=t.find((e=>e.default))??t[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:a}))),[u,c]=m({queryString:n,groupId:r}),[g,x]=function({groupId:e}){const t=function(e){return e?`docusaurus.tab.${e}`:null}(e),[n,r]=(0,d.Dv)(t);return[n,(0,i.useCallback)((e=>{t&&r.set(e)}),[t,r])]}({groupId:r}),f=(()=>{const e=u??g;return p({value:e,tabValues:a})?e:null})();(0,o.A)((()=>{f&&l(f)}),[f]);return{selectedValue:s,selectValue:(0,i.useCallback)((e=>{if(!p({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);l(e),c(e),x(e)}),[c,x,a]),tabValues:a}}var x=n(9136);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=n(4848);function j({className:e,block:t,selectedValue:n,selectValue:i,tabValues:s}){const o=[],{blockElementScrollPositionUntilNextRender:l}=(0,a.a_)(),u=e=>{const t=e.currentTarget,r=o.indexOf(t),a=s[r].value;a!==n&&(l(t),i(a))},d=e=>{let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const n=o.indexOf(e.currentTarget)+1;t=o[n]??o[0];break}case"ArrowLeft":{const n=o.indexOf(e.currentTarget)-1;t=o[n]??o[o.length-1];break}}t?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},e),children:s.map((({value:e,label:t,attributes:i})=>(0,b.jsx)("li",{role:"tab",tabIndex:n===e?0:-1,"aria-selected":n===e,ref:e=>{o.push(e)},onKeyDown:d,onClick:u,...i,className:(0,r.A)("tabs__item",f.tabItem,i?.className,{"tabs__item--active":n===e}),children:t??e},e)))})}function v({lazy:e,children:t,selectedValue:n}){const a=(Array.isArray(t)?t:[t]).filter(Boolean);if(e){const e=a.find((e=>e.props.value===n));return e?(0,i.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:a.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==n})))})}function y(e){const t=g(e);return(0,b.jsxs)("div",{className:(0,r.A)("tabs-container",f.tabList),children:[(0,b.jsx)(j,{...t,...e}),(0,b.jsx)(v,{...t,...e})]})}function w(e){const t=(0,x.A)();return(0,b.jsx)(y,{...e,children:c(e.children)},String(t))}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var i=n(6540);const r={},a=i.createContext(r);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:t},e.children)}},9329:(e,t,n)=>{n.d(t,{A:()=>s});n(6540);var i=n(4164);const r={tabItem:"tabItem_Ymn6"};var a=n(4848);function s({children:e,hidden:t,className:n}){return(0,a.jsx)("div",{role:"tabpanel",className:(0,i.A)(r.tabItem,n),hidden:t,children:e})}}}]);