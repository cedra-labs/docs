"use strict";(self.webpackChunkcedra_docs=self.webpackChunkcedra_docs||[]).push([[30],{4464:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"move/functions","title":"Functions in Move - Declaration and Usage","description":"Master Move functions - from basic declarations to advanced patterns. Learn about parameters, return values, generics, and how to design robust blockchain APIs.","source":"@site/docs/move/functions.md","sourceDirName":"move","slug":"/move/functions","permalink":"/move/functions","draft":false,"unlisted":false,"editUrl":"https://github.com/cedra-labs/docs/edit/main/docs/move/functions.md","tags":[],"version":"current","frontMatter":{"title":"Functions in Move - Declaration and Usage","description":"Master Move functions - from basic declarations to advanced patterns. Learn about parameters, return values, generics, and how to design robust blockchain APIs.","keywords":["move functions","function parameters","return values","generics","move programming","blockchain functions"]},"sidebar":"docs","previous":{"title":"Move Modules","permalink":"/move/modules"},"next":{"title":"Resource Types","permalink":"/move/resource"}}');var r=t(4848),i=t(8453);const a={title:"Functions in Move - Declaration and Usage",description:"Master Move functions - from basic declarations to advanced patterns. Learn about parameters, return values, generics, and how to design robust blockchain APIs.",keywords:["move functions","function parameters","return values","generics","move programming","blockchain functions"]},o="Functions in Move: Declaration and Usage",c={},l=[{value:"Function Basics",id:"function-basics",level:2},{value:"Parameters: How Data Flows In",id:"parameters-how-data-flows-in",level:2},{value:"Passing by Value",id:"passing-by-value",level:3},{value:"Immutable References (&amp;)",id:"immutable-references-",level:3},{value:"Mutable References (&amp;mut)",id:"mutable-references-mut",level:3},{value:"The Signer Type",id:"the-signer-type",level:3},{value:"Return Values: Getting Data Out",id:"return-values-getting-data-out",level:2},{value:"Single Returns",id:"single-returns",level:3},{value:"Multiple Returns",id:"multiple-returns",level:3},{value:"No Return Value",id:"no-return-value",level:3},{value:"Generic Functions: Write Once, Use Many",id:"generic-functions-write-once-use-many",level:2},{value:"Basic Generics",id:"basic-generics",level:3},{value:"Type Constraints",id:"type-constraints",level:3},{value:"Phantom Types",id:"phantom-types",level:3},{value:"Function Modifiers and Annotations",id:"function-modifiers-and-annotations",level:2},{value:"The <code>acquires</code> Annotation",id:"the-acquires-annotation",level:3},{value:"View Functions",id:"view-functions",level:3},{value:"Test Functions",id:"test-functions",level:3},{value:"Advanced Function Patterns",id:"advanced-function-patterns",level:2},{value:"The Check-Effects-Interactions Pattern",id:"the-check-effects-interactions-pattern",level:3},{value:"Builder Pattern with Functions",id:"builder-pattern-with-functions",level:3},{value:"Result Pattern for Error Handling",id:"result-pattern-for-error-handling",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Naming Conventions",id:"naming-conventions",level:3},{value:"Function Documentation",id:"function-documentation",level:3},{value:"Input Validation",id:"input-validation",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"What&#39;s Next?",id:"whats-next",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"functions-in-move-declaration-and-usage",children:"Functions in Move: Declaration and Usage"})}),"\n",(0,r.jsx)(n.p,{children:"Functions are where Move code comes to life. They define the actions your modules can perform, from simple calculations to complex asset transfers. Let's explore how to write functions that are safe, efficient, and easy to use."}),"\n",(0,r.jsx)(n.h2,{id:"function-basics",children:"Function Basics"}),"\n",(0,r.jsx)(n.p,{children:"Every function in Move follows a consistent structure:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fun function_name(parameter1: Type1, parameter2: Type2): ReturnType {\n    // Function body\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"But Move functions have unique characteristics driven by blockchain requirements. Unlike traditional programming, Move functions must be deterministic \u2013 given the same inputs, they always produce the same outputs. No random numbers from system time, no network calls, no file I/O."}),"\n",(0,r.jsx)(n.p,{children:"Here's a simple function that demonstrates Move's clarity:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"public fun calculate_fee(amount: u64, fee_percentage: u8): u64 {\n    (amount * (fee_percentage as u64)) / 100\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This function is public (callable from other modules), takes two parameters, and returns a fee amount."}),"\n",(0,r.jsx)(n.h2,{id:"parameters-how-data-flows-in",children:"Parameters: How Data Flows In"}),"\n",(0,r.jsx)(n.p,{children:"Move is strict about how data enters functions. Understanding parameter passing is crucial because it directly relates to Move's ownership model."}),"\n",(0,r.jsx)(n.h3,{id:"passing-by-value",children:"Passing by Value"}),"\n",(0,r.jsx)(n.p,{children:"When you pass a value directly, Move transfers ownership:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fun consume_token(token: Token) {\n    // Function now owns token\n    let Token { amount } = token; // Destructure and destroy\n    emit_burn_event(amount);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Once ",(0,r.jsx)(n.code,{children:"token"})," is passed to ",(0,r.jsx)(n.code,{children:"consume_token"}),", the caller no longer has access to it. This is Move's linear type system in action \u2013 ensuring resources can't be duplicated. Use this pattern when:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The function needs to destroy or store the resource"}),"\n",(0,r.jsx)(n.li,{children:"You're transferring ownership permanently"}),"\n",(0,r.jsx)(n.li,{children:"The resource won't be needed by the caller afterward"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"immutable-references-",children:"Immutable References (&)"}),"\n",(0,r.jsx)(n.p,{children:"References let you read data without taking ownership:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"public fun check_balance(account: &Account): u64 {\n    account.balance\n}\n\npublic fun validate_transfer(from: &Account, to: &Account, amount: u64): bool {\n    from.balance >= amount && to.status == ACTIVE\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Immutable references are perfect for:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reading data without modifying it"}),"\n",(0,r.jsx)(n.li,{children:"Checking conditions or validating state"}),"\n",(0,r.jsx)(n.li,{children:"Passing large structs efficiently (no copying)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"&"})," symbol creates a reference. Multiple functions can hold immutable references to the same data simultaneously \u2013 Move's borrow checker ensures safety."]}),"\n",(0,r.jsx)(n.h3,{id:"mutable-references-mut",children:"Mutable References (&mut)"}),"\n",(0,r.jsx)(n.p,{children:"Mutable references allow modification:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"public fun deposit(account: &mut Account, amount: u64) {\n    account.balance = account.balance + amount;\n    account.last_updated = timestamp::now_seconds();\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Key rules for mutable references:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Only one mutable reference can exist at a time"}),"\n",(0,r.jsx)(n.li,{children:"Cannot coexist with immutable references"}),"\n",(0,r.jsx)(n.li,{children:"Changes affect the original data"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This exclusivity prevents data races and ensures consistency \u2013 critical for financial operations."}),"\n",(0,r.jsx)(n.h3,{id:"the-signer-type",children:"The Signer Type"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"signer"})," type is special \u2013 it represents transaction authority:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"public entry fun withdraw(user: &signer, amount: u64) {\n    let user_address = signer::address_of(user);\n    let account = borrow_global_mut<Account>(user_address);\n    \n    assert!(account.balance >= amount, ERROR_INSUFFICIENT_FUNDS);\n    account.balance = account.balance - amount;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You can only get a ",(0,r.jsx)(n.code,{children:"signer"})," for the account that initiated the transaction. This prevents impersonation \u2013 you can't create a signer for someone else's address. Functions typically use ",(0,r.jsx)(n.code,{children:"&signer"})," (reference) rather than ",(0,r.jsx)(n.code,{children:"signer"})," (value) because the signer doesn't need to be consumed."]}),"\n",(0,r.jsx)(n.h2,{id:"return-values-getting-data-out",children:"Return Values: Getting Data Out"}),"\n",(0,r.jsx)(n.p,{children:"Move functions can return zero, one, or multiple values. This flexibility enables clean APIs without wrapper types."}),"\n",(0,r.jsx)(n.h3,{id:"single-returns",children:"Single Returns"}),"\n",(0,r.jsx)(n.p,{children:"Most functions return a single value:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"public fun calculate_interest(principal: u64, rate: u8, days: u64): u64 {\n    (principal * (rate as u64) * days) / 36500\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"multiple-returns",children:"Multiple Returns"}),"\n",(0,r.jsx)(n.p,{children:"Move shines with multiple return values:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"public fun swap_exact_input(\n    input: Token<X>,\n    min_output: u64\n): (Token<Y>, u64) {\n    let output_amount = calculate_output_amount(token::value(&input));\n    assert!(output_amount >= min_output, ERROR_SLIPPAGE);\n    \n    let output = withdraw_from_pool<Y>(output_amount);\n    deposit_to_pool(input);\n    \n    (output, output_amount)\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This function returns both the output tokens and the amount \u2013 no need for a wrapper struct. Callers can destructure the result:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"let (tokens, amount) = swap_exact_input(my_tokens, 1000);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"no-return-value",children:"No Return Value"}),"\n",(0,r.jsx)(n.p,{children:"Functions that only cause side effects return nothing:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"public entry fun register_user(user: &signer, username: vector<u8>) {\n    let user_addr = signer::address_of(user);\n    assert!(!exists<UserProfile>(user_addr), ERROR_ALREADY_REGISTERED);\n    \n    move_to(user, UserProfile {\n        username,\n        reputation: 0,\n        joined_at: timestamp::now_seconds(),\n    });\n}\n"})}),"\n",(0,r.jsxs)(n.admonition,{title:"Entry Functions",type:"info",children:[(0,r.jsxs)(n.p,{children:["Functions marked ",(0,r.jsx)(n.code,{children:"entry"})," are special \u2013 they can be called directly from transactions but cannot return values. They're your module's user interface."]}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"See Entry Functions in Action:"})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/guides/first-nft#3-creatorgated-mint",children:"NFT Minting"})," - The ",(0,r.jsx)(n.code,{children:"mint_nft"})," entry function"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/guides/first-fa#213-transfer---peertopeer-move",children:"FA Transfer"})," - The ",(0,r.jsx)(n.code,{children:"transfer"})," entry function"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/guides/escrow#step-2-locking-funds-into-escrow",children:"Escrow Operations"})," - Multiple entry functions for locking and releasing funds"]}),"\n"]})]}),"\n",(0,r.jsx)(n.h2,{id:"generic-functions-write-once-use-many",children:"Generic Functions: Write Once, Use Many"}),"\n",(0,r.jsx)(n.p,{children:"Generics let you write functions that work with multiple types. This is powerful for building reusable components."}),"\n",(0,r.jsx)(n.h3,{id:"basic-generics",children:"Basic Generics"}),"\n",(0,r.jsx)(n.p,{children:"Here's a generic function that works with any token type:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"public fun transfer<TokenType>(\n    from: &signer,\n    to: address,\n    amount: u64\n) {\n    let coins = coin::withdraw<TokenType>(from, amount);\n    coin::deposit(to, coins);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"<TokenType>"})," declares a type parameter. When calling this function, Move infers or requires the type:"]}),"\n",(0,r.jsx)(n.admonition,{title:"Real-World Generic Usage",type:"tip",children:(0,r.jsxs)(n.p,{children:["Our ",(0,r.jsx)(n.a,{href:"/guides/first-fa",children:"Fungible Asset Guide"})," uses generics extensively. The entire FA framework is built on generic types like ",(0,r.jsx)(n.code,{children:"FungibleStore<T>"})," and functions like ",(0,r.jsx)(n.code,{children:"mint<T>"})," that work with any token type."]})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// Move infers USDC from the context\ntransfer<USDC>(from, recipient, 1000);\n\n// Or explicitly specify\ntransfer<0x1::aptos_coin::AptosCoin>(from, recipient, 1000);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"type-constraints",children:"Type Constraints"}),"\n",(0,r.jsx)(n.p,{children:"You can constrain generic types with abilities:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"public fun store_in_vault<T: store>(item: T) {\n    // T must have the 'store' ability\n    move_to(vault_address, VaultItem { contents: item });\n}\n\npublic fun create_pair<T: copy + drop>(first: T, second: T): Pair<T> {\n    // T must have both 'copy' and 'drop'\n    Pair { first, second }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"These constraints ensure type safety. The compiler verifies that only appropriate types are used."}),"\n",(0,r.jsx)(n.h3,{id:"phantom-types",children:"Phantom Types"}),"\n",(0,r.jsx)(n.p,{children:"Phantom types exist only at compile time for type safety:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"struct Balance<phantom TokenType> has key {\n    amount: u64\n}\n\npublic fun get_balance<TokenType>(addr: address): u64 acquires Balance {\n    borrow_global<Balance<TokenType>>(addr).amount\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"phantom"})," keyword indicates that ",(0,r.jsx)(n.code,{children:"TokenType"})," isn't stored in the struct \u2013 it's just used for type checking. This creates type-safe interfaces without runtime overhead."]}),"\n",(0,r.jsx)(n.h2,{id:"function-modifiers-and-annotations",children:"Function Modifiers and Annotations"}),"\n",(0,r.jsx)(n.p,{children:"Move provides several modifiers that change function behavior or provide information to the compiler."}),"\n",(0,r.jsxs)(n.h3,{id:"the-acquires-annotation",children:["The ",(0,r.jsx)(n.code,{children:"acquires"})," Annotation"]}),"\n",(0,r.jsx)(n.p,{children:"When a function accesses global storage, it must declare what it acquires:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"public fun get_user_tokens(user: address): u64 acquires TokenVault {\n    let vault = borrow_global<TokenVault>(user);\n    vault.balance\n}\n\npublic fun transfer_from_vault(\n    user: address,\n    recipient: address,\n    amount: u64\n) acquires TokenVault {\n    let vault = borrow_global_mut<TokenVault>(user);\n    assert!(vault.balance >= amount, ERROR_INSUFFICIENT_BALANCE);\n    \n    vault.balance = vault.balance - amount;\n    // Transfer logic\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"acquires"})," annotation serves two purposes:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Documents what resources the function touches"}),"\n",(0,r.jsx)(n.li,{children:"Prevents reentrancy by tracking resource access"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["If you forget ",(0,r.jsx)(n.code,{children:"acquires"}),", the compiler catches it \u2013 another safety net."]}),"\n",(0,r.jsx)(n.h3,{id:"view-functions",children:"View Functions"}),"\n",(0,r.jsxs)(n.p,{children:["Functions marked ",(0,r.jsx)(n.code,{children:"#[view]"})," are read-only queries:"]}),"\n",(0,r.jsxs)(n.admonition,{title:"View Functions in Practice",type:"success",children:[(0,r.jsx)(n.p,{children:"Check out these view functions in our guides:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/guides/escrow#step-4-checking-status",children:"Escrow Status Checks"})," - Multiple view functions for checking locked funds"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/guides/fee-splitter#36-read-only-helpers",children:"Fee Splitter Info"})," - Query recipient shares and existence"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/guides/first-nft#6-readonly-helpers",children:"NFT Collection Data"})," - Read collection metadata without gas costs"]}),"\n"]})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[view]\npublic fun get_price(token_a: address, token_b: address): u64 acquires PriceOracle {\n    let oracle = borrow_global<PriceOracle>(@oracle_address);\n    *table::borrow(&oracle.prices, &PricePair { token_a, token_b })\n}\n\n#[view]\npublic fun calculate_reward(staker: address): u64 acquires StakeInfo {\n    let info = borrow_global<StakeInfo>(staker);\n    let duration = timestamp::now_seconds() - info.start_time;\n    (info.amount * duration * REWARD_RATE) / SECONDS_PER_YEAR\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"View functions:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Can be called off-chain without a transaction"}),"\n",(0,r.jsx)(n.li,{children:"Must not modify state"}),"\n",(0,r.jsx)(n.li,{children:"Perfect for building UIs and dashboards"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"test-functions",children:"Test Functions"}),"\n",(0,r.jsx)(n.p,{children:"Test-specific functions help you write comprehensive tests:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[test]\npublic fun test_transfer_success() {\n    let sender = @0x1;\n    let recipient = @0x2;\n    \n    // Setup\n    create_account_for_test(sender, 1000);\n    create_account_for_test(recipient, 0);\n    \n    // Execute\n    transfer(sender, recipient, 500);\n    \n    // Verify\n    assert!(get_balance(sender) == 500, 0);\n    assert!(get_balance(recipient) == 500, 1);\n}\n\n#[test_only]\npublic fun create_account_for_test(addr: address, initial_balance: u64) {\n    // This function only exists in test builds\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-function-patterns",children:"Advanced Function Patterns"}),"\n",(0,r.jsx)(n.p,{children:"Let's explore patterns that make your functions more robust and maintainable."}),"\n",(0,r.jsx)(n.h3,{id:"the-check-effects-interactions-pattern",children:"The Check-Effects-Interactions Pattern"}),"\n",(0,r.jsx)(n.p,{children:"This pattern prevents reentrancy and ensures consistency:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"public fun safe_withdraw(user: &signer, amount: u64) acquires Vault {\n    // 1. Checks\n    let user_addr = signer::address_of(user);\n    let vault = borrow_global_mut<Vault>(user_addr);\n    assert!(vault.balance >= amount, ERROR_INSUFFICIENT_FUNDS);\n    assert!(!vault.is_locked, ERROR_VAULT_LOCKED);\n    \n    // 2. Effects (update state)\n    vault.balance = vault.balance - amount;\n    vault.last_withdrawal = timestamp::now_seconds();\n    \n    // 3. Interactions (external calls)\n    coin::transfer<AptosCoin>(user, amount);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"By updating state before external interactions, you prevent reentrancy attacks. Even if the external call somehow triggers a callback, your state is already updated."}),"\n",(0,r.jsx)(n.h3,{id:"builder-pattern-with-functions",children:"Builder Pattern with Functions"}),"\n",(0,r.jsx)(n.p,{children:"For complex operations, use a builder pattern:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"public fun create_pool(): PoolBuilder {\n    PoolBuilder {\n        token_a: option::none(),\n        token_b: option::none(),\n        fee_tier: 30, // 0.3% default\n        initial_price: 0,\n    }\n}\n\npublic fun with_tokens<A, B>(builder: PoolBuilder): PoolBuilder {\n    builder.token_a = option::some(type_name<A>());\n    builder.token_b = option::some(type_name<B>());\n    builder\n}\n\npublic fun with_fee(builder: PoolBuilder, fee: u64): PoolBuilder {\n    assert!(fee <= 1000, ERROR_FEE_TOO_HIGH); // Max 10%\n    builder.fee_tier = fee;\n    builder\n}\n\npublic fun build(builder: PoolBuilder): Pool {\n    assert!(option::is_some(&builder.token_a), ERROR_TOKEN_A_NOT_SET);\n    assert!(option::is_some(&builder.token_b), ERROR_TOKEN_B_NOT_SET);\n    assert!(builder.initial_price > 0, ERROR_INVALID_PRICE);\n    \n    // Create the actual pool\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This pattern provides a fluent interface for complex object construction while maintaining type safety."}),"\n",(0,r.jsx)(n.h3,{id:"result-pattern-for-error-handling",children:"Result Pattern for Error Handling"}),"\n",(0,r.jsxs)(n.p,{children:["While Move uses ",(0,r.jsx)(n.code,{children:"assert!"})," for errors, you can create Result-like types:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"struct Result<T> has drop {\n    value: Option<T>,\n    error: Option<u64>,\n}\n\npublic fun safe_divide(numerator: u64, denominator: u64): Result<u64> {\n    if (denominator == 0) {\n        Result {\n            value: option::none(),\n            error: option::some(ERROR_DIVISION_BY_ZERO),\n        }\n    } else {\n        Result {\n            value: option::some(numerator / denominator),\n            error: option::none(),\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This pattern is useful when you want to handle errors without aborting the transaction."}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"naming-conventions",children:"Naming Conventions"}),"\n",(0,r.jsx)(n.p,{children:"Follow Move's naming conventions consistently:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// Functions: snake_case\npublic fun calculate_interest() { }\n\n// Parameters: snake_case\npublic fun transfer(from_account: &signer, to_address: address) { }\n\n// Type parameters: PascalCase\npublic fun create<TokenType>() { }\n"})}),"\n",(0,r.jsx)(n.h3,{id:"function-documentation",children:"Function Documentation"}),"\n",(0,r.jsx)(n.p,{children:"Document your functions thoroughly:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"/// Calculates compound interest for a given principal\n/// @param principal - The initial amount in base units\n/// @param rate - Annual interest rate as a percentage (e.g., 5 for 5%)\n/// @param years - Number of years to compound\n/// @return The final amount after compound interest\npublic fun calculate_compound_interest(\n    principal: u64,\n    rate: u8,\n    years: u8\n): u64 {\n    // Implementation\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"input-validation",children:"Input Validation"}),"\n",(0,r.jsx)(n.p,{children:"Always validate inputs early:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"public fun create_order(\n    trader: &signer,\n    amount: u64,\n    price: u64,\n    is_buy: bool\n) {\n    // Validate immediately\n    assert!(amount > 0, ERROR_ZERO_AMOUNT);\n    assert!(price > 0, ERROR_ZERO_PRICE);\n    assert!(amount <= MAX_ORDER_SIZE, ERROR_ORDER_TOO_LARGE);\n    \n    // Then proceed with logic\n    let order = Order { amount, price, is_buy };\n    // ...\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Early validation provides better error messages and prevents unnecessary computation."}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"\ud83d\udcd6 Function Design Checklist"}),(0,r.jsx)(n.p,{children:"Before finalizing a function, check:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Is the function name clear and descriptive?"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Are parameters in the most logical order?"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Does it validate inputs early?"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Is the visibility (public/private/friend) appropriate?"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Are error messages helpful?"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Is it documented?"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Does it follow the single responsibility principle?"}),"\n"]})]}),"\n",(0,r.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsx)(n.p,{children:"Functions in Move are designed with blockchain's unique requirements in mind:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Ownership is explicit"}),": Parameters show exactly how data moves"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"References provide flexibility"}),": Read or modify without ownership transfer"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Generics enable reusability"}),": Write once, use with many types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Safety is built-in"}),": The compiler catches many errors before deployment"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Remember: good functions are predictable, well-documented, and do one thing well."}),"\n",(0,r.jsx)(n.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,r.jsxs)(n.p,{children:["In our next article, ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/move/resource",children:"Resource Types: The Heart of Move's Security Model"})}),", we'll explore how Move's resource types provide unprecedented safety for digital assets. You'll learn how to create resources that can't be copied or lost, and why this makes Move perfect for blockchain development."]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);