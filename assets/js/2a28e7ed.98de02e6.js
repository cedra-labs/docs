"use strict";(self.webpackChunkcedra_docs=self.webpackChunkcedra_docs||[]).push([[9937],{8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>i});var t=s(6540);const o={},r=t.createContext(o);function c(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),t.createElement(r.Provider,{value:n},e.children)}},9601:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>u,frontMatter:()=>c,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"concepts/accounts/resources","title":"Move Resources","description":"On Cedra, all on-chain state is organized into resources and modules stored within accounts. This is fundamentally different from Ethereum\'s model where each smart contract maintains its own storage. In Cedra, your tokens live in your account, not in a contract\'s storage - and this per-account model is what enables parallel transaction execution.","source":"@site/docs/concepts/accounts/resources.md","sourceDirName":"concepts/accounts","slug":"/concepts/accounts/resources","permalink":"/concepts/accounts/resources","draft":false,"unlisted":false,"editUrl":"https://github.com/cedra-labs/docs/edit/main/docs/concepts/accounts/resources.md","tags":[],"version":"current","frontMatter":{},"sidebar":"concepts","previous":{"title":"Authentication","permalink":"/concepts/accounts/authentication"},"next":{"title":"Understanding Transactions","permalink":"/concepts/transactions/understanding-transactions"}}');var o=s(4848),r=s(8453);const c={},i="Move Resources",a={},l=[{value:"Resources vs Instances",id:"resources-vs-instances",level:2},{value:"Defining Resources",id:"defining-resources",level:2},{value:"Resource Permissions",id:"resource-permissions",level:2},{value:"Storage Location",id:"storage-location",level:2},{value:"Parallel Execution Benefits",id:"parallel-execution-benefits",level:2},{value:"Working with Resources",id:"working-with-resources",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"move-resources",children:"Move Resources"})}),"\n",(0,o.jsx)(n.p,{children:"On Cedra, all on-chain state is organized into resources and modules stored within accounts. This is fundamentally different from Ethereum's model where each smart contract maintains its own storage. In Cedra, your tokens live in your account, not in a contract's storage - and this per-account model is what enables parallel transaction execution."}),"\n",(0,o.jsx)(n.admonition,{title:"Navigation",type:"tip",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Previous:"})," ",(0,o.jsx)(n.a,{href:"/concepts/accounts/authentication",children:"Authentication"}),"\n",(0,o.jsx)(n.strong,{children:"You are here:"})," Resources\n",(0,o.jsx)(n.strong,{children:"Overview:"})," ",(0,o.jsx)(n.a,{href:"/concepts/accounts/understanding-accounts",children:"Understanding Accounts"})]})}),"\n",(0,o.jsx)(n.h2,{id:"resources-vs-instances",children:"Resources vs Instances"}),"\n",(0,o.jsx)(n.p,{children:"Move distinguishes between two types of storable data based on their abilities."}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.strong,{children:"resource"})," has the ",(0,o.jsx)(n.code,{children:"key"})," ability, meaning it can be stored directly under an account address. Resources are top-level citizens - you can query them directly by account address and type."]}),"\n",(0,o.jsxs)(n.p,{children:["An ",(0,o.jsx)(n.strong,{children:"instance"})," has the ",(0,o.jsx)(n.code,{children:"store"})," ability, meaning it can be stored within other resources but not directly under an account. Instances are nested data that lives inside resources."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module 0x1::coin {\n    /// Resource - stored directly under account (has `key`)\n    struct CoinStore<phantom CoinType> has key {\n        coin: Coin<CoinType>,\n    }\n\n    /// Instance - stored within CoinStore (has `store`)\n    struct Coin<phantom CoinType> has store {\n        value: u64,\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, ",(0,o.jsx)(n.code,{children:"CoinStore"})," is the resource that lives under your account. It contains a ",(0,o.jsx)(n.code,{children:"Coin"})," instance that holds the actual balance. You can't store a ",(0,o.jsx)(n.code,{children:"Coin"})," directly under an account - it must be wrapped in something with the ",(0,o.jsx)(n.code,{children:"key"})," ability."]}),"\n",(0,o.jsx)(n.mermaid,{value:'graph TD\n    subgraph "Account 0xABC"\n        A[CoinStore&lt;CED&gt;] --\x3e|contains| B[Coin: 1000]\n        C[CoinStore&lt;USDC&gt;] --\x3e|contains| D[Coin: 500]\n    end\n\n    style A fill:#e1f5fe\n    style C fill:#e1f5fe\n    style B fill:#fff3e0\n    style D fill:#fff3e0'}),"\n",(0,o.jsx)(n.h2,{id:"defining-resources",children:"Defining Resources"}),"\n",(0,o.jsx)(n.p,{children:"When you define a resource, you're specifying its structure, abilities, and the module that governs it."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module 0x1234::token {\n    struct TokenStore has key {\n        tokens: vector<Token>,\n        frozen: bool,\n    }\n\n    struct Token has store, drop {\n        id: u64,\n        metadata: vector<u8>,\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The fully qualified path to this resource is ",(0,o.jsx)(n.code,{children:"0x1234::token::TokenStore"}),". When you want to access it, you need three pieces of information:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Address"}),": ",(0,o.jsx)(n.code,{children:"0x1234"})," - where the module is deployed"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Module"}),": ",(0,o.jsx)(n.code,{children:"token"})," - the module name"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Resource"}),": ",(0,o.jsx)(n.code,{children:"TokenStore"})," - the struct name with ",(0,o.jsx)(n.code,{children:"key"})," ability"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"resource-permissions",children:"Resource Permissions"}),"\n",(0,o.jsx)(n.p,{children:"The module that defines a resource controls all operations on it. This is Move's core security model - only the defining module can:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Create new instances (",(0,o.jsx)(n.code,{children:"move_to"}),")"]}),"\n",(0,o.jsxs)(n.li,{children:["Destroy instances (",(0,o.jsx)(n.code,{children:"move_from"}),")"]}),"\n",(0,o.jsxs)(n.li,{children:["Borrow references (",(0,o.jsx)(n.code,{children:"borrow_global"}),", ",(0,o.jsx)(n.code,{children:"borrow_global_mut"}),")"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"External modules and users can only interact with resources through the public functions that the defining module exposes. The internal state of a resource is completely protected."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module 0x1::coin {\n    struct Balance has key { value: u64 }\n\n    /// Only this module can create balances\n    public fun initialize(account: &signer) {\n        move_to(account, Balance { value: 0 });\n    }\n\n    /// Only this module can modify balances\n    public fun deposit(addr: address, amount: u64) acquires Balance {\n        let balance = borrow_global_mut<Balance>(addr);\n        balance.value = balance.value + amount;\n    }\n\n    /// External code can read but not modify\n    public fun get_balance(addr: address): u64 acquires Balance {\n        borrow_global<Balance>(addr).value\n    }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"This means \"ownership\" in Move is not just about where data is stored - it's about which module has permission to modify it. A token might be stored under your account, but only the token module's code can change its value."}),"\n",(0,o.jsx)(n.h2,{id:"storage-location",children:"Storage Location"}),"\n",(0,o.jsxs)(n.p,{children:["Resources live within the accounts that own them. When Alice holds CED tokens, the ",(0,o.jsx)(n.code,{children:"CoinStore<CED>"})," resource is stored under Alice's address, not under some global contract address."]}),"\n",(0,o.jsx)(n.p,{children:"To query a resource, you need the owner's address plus the resource type:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Account: 0xALICE\nResource: 0x1::coin::CoinStore<0x1::ced::CED>\n"})}),"\n",(0,o.jsx)(n.p,{children:"You can view resources through:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The Cedra Explorer - enter any address to see its resources"}),"\n",(0,o.jsxs)(n.li,{children:["Fullnode REST API - ",(0,o.jsx)(n.code,{children:"GET /accounts/{address}/resources"})]}),"\n",(0,o.jsxs)(n.li,{children:["SDK calls - ",(0,o.jsx)(n.code,{children:"client.getAccountResource(address, resourceType)"})]}),"\n"]}),"\n",(0,o.jsx)(n.mermaid,{value:'graph LR\n    subgraph "Query"\n        A[Account Address] --\x3e B[Resource Type]\n        B --\x3e C[Resource Data]\n    end\n\n    subgraph "Example"\n        D["0xALICE"] --\x3e E["0x1::coin::CoinStore"]\n        E --\x3e F["{ coin: { value: 1000 } }"]\n    end'}),"\n",(0,o.jsx)(n.h2,{id:"parallel-execution-benefits",children:"Parallel Execution Benefits"}),"\n",(0,o.jsx)(n.p,{children:"This per-account storage model is why Cedra can execute transactions in parallel. When Alice sends tokens to Bob while Carol sends tokens to Dave, these transactions touch completely different storage locations:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Alice's transaction: reads/writes Alice's ",(0,o.jsx)(n.code,{children:"CoinStore"}),", writes Bob's ",(0,o.jsx)(n.code,{children:"CoinStore"})]}),"\n",(0,o.jsxs)(n.li,{children:["Carol's transaction: reads/writes Carol's ",(0,o.jsx)(n.code,{children:"CoinStore"}),", writes Dave's ",(0,o.jsx)(n.code,{children:"CoinStore"})]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"No overlap means no conflicts, so both transactions can execute simultaneously."}),"\n",(0,o.jsx)(n.mermaid,{value:'graph TD\n    subgraph "Parallel Execution"\n        subgraph "Thread 1"\n            A1[Alice\'s CoinStore] --\x3e B1[Bob\'s CoinStore]\n        end\n        subgraph "Thread 2"\n            A2[Carol\'s CoinStore] --\x3e B2[Dave\'s CoinStore]\n        end\n    end\n\n    style A1 fill:#e8f5e9\n    style B1 fill:#e8f5e9\n    style A2 fill:#e3f2fd\n    style B2 fill:#e3f2fd'}),"\n",(0,o.jsx)(n.p,{children:"Compare this to Ethereum, where all ERC-20 transfers go through a single contract's storage. Every transfer must access the same contract state, creating a bottleneck that prevents parallel execution."}),"\n",(0,o.jsx)(n.admonition,{title:"Events and Receivers",type:"info",children:(0,o.jsx)(n.p,{children:"Events can also be stored in the receiver's account rather than emitted globally. This further reduces contention - Alice receiving tokens triggers an event stored under Alice's account, not in some shared event log."})}),"\n",(0,o.jsx)(n.h2,{id:"working-with-resources",children:"Working with Resources"}),"\n",(0,o.jsx)(n.p,{children:"Here's how you interact with resources in Move code:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module 0x1::example {\n    struct Counter has key {\n        value: u64,\n    }\n\n    /// Create a new counter under the signer's account\n    public fun create(account: &signer) {\n        move_to(account, Counter { value: 0 });\n    }\n\n    /// Check if an account has a counter\n    public fun exists_at(addr: address): bool {\n        exists<Counter>(addr)\n    }\n\n    /// Read the counter value\n    public fun get(addr: address): u64 acquires Counter {\n        borrow_global<Counter>(addr).value\n    }\n\n    /// Increment the counter (requires signer for access control)\n    public fun increment(account: &signer) acquires Counter {\n        let addr = signer::address_of(account);\n        let counter = borrow_global_mut<Counter>(addr);\n        counter.value = counter.value + 1;\n    }\n\n    /// Remove and destroy the counter\n    public fun destroy(account: &signer) acquires Counter {\n        let addr = signer::address_of(account);\n        let Counter { value: _ } = move_from<Counter>(addr);\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"acquires"})," annotation tells the compiler which resources a function accesses. This enables compile-time checking and helps with parallel execution planning."]}),"\n",(0,o.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/concepts/accounts/understanding-accounts",children:"Understanding Accounts"})," - Account fundamentals and types"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/concepts/accounts/authentication",children:"Authentication"})," - How accounts prove ownership"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/move/resource",children:"Move Resource Types"})," - Deep dive into resource programming"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/concepts/block-stm",children:"Block-STM"})," - How per-account storage enables parallel execution"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);