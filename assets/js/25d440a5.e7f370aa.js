"use strict";(self.webpackChunkcedra_docs=self.webpackChunkcedra_docs||[]).push([[18],{8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(6540);const o={},i=s.createContext(o);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},9126:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"move/resource","title":"Resource Types - The Heart of Move\'s Security Model","description":"Deep dive into Move\'s revolutionary resource types. Learn how linear types prevent duplication and loss of digital assets, making Move the safest language for blockchain development.","source":"@site/docs/move/resource.md","sourceDirName":"move","slug":"/move/resource","permalink":"/move/resource","draft":false,"unlisted":false,"editUrl":"https://github.com/cedra-labs/docs/edit/main/docs/move/resource.md","tags":[],"version":"current","frontMatter":{"title":"Resource Types - The Heart of Move\'s Security Model","description":"Deep dive into Move\'s revolutionary resource types. Learn how linear types prevent duplication and loss of digital assets, making Move the safest language for blockchain development.","keywords":["move resources","linear types","digital assets","blockchain security","resource safety","move programming"]},"sidebar":"docs","previous":{"title":"Functions in Move","permalink":"/move/functions"},"next":{"title":"Ownership & Borrowing","permalink":"/move/ownership"}}');var o=t(4848),i=t(8453);const r={title:"Resource Types - The Heart of Move's Security Model",description:"Deep dive into Move's revolutionary resource types. Learn how linear types prevent duplication and loss of digital assets, making Move the safest language for blockchain development.",keywords:["move resources","linear types","digital assets","blockchain security","resource safety","move programming"]},a="Resource Types: The Heart of Move's Security Model",c={},l=[{value:"The Four Abilities: Controlling Resource Behavior",id:"the-four-abilities-controlling-resource-behavior",level:2},{value:"Copy: The Ability Resources Don&#39;t Have",id:"copy-the-ability-resources-dont-have",level:3},{value:"Drop: Controlling Destruction",id:"drop-controlling-destruction",level:3},{value:"Store: Enabling Composition",id:"store-enabling-composition",level:3},{value:"Key: Global Storage Access",id:"key-global-storage-access",level:3},{value:"Linear Types in Action",id:"linear-types-in-action",level:2},{value:"Explicit Resource Handling",id:"explicit-resource-handling",level:3},{value:"Resource Destruction",id:"resource-destruction",level:3},{value:"Common Resource Patterns",id:"common-resource-patterns",level:2},{value:"The Capability Pattern",id:"the-capability-pattern",level:3},{value:"The Hot Potato Pattern",id:"the-hot-potato-pattern",level:3},{value:"Resource Wrappers",id:"resource-wrappers",level:3},{value:"Best Practices for Resource Design",id:"best-practices-for-resource-design",level:2},{value:"Use Phantom Types for Safety",id:"use-phantom-types-for-safety",level:3},{value:"Design for Composability",id:"design-for-composability",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Attempting to Copy Resources",id:"attempting-to-copy-resources",level:3},{value:"Forgetting to Handle Resources",id:"forgetting-to-handle-resources",level:3},{value:"Incorrect Ability Combinations",id:"incorrect-ability-combinations",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"What&#39;s Next?",id:"whats-next",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"resource-types-the-heart-of-moves-security-model",children:"Resource Types: The Heart of Move's Security Model"})}),"\n",(0,o.jsx)(n.p,{children:"In traditional programming, data can be freely copied and discarded. You can duplicate a bank balance variable, accidentally overwrite it, or let it go out of scope. This flexibility is dangerous when dealing with digital assets."}),"\n",(0,o.jsx)(n.p,{children:"Move takes a radically different approach. Resources are special types that follow strict rules:"}),"\n",(0,o.jsx)(n.admonition,{title:"See Resources in Action",type:"tip",children:(0,o.jsxs)(n.p,{children:["Want to see real resources? Our ",(0,o.jsx)(n.a,{href:"/guides/first-fa",children:"Fungible Asset Guide"})," shows how tokens use the resource model to prevent duplication, while ",(0,o.jsx)(n.a,{href:"/guides/first-nft",children:"NFTs"})," demonstrate unique, non-fungible resources. The ",(0,o.jsx)(n.a,{href:"/guides/escrow",children:"Escrow Contract"})," showcases complex resource management with time-locked funds."]})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct Coin has store {\n    value: u64\n}\n\nstruct NFT has key, store {\n    id: u64,\n    metadata: vector<u8>\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Notice what's missing? Neither struct has the ",(0,o.jsx)(n.code,{children:"copy"})," or ",(0,o.jsx)(n.code,{children:"drop"})," abilities. This makes them resources \u2013 linear types that must be explicitly handled. You can't duplicate a Coin or accidentally lose an NFT. The compiler enforces this at every step."]}),"\n",(0,o.jsx)(n.h2,{id:"the-four-abilities-controlling-resource-behavior",children:"The Four Abilities: Controlling Resource Behavior"}),"\n",(0,o.jsx)(n.p,{children:"Move's ability system gives you fine-grained control over how types behave. Understanding these abilities is crucial for resource programming."}),"\n",(0,o.jsx)(n.h3,{id:"copy-the-ability-resources-dont-have",children:"Copy: The Ability Resources Don't Have"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"copy"})," ability allows types to be duplicated. Resources deliberately lack this ability:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct Price has copy, drop {\n    amount: u64\n}\n\nstruct Token has store {\n    amount: u64\n}\n\nlet price = Price { amount: 100 };\nlet price2 = price;  \nlet price3 = price;  \n\nlet token = Token { amount: 100 };\nlet token2 = token;  \n"})}),"\n",(0,o.jsxs)(n.p,{children:["The Price struct can be copied freely \u2013 ",(0,o.jsx)(n.code,{children:"price"})," remains valid after creating ",(0,o.jsx)(n.code,{children:"price2"})," and ",(0,o.jsx)(n.code,{children:"price3"}),". Each variable has its own independent copy. This is perfect for data that represents information rather than value."]}),"\n",(0,o.jsxs)(n.p,{children:["The Token struct cannot be copied. After ",(0,o.jsx)(n.code,{children:"token2 = token"}),", the original ",(0,o.jsx)(n.code,{children:"token"})," variable is no longer accessible. The ownership has moved. This movement is tracked by the compiler, ensuring no tokens are created or destroyed accidentally."]}),"\n",(0,o.jsx)(n.h3,{id:"drop-controlling-destruction",children:"Drop: Controlling Destruction"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"drop"})," ability allows values to be discarded implicitly:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'struct LogEntry has drop {\n    message: vector<u8>,\n    timestamp: u64\n}\n\nstruct Ticket has store {\n    event_id: u64,\n    seat_number: u64\n}\n\nfun process_log() {\n    let log = LogEntry { \n        message: b"User logged in", \n        timestamp: 1234567890 \n    };\n}\n\nfun process_ticket() {\n    let ticket = Ticket { \n        event_id: 1, \n        seat_number: 42 \n    };\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["When ",(0,o.jsx)(n.code,{children:"process_log"})," ends, the LogEntry is automatically dropped \u2013 no special handling needed. This is convenient for temporary data that doesn't represent value."]}),"\n",(0,o.jsxs)(n.p,{children:["The Ticket in ",(0,o.jsx)(n.code,{children:"process_ticket"})," cannot be dropped. This code won't compile because the ticket must be explicitly handled. You must transfer it, store it, or explicitly destroy it. This prevents accidentally losing valuable assets."]}),"\n",(0,o.jsx)(n.h3,{id:"store-enabling-composition",children:"Store: Enabling Composition"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"store"})," ability allows types to be stored inside other structs:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct Coin has store {\n    value: u64\n}\n\nstruct NFT has key, store {\n    id: u64,\n    metadata: vector<u8>\n}\n\nstruct Wallet has key {\n    nfts: vector<NFT>\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["NFT have the ",(0,o.jsx)(n.code,{children:"store"})," ability, so it can be placed in containers. This enables building complex data structures while maintaining resource safety. Without ",(0,o.jsx)(n.code,{children:"store"}),", a type can only exist independently, not as part of other structures."]}),"\n",(0,o.jsxs)(n.p,{children:["The container (Wallet) has the ",(0,o.jsx)(n.code,{children:"key"})," ability, allowing it to exist in global storage. This creates a hierarchy: resources with ",(0,o.jsx)(n.code,{children:"store"})," live inside resources with ",(0,o.jsx)(n.code,{children:"key"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"key-global-storage-access",children:"Key: Global Storage Access"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"key"})," ability marks types that can exist at the top level of global storage:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct UserAccount has key {\n    balance: u64,\n    frozen: bool\n}\n\npublic fun create_account(user: &signer) {\n    let user_addr = signer::address_of(user);\n    assert!(!exists<UserAccount>(user_addr), ERROR_ACCOUNT_EXISTS);\n    \n    move_to(user, UserAccount {\n        balance: 0,\n        frozen: false\n    });\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Only types with ",(0,o.jsx)(n.code,{children:"key"})," can be published to addresses using ",(0,o.jsx)(n.code,{children:"move_to"}),". They become globally accessible resources that can be read with ",(0,o.jsx)(n.code,{children:"borrow_global"})," and modified with ",(0,o.jsx)(n.code,{children:"borrow_global_mut"}),". Each address can hold at most one instance of each ",(0,o.jsx)(n.code,{children:"key"})," type, creating natural uniqueness."]}),"\n",(0,o.jsxs)(n.admonition,{title:"Ability Combinations",type:"tip",children:[(0,o.jsx)(n.p,{children:"Common patterns for ability combinations:"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"has store"}),": Basic resources (tokens, items)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"has key, store"}),": Flexible resources (NFTs that can be stored or exist independently)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"has copy, drop"}),": Information/data types (prices, metadata)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"has key"}),": Singletons (user accounts, global configs)"]}),"\n",(0,o.jsx)(n.li,{children:"No abilities: Hot potatoes (must be handled immediately)"}),"\n"]})]}),"\n",(0,o.jsx)(n.h2,{id:"linear-types-in-action",children:"Linear Types in Action"}),"\n",(0,o.jsx)(n.p,{children:"Move's linear type system ensures every resource is accounted for. Let's see how this works in practice. When you assign a resource to a new variable or pass it to a function, ownership moves:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"public fun transfer_ownership() {\n    let coin = Coin { value: 100 };\n    let my_coin = coin;\n    \n    spend_coin(my_coin);\n}\n\nfun spend_coin(coin: Coin) {\n    let Coin { value } = coin;\n    emit_spent_event(value);\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["After ",(0,o.jsx)(n.code,{children:"my_coin = coin"}),", the variable ",(0,o.jsx)(n.code,{children:"coin"})," is no longer valid. The compiler tracks this movement and will error if you try to use ",(0,o.jsx)(n.code,{children:"coin"})," again. This isn't a limitation \u2013 it's a guarantee that resources can't be duplicated."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"spend_coin"})," function takes ownership of the coin. Inside the function, we destructure the coin with ",(0,o.jsx)(n.code,{children:"let Coin { value } = coin"}),". This pattern extracts the value and destroys the coin in one operation. The coin no longer exists after this line."]}),"\n",(0,o.jsx)(n.h3,{id:"explicit-resource-handling",children:"Explicit Resource Handling"}),"\n",(0,o.jsx)(n.p,{children:"Resources must be explicitly handled \u2013 you can't ignore them:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"public fun bad_function() {\n    let token = Token { amount: 50 };\n}\n\npublic fun good_function() {\n    let token = Token { amount: 50 };\n    store_token(token);\n}\n\nfun store_token(token: Token) acquires TokenVault {\n    let vault = borrow_global_mut<TokenVault>(@vault_address);\n    vector::push_back(&mut vault.tokens, token);\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"bad_function"})," creates a token but doesn't do anything with it. This won't compile \u2013 Move detects the unused resource. Every resource must be moved somewhere: into storage, to another function, or explicitly destroyed."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"good_function"})," properly handles the token by passing it to ",(0,o.jsx)(n.code,{children:"store_token"}),", which stores it in a vault. This explicit handling ensures no assets are lost."]}),"\n",(0,o.jsx)(n.h3,{id:"resource-destruction",children:"Resource Destruction"}),"\n",(0,o.jsx)(n.p,{children:"Sometimes you need to destroy resources intentionally. Move requires explicit destruction through pattern matching:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct RewardPoint has store {\n    value: u64\n}\n\npublic fun burn_points(points: RewardPoint): u64 {\n    let RewardPoint { value } = points;\n    emit_burn_event(value);\n    value\n}\n\npublic fun merge_points(points1: RewardPoint, points2: RewardPoint): RewardPoint {\n    let RewardPoint { value: value1 } = points1;\n    let RewardPoint { value: value2 } = points2;\n    \n    RewardPoint { value: value1 + value2 }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The destructuring pattern ",(0,o.jsx)(n.code,{children:"let RewardPoint { value } = points"})," unpacks the struct and destroys it. After this line, ",(0,o.jsx)(n.code,{children:"points"})," no longer exists, but we have its inner ",(0,o.jsx)(n.code,{children:"value"}),". This makes resource destruction explicit and intentional."]}),"\n",(0,o.jsxs)(n.p,{children:["In ",(0,o.jsx)(n.code,{children:"merge_points"}),", we destroy two RewardPoint resources and create a new one with the combined value. The total number of points is preserved \u2013 we can't create or destroy value, only transform it."]}),"\n",(0,o.jsxs)(n.admonition,{title:"Resource Conservation Law",type:"warning",children:[(0,o.jsx)(n.p,{children:"Just like energy in physics, resources in Move follow a conservation law:"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Resources cannot be created from nothing (except by authorized minters)"}),"\n",(0,o.jsx)(n.li,{children:"Resources cannot be destroyed into nothing (except by explicit burning)"}),"\n",(0,o.jsx)(n.li,{children:"Resources can only be transformed or transferred"}),"\n",(0,o.jsx)(n.li,{children:"The total amount is always conserved"}),"\n"]})]}),"\n",(0,o.jsx)(n.h2,{id:"common-resource-patterns",children:"Common Resource Patterns"}),"\n",(0,o.jsx)(n.p,{children:"Certain patterns emerge repeatedly when working with resources. Understanding these patterns helps you write safer, more efficient code."}),"\n",(0,o.jsx)(n.h3,{id:"the-capability-pattern",children:"The Capability Pattern"}),"\n",(0,o.jsx)(n.p,{children:"Capabilities are resources that represent permissions or rights:"}),"\n",(0,o.jsx)(n.admonition,{title:"Real Implementation",type:"info",children:(0,o.jsxs)(n.p,{children:["Our ",(0,o.jsx)(n.a,{href:"/guides/first-fa#211-init_module---bootstrap",children:"Fungible Asset Guide"})," shows this pattern in production with ",(0,o.jsx)(n.code,{children:"MintRef"})," and ",(0,o.jsx)(n.code,{children:"BurnRef"})," capabilities. These resources control who can create or destroy tokens, making permission management explicit and secure."]})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct MintCapability has key, store {\n    supply_limit: u64,\n    minted_so_far: u64\n}\n\nstruct BurnCapability has key, store {\n    authorized_burner: address\n}\n\npublic fun mint_tokens(\n    cap: &mut MintCapability,\n    amount: u64\n): Token {\n    assert!(\n        cap.minted_so_far + amount <= cap.supply_limit,\n        ERROR_EXCEEDS_SUPPLY\n    );\n    \n    cap.minted_so_far = cap.minted_so_far + amount;\n    Token { amount }\n}\n\npublic fun burn_tokens(\n    cap: &BurnCapability,\n    token: Token,\n    burner: address\n): u64 {\n    assert!(cap.authorized_burner == burner, ERROR_UNAUTHORIZED);\n    \n    let Token { amount } = token;\n    emit_burn_event(amount);\n    amount\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"The MintCapability is a resource that controls token creation. Having a reference to this capability proves you're authorized to mint. The capability tracks how many tokens have been minted, enforcing supply limits. Because it's a resource, the capability can't be forged or duplicated."}),"\n",(0,o.jsx)(n.p,{children:"The BurnCapability works similarly but for destruction. Only the authorized burner can destroy tokens. This pattern separates permission (having the capability) from action (minting/burning), making systems more flexible and secure."}),"\n",(0,o.jsx)(n.h3,{id:"the-hot-potato-pattern",children:"The Hot Potato Pattern"}),"\n",(0,o.jsx)(n.p,{children:'A "hot potato" is a resource without any abilities \u2013 it must be handled immediately:'}),"\n",(0,o.jsx)(n.admonition,{title:"Pattern Example",type:"success",children:(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.a,{href:"/guides/escrow#escrow",children:"Escrow Contract"})," uses a similar pattern with its time-locked escrows. Once created, these resources must be explicitly claimed or refunded - they can't be forgotten or ignored."]})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct Receipt {\n    amount: u64,\n    payer: address\n}\n\npublic fun start_payment(payer: &signer, amount: u64): Receipt {\n    let payer_addr = signer::address_of(payer);\n    withdraw_from_account(payer, amount);\n    \n    Receipt { amount, payer: payer_addr }\n}\n\npublic fun complete_payment(receipt: Receipt, recipient: address) {\n    let Receipt { amount, payer } = receipt;\n    deposit_to_account(recipient, amount);\n    emit_payment_event(payer, recipient, amount);\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The Receipt has no abilities \u2013 it can't be stored, copied, or dropped. When ",(0,o.jsx)(n.code,{children:"start_payment"})," returns a Receipt, the caller must immediately pass it to ",(0,o.jsx)(n.code,{children:"complete_payment"}),'. There\'s no way to "forget" about the payment or store the receipt for later.']}),"\n",(0,o.jsx)(n.p,{children:"This pattern ensures atomic operations. The payment must be completed in the same transaction where it started. It's impossible to leave the system in an inconsistent state."}),"\n",(0,o.jsx)(n.h3,{id:"resource-wrappers",children:"Resource Wrappers"}),"\n",(0,o.jsx)(n.p,{children:"Sometimes you need to temporarily give resources abilities they don't naturally have:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct LockedCoin has key {\n    coin: Coin,\n    unlock_time: u64\n}\n\npublic fun lock_coins(\n    owner: &signer,\n    coin: Coin,\n    lock_duration: u64\n) {\n    let unlock_time = timestamp::now_seconds() + lock_duration;\n    move_to(owner, LockedCoin { coin, unlock_time });\n}\n\npublic fun unlock_coins(owner: &signer): Coin acquires LockedCoin {\n    let owner_addr = signer::address_of(owner);\n    let LockedCoin { coin, unlock_time } = move_from<LockedCoin>(owner_addr);\n    \n    assert!(\n        timestamp::now_seconds() >= unlock_time,\n        ERROR_STILL_LOCKED\n    );\n    \n    coin\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The Coin resource doesn't have the ",(0,o.jsx)(n.code,{children:"key"})," ability, so it can't exist in global storage directly. By wrapping it in LockedCoin (which has ",(0,o.jsx)(n.code,{children:"key"}),"), we can store it at an address. The wrapper adds the time-lock functionality while preserving the underlying resource."]}),"\n",(0,o.jsx)(n.p,{children:"When unlocking, we unwrap the coin and return it. The LockedCoin wrapper is destroyed, but the inner Coin resource is preserved and returned to the caller."}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"\ud83d\udcda More Resource Patterns"}),(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Flash Loan Pattern"}),": Borrow and return in same transaction"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct FlashLoan<phantom T> {\n    amount: u64,\n    borrowed_at: u64\n}\n\npublic fun borrow<T>(amount: u64): (Coin<T>, FlashLoan<T>) {\n    // Withdraw from pool and create loan receipt\n}\n\npublic fun repay<T>(coin: Coin<T>, loan: FlashLoan<T>) {\n    // Verify same transaction and amount matches\n}\n"})}),(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Escrow Pattern"}),": Hold resources until conditions met"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct Escrow<phantom T> has key {\n    seller: address,\n    buyer: address,\n    item: T,\n    price: u64\n}\n"})})]}),"\n",(0,o.jsx)(n.h2,{id:"best-practices-for-resource-design",children:"Best Practices for Resource Design"}),"\n",(0,o.jsx)(n.p,{children:"Resources should contain only essential data:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct Token has store {\n    amount: u64\n}\n\nstruct TokenMetadata has copy, drop, store {\n    name: vector<u8>,\n    symbol: vector<u8>,\n    decimals: u8\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"The Token resource contains only the value. Metadata is a separate, copyable struct. This separation keeps resources lightweight and allows metadata to be freely shared without risking the actual assets."}),"\n",(0,o.jsx)(n.h3,{id:"use-phantom-types-for-safety",children:"Use Phantom Types for Safety"}),"\n",(0,o.jsx)(n.p,{children:"Phantom types prevent mixing incompatible resources:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct Balance<phantom TokenType> has key {\n    amount: u64\n}\n\npublic fun transfer<TokenType>(\n    from: address,\n    to: address,\n    amount: u64\n) acquires Balance {\n    let from_balance = borrow_global_mut<Balance<TokenType>>(from);\n    assert!(from_balance.amount >= amount, ERROR_INSUFFICIENT);\n    from_balance.amount = from_balance.amount - amount;\n    \n    let to_balance = borrow_global_mut<Balance<TokenType>>(to);\n    to_balance.amount = to_balance.amount + amount;\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Even though all balances store just a ",(0,o.jsx)(n.code,{children:"u64"}),", the phantom type ensures you can't accidentally transfer USDC when you meant to transfer APT. The type system enforces this at compile time with zero runtime cost."]}),"\n",(0,o.jsx)(n.h3,{id:"design-for-composability",children:"Design for Composability"}),"\n",(0,o.jsx)(n.p,{children:"Make resources that work well together:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct Coin<phantom TokenType> has store {\n    amount: u64\n}\n\nstruct Vault<phantom TokenType> has key {\n    coins: Coin<TokenType>,\n    withdraw_capability: Option<WithdrawCap>\n}\n\nstruct WithdrawCap has store {\n    vault_owner: address,\n    max_amount: Option<u64>\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"These resources compose naturally. Coins go in Vaults, Vaults can issue WithdrawCaps, and the whole system maintains resource safety. Each piece has a clear purpose and combines predictably with others."}),"\n",(0,o.jsxs)(n.admonition,{title:"Design Principle",type:"info",children:[(0,o.jsx)(n.p,{children:"Think of resources like LEGO blocks:"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Each piece has a specific shape (abilities)"}),"\n",(0,o.jsx)(n.li,{children:"They connect in predictable ways (type compatibility)"}),"\n",(0,o.jsx)(n.li,{children:"Complex structures emerge from simple pieces (composability)"}),"\n",(0,o.jsx)(n.li,{children:"You can't force incompatible pieces together (type safety)"}),"\n"]})]}),"\n",(0,o.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,o.jsx)(n.h3,{id:"attempting-to-copy-resources",children:"Attempting to Copy Resources"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"let token = Token { amount: 100 };\nlet token_copy = token;\nlet another_copy = token;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This won't compile. After ",(0,o.jsx)(n.code,{children:"token_copy = token"}),", the original ",(0,o.jsx)(n.code,{children:"token"})," is moved and no longer accessible. Design your code with movement in mind."]}),"\n",(0,o.jsx)(n.h3,{id:"forgetting-to-handle-resources",children:"Forgetting to Handle Resources"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"public fun broken_swap(input: Token<X>): Token<Y> {\n    let output = get_output_amount(input);\n    create_token<Y>(output)\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"This function takes an input token but never handles it. The compiler will reject this. You must explicitly store, transfer, or destroy every resource."}),"\n",(0,o.jsx)(n.h3,{id:"incorrect-ability-combinations",children:"Incorrect Ability Combinations"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct BrokenNFT has copy, key {\n    id: u64\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["An NFT with ",(0,o.jsx)(n.code,{children:"copy"})," defeats the purpose \u2013 anyone could duplicate it. Think carefully about which abilities make sense for your use case."]}),"\n",(0,o.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,o.jsx)(n.p,{children:"Resource types are Move's superpower for blockchain development:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Linear types ensure conservation"}),": Resources can't be created or destroyed accidentally"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Abilities provide fine control"}),": Choose exactly how your types can be used"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Compiler enforcement"}),": Resource safety is guaranteed at compile time"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Composable patterns"}),": Build complex systems from simple, safe components"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Resources might feel restrictive at first, but they're actually liberating. They free you from worrying about duplication bugs, lost assets, or inconsistent state. The compiler has your back."}),"\n",(0,o.jsx)(n.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,o.jsxs)(n.p,{children:["In our next article, ",(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.a,{href:"/move/ownership",children:"Move Ownership and Borrowing"})}),", we'll dive deep into Move's ownership system. You'll learn how references work, when to use mutable vs immutable borrows, and patterns for efficient resource access without taking ownership."]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);