"use strict";(self.webpackChunkcedra_docs=self.webpackChunkcedra_docs||[]).push([[705],{4899:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"guides/dex/client-integration","title":"DEX Client Integration Guide","description":"Building a user-friendly client is crucial for DEX adoption. This tutorial walks through creating a TypeScript client that interacts with your Cedra DEX, demonstrating best practices for wallet integration, transaction handling, and user experience.","source":"@site/docs/guides/dex/client-integration.md","sourceDirName":"guides/dex","slug":"/guides/dex/client-integration","permalink":"/guides/dex/client-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/cedra-labs/docs/edit/main/docs/guides/dex/client-integration.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Multi-hop Routing for Optimal Execution","permalink":"/guides/dex/multi-hop-routing"},"next":{"title":"Glossary","permalink":"/glossary"}}');var o=t(4848),i=t(8453);const r={},s="DEX Client Integration Guide",c={},l=[{value:"What You&#39;ll Learn",id:"what-youll-learn",level:3},{value:"Configuration Structure",id:"configuration-structure",level:3},{value:"Display Utilities",id:"display-utilities",level:3},{value:"Account Management",id:"account-management",level:3},{value:"Token Operations",id:"token-operations",level:3},{value:"Pool Management",id:"pool-management",level:3},{value:"Liquidity Operations",id:"liquidity-operations",level:3},{value:"Swap Implementation",id:"swap-implementation",level:3},{value:"\ud83c\udf89 Congratulations, DEX Builder!",id:"-congratulations-dex-builder",level:2},{value:"Continue Your Journey",id:"continue-your-journey",level:3}];function u(n){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"dex-client-integration-guide",children:"DEX Client Integration Guide"})}),"\n",(0,o.jsx)(e.p,{children:"Building a user-friendly client is crucial for DEX adoption. This tutorial walks through creating a TypeScript client that interacts with your Cedra DEX, demonstrating best practices for wallet integration, transaction handling, and user experience."}),"\n",(0,o.jsx)(e.admonition,{title:"Complete DEX Source Code",type:"tip",children:(0,o.jsxs)(e.p,{children:["View the full Move implementation: ",(0,o.jsx)(e.a,{href:"https://github.com/cedra-labs/move-contract-examples/tree/main/dex",children:(0,o.jsx)(e.code,{children:"cedra-labs/move-contract-examples/dex"})})]})}),"\n",(0,o.jsx)(e.h3,{id:"what-youll-learn",children:"What You'll Learn"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Setting up Cedra TypeScript SDK"}),"\n",(0,o.jsx)(e.li,{children:"Implementing core DEX operations"}),"\n",(0,o.jsx)(e.li,{children:"Building educational examples"}),"\n",(0,o.jsx)(e.li,{children:"Error handling and user feedback"}),"\n",(0,o.jsx)(e.li,{children:"Best practices for production clients"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"configuration-structure",children:"Configuration Structure"}),"\n",(0,o.jsxs)(e.p,{children:["Our story begins with project setup. You'll create a clean TypeScript configuration that connects to the Cedra network. The ",(0,o.jsx)(e.code,{children:"config.ts"})," file becomes your command center, defining network endpoints and module addresses. Think of it as setting up your workshop before crafting something beautiful."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:'// config.ts\nimport { Cedra, CedraConfig, Network } from "@cedra-labs/ts-sdk";\n\nexport const NETWORK: Network = Network.TESTNET;\nexport const NODE_URL = "https://testnet.cedra.network/v1";\nexport const MODULE_ADDRESS = "0x..."; // Your deployed DEX address\n\nconst config: CedraConfig = {\n  network: NETWORK,\n  nodeUrl: NODE_URL,\n};\n\nexport const cedra = new Cedra(config);\n\nexport const MODULES = {\n  math_amm: `${MODULE_ADDRESS}::math_amm`,\n  swap: `${MODULE_ADDRESS}::swap`,\n  slippage: `${MODULE_ADDRESS}::slippage`,\n  multihop: `${MODULE_ADDRESS}::multihop`,\n  test_tokens: `${MODULE_ADDRESS}::test_tokens`,\n};\n'})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h3,{id:"display-utilities",children:"Display Utilities"}),"\n",(0,o.jsxs)(e.p,{children:["Raw blockchain data is intimidating - numbers like 1000000000 don't mean much to users. Your first set of functions transforms these machine values into human-readable formats. The ",(0,o.jsx)(e.code,{children:"formatAmount()"}),' function turns those scary numbers into friendly "10.5 ETH". The ',(0,o.jsx)(e.code,{children:"displayBalances()"})," function creates beautiful ASCII tables that make users smile when checking their tokens."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:'// Format token amounts for display\nexport function formatAmount(amount: number, symbol: string = ""): string {\n  const formatted = (amount / Math.pow(10, TOKEN_DECIMALS)).toFixed(4);\n  return symbol ? `${formatted} ${symbol}` : formatted;\n}\n\n// Display token balances in a table format\nexport async function displayBalances(\n  account: string,\n  tokens: Array<{ symbol: string; metadata: string; decimals: number }>\n): Promise<void> {\n  console.log("\\n\ud83d\udcb0 Token Balances:");\n  console.log("\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510");\n  console.log("\u2502 Token   \u2502 Balance          \u2502");\n  console.log("\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524");\n  \n  for (const token of tokens) {\n    const balance = await getTokenBalance(account, token.metadata);\n    const formatted = formatAmount(balance, token.symbol);\n    console.log(`\u2502 ${token.symbol.padEnd(7)} \u2502 ${formatted.padStart(16)} \u2502`);\n  }\n  \n  console.log("\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518");\n}\n'})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h3,{id:"account-management",children:"Account Management"}),"\n",(0,o.jsxs)(e.p,{children:["Next, you'll implement account creation and funding. The ",(0,o.jsx)(e.code,{children:"setupAccounts()"})," function generates test wallets - Alice and Bob become your first traders. The funding functions ensure they have tokens to play with. This is where users first feel the magic - watching their newly created account receive its first tokens."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:'// Fund account with test tokens\nexport async function fundAccount(account: Account): Promise<void> {\n  console.log(`\\n\ud83d\udcb3 Funding account ${account.accountAddress.toString().slice(0, 6)}...`);\n  await cedra.fundAccount({\n    accountAddress: account.accountAddress,\n    amount: 1_000_000_000, // 10 CEDRA\n  });\n  console.log("   \u2713 Account funded with 10 CEDRA");\n}\n\n// Create and prepare test accounts\nasync function setupAccounts(): Promise<{ alice: Account; bob: Account }> {\n  const alice = Account.generate();\n  const bob = Account.generate();\n  \n  console.log("\ud83d\udcdd Creating test accounts:");\n  console.log(`   \u2022 Alice: ${alice.accountAddress.toString()}`);\n  console.log(`   \u2022 Bob: ${bob.accountAddress.toString()}`);\n  \n  await fundAccount(alice);\n  await fundAccount(bob);\n  \n  return { alice, bob };\n}\n'})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h3,{id:"token-operations",children:"Token Operations"}),"\n",(0,o.jsxs)(e.p,{children:["The token functions are where things get interesting. ",(0,o.jsx)(e.code,{children:"getTokenMetadata()"})," navigates the complex world of token standards, extracting the addresses your DEX needs. The ",(0,o.jsx)(e.code,{children:"mintTestTokens()"})," function gives users their trading ammunition. Each successful mint shows a satisfying confirmation message, making users feel in control."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:'// Get token metadata address\nexport async function getTokenMetadata(tokenType: string): Promise<string> {\n  const functionName = tokenType === "ETH" ? "get_eth_metadata" :\n                      tokenType === "BTC" ? "get_btc_metadata" :\n                      "get_usdc_metadata";\n  \n  const result = await cedra.view({\n    payload: {\n      function: `${MODULES.test_tokens}::${functionName}`,\n      typeArguments: [],\n      functionArguments: [],\n    }\n  });\n  \n  // Handle nested metadata object\n  const metadata = result[0];\n  if (typeof metadata === \'object\' && metadata !== null && \'inner\' in metadata) {\n    const inner = metadata.inner as string;\n    return inner.startsWith(\'0x\') ? inner : `0x${inner}`;\n  }\n  return metadata.toString();\n}\n\n// Mint test tokens\nexport async function mintTestTokens(\n  account: Account,\n  tokenType: string,\n  amount: number\n): Promise<void> {\n  console.log(`\\n\ud83e\ude99  Minting ${formatAmount(amount)} test ${tokenType}...`);\n  \n  const transaction = await cedra.transaction.build.simple({\n    sender: account.accountAddress,\n    data: {\n      function: `${MODULES.test_tokens}::mint_${tokenType.toLowerCase()}`,\n      typeArguments: [],\n      functionArguments: [amount],\n    },\n  });\n\n  const pendingTxn = await cedra.signAndSubmitTransaction({\n    signer: account,\n    transaction,\n  });\n\n  await cedra.waitForTransaction({ transactionHash: pendingTxn.hash });\n  console.log(`   \u2713 Minted successfully (tx: ${pendingTxn.hash.slice(0, 10)}...)`);\n}\n'})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h3,{id:"pool-management",children:"Pool Management"}),"\n",(0,o.jsxs)(e.p,{children:["This is where your DEX comes alive. The ",(0,o.jsx)(e.code,{children:"createTradingPair()"})," function births new markets with a single call. Users watch as their transaction creates a whole new trading opportunity. The ",(0,o.jsx)(e.code,{children:"getReserves()"})," function becomes their window into pool health, showing real-time liquidity depths."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"// Create a new trading pair\nexport async function createTradingPair(\n  account: Account,\n  tokenX: string,\n  tokenY: string\n): Promise<string> {\n  console.log(\"\\n\ud83d\udd04 Creating trading pair...\");\n  \n  const transaction = await cedra.transaction.build.simple({\n    sender: account.accountAddress,\n    data: {\n      function: `${MODULES.swap}::create_pair_entry`,\n      typeArguments: [],\n      functionArguments: [tokenX, tokenY],\n    },\n  });\n\n  const pendingTxn = await cedra.signAndSubmitTransaction({\n    signer: account,\n    transaction,\n  });\n\n  const result = await cedra.waitForTransaction({ transactionHash: pendingTxn.hash });\n  \n  // Extract LP token address from state changes\n  let lpToken = \"\";\n  if ('changes' in result && Array.isArray(result.changes)) {\n    for (const change of result.changes) {\n      if (change.type === 'write_resource' && \n          change.data?.type?.includes('::swap::TradingPair')) {\n        lpToken = change.address;\n        break;\n      }\n    }\n  }\n  \n  console.log(`   \u2713 Trading pair created`);\n  console.log(`   \u2022 LP Token: ${lpToken}`);\n  \n  return lpToken;\n}\n\n// Get pool reserves\nexport async function getReserves(lpMetadata: string): Promise<[number, number]> {\n  try {\n    const result = await cedra.view({\n      payload: {\n        function: `${MODULES.swap}::reserves`,\n        typeArguments: [],\n        functionArguments: [lpMetadata],\n      }\n    });\n    \n    return [Number(result[0]), Number(result[1])];\n  } catch (error) {\n    return [0, 0];\n  }\n}\n"})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h3,{id:"liquidity-operations",children:"Liquidity Operations"}),"\n",(0,o.jsxs)(e.p,{children:["The ",(0,o.jsx)(e.code,{children:"addLiquidity()"})," function transforms users from traders to market makers. The code automatically calculates slippage protection - users don't need to understand the math, they just see their liquidity being added safely. The function returns LP tokens as proof of their contribution, like receiving shares in the market they're helping create."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"export async function addLiquidity(\n  account: Account,\n  lpToken: string,\n  tokenX: string,\n  tokenY: string,\n  amountX: number,\n  amountY: number,\n  minAmountX?: number,\n  minAmountY?: number\n): Promise<void> {\n  console.log(`\\n\ud83d\udca7 Adding liquidity: ${formatAmount(amountX)} + ${formatAmount(amountY)}...`);\n  \n  // Default 1% slippage if not specified\n  const slippageFactor = 0.99;\n  const actualMinX = minAmountX ?? Math.floor(amountX * slippageFactor);\n  const actualMinY = minAmountY ?? Math.floor(amountY * slippageFactor);\n  \n  const transaction = await cedra.transaction.build.simple({\n    sender: account.accountAddress,\n    data: {\n      function: `${MODULES.swap}::add_liquidity`,\n      typeArguments: [],\n      functionArguments: [\n        lpToken, tokenX, tokenY, \n        amountX, amountY, \n        actualMinX, actualMinY\n      ],\n    },\n  });\n\n  const pendingTxn = await cedra.signAndSubmitTransaction({\n    signer: account,\n    transaction,\n  });\n\n  await cedra.waitForTransaction({ transactionHash: pendingTxn.hash });\n  \n  const lpBalance = await getTokenBalance(account.accountAddress.toString(), lpToken);\n  console.log(`   \u2713 Liquidity added successfully`);\n  console.log(`   \u2022 LP tokens received: ${formatAmount(lpBalance)}`);\n}\n"})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h3,{id:"swap-implementation",children:"Swap Implementation"}),"\n",(0,o.jsxs)(e.p,{children:["The crown jewel - ",(0,o.jsx)(e.code,{children:"executeSwap()"}),". This function orchestrates the entire trading experience:"]}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Balance Check"}),": Verifies sufficient funds (no embarrassing failed transactions)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Output Preview"}),": Calculates expected returns (users see what they'll get)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Protected Execution"}),": Applies slippage limits (keeps trades safe)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Transparent Results"}),": Shows actual outcomes (builds user trust)"]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["The ",(0,o.jsx)(e.code,{children:"calculateSwapOutput()"})," helper lets users preview their trades. They can experiment with different amounts, watching how price impact changes, learning by doing rather than reading formulas."]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-typescript",children:"export async function executeSwap(\n  account: Account,\n  lpToken: string,\n  tokenIn: string,\n  tokenOut: string,\n  amountIn: number,\n  minAmountOut: number = 0\n): Promise<number> {\n  console.log(`\\n\ud83d\udd04 Swapping ${formatAmount(amountIn)} tokens...`);\n  \n  // Get initial balance to calculate actual output\n  const initialBalance = await getTokenBalance(\n    account.accountAddress.toString(), \n    tokenOut\n  );\n  \n  const transaction = await cedra.transaction.build.simple({\n    sender: account.accountAddress,\n    data: {\n      function: `${MODULES.swap}::swap_exact_input`,\n      typeArguments: [],\n      functionArguments: [lpToken, tokenIn, tokenOut, amountIn, minAmountOut],\n    },\n  });\n\n  const pendingTxn = await cedra.signAndSubmitTransaction({\n    signer: account,\n    transaction,\n  });\n\n  await cedra.waitForTransaction({ transactionHash: pendingTxn.hash });\n  \n  const finalBalance = await getTokenBalance(\n    account.accountAddress.toString(), \n    tokenOut\n  );\n  const actualOutput = finalBalance - initialBalance;\n  \n  console.log(`   \u2713 Swap completed`);\n  console.log(`   \u2022 Amount out: ${formatAmount(actualOutput)}`);\n  \n  return actualOutput;\n}\n\n// Calculate expected swap output\nexport async function calculateSwapOutput(\n  amountIn: number,\n  reserveIn: number,\n  reserveOut: number\n): Promise<number> {\n  const [amountOut] = await cedra.view({\n    payload: {\n      function: `${MODULES.math_amm}::get_amount_out`,\n      typeArguments: [],\n      functionArguments: [amountIn, reserveIn, reserveOut],\n    }\n  });\n  return Number(amountOut);\n}\n"})}),"\n",(0,o.jsx)(e.p,{children:"Your DEX client is now ready to provide a smooth trading experience!"}),"\n",(0,o.jsx)(e.h2,{id:"-congratulations-dex-builder",children:"\ud83c\udf89 Congratulations, DEX Builder!"}),"\n",(0,o.jsx)(e.p,{children:"You've completed the entire Cedra DEX Development Course!\nFrom your first Move contract to this polished TypeScript client, you've built a complete decentralized exchange. You understand not just how DEXs work, but how to make them work for real users.\nYour DEX can now:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Create markets for any token pair"}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Execute swaps with professional-grade safety features"}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Manage liquidity with automatic optimization"}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Teach users through interactive examples"}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"Handle errors gracefully and informatively"}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"You're no longer just learning about DeFi - you're building it. Every line of code in this client represents knowledge earned through the course."}),"\n",(0,o.jsx)(e.h3,{id:"continue-your-journey",children:"Continue Your Journey"}),"\n",(0,o.jsx)(e.p,{children:"Now that you've mastered DEX development, explore these related challenges:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Token Creation"}),": Ready to create your own trading pairs? Start with our ",(0,o.jsx)(e.a,{href:"/guides/first-fa",children:"First FA Guide"})," to mint custom tokens for your DEX"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Advanced Patterns"}),": Dive into our ",(0,o.jsx)(e.a,{href:"https://github.com/cedra-labs/move-contract-examples",children:"Move examples repository"})," for governance, staking, and other DeFi primitives to enhance your DEX"]}),"\n"]})]})}function d(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(u,{...n})}):u(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>s});var a=t(6540);const o={},i=a.createContext(o);function r(n){const e=a.useContext(i);return a.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),a.createElement(i.Provider,{value:e},n.children)}}}]);