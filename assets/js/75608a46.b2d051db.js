"use strict";(self.webpackChunkcedra_docs=self.webpackChunkcedra_docs||[]).push([[510],{7899:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>u,frontMatter:()=>c,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"guides/escrow","title":"Build an Escrow Contract","description":"In this guide, we\'ll walk through how escrow works by explaining its flow. We\'ll cover how funds are locked, released, or returned in a secure and predictable way.","source":"@site/docs/guides/escrow.md","sourceDirName":"guides","slug":"/guides/escrow","permalink":"/guides/escrow","draft":false,"unlisted":false,"editUrl":"https://github.com/cedra-labs/docs/edit/main/docs/guides/escrow.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Build an Escrow Contract","sidebar_position":3},"sidebar":"docs","previous":{"title":"Build a Fee Splitter Contract","permalink":"/guides/fee-splitter"},"next":{"title":"Glossary","permalink":"/glossary"}}');var r=s(4848),o=s(8453);const c={title:"Build an Escrow Contract",sidebar_position:3},i="Build an Escrow Contract",a={},l=[{value:"Before we start - check these resources",id:"before-we-start---check-these-resources",level:2},{value:"Core Data Structures",id:"core-data-structures",level:2},{value:"<code>LockupRef</code>",id:"lockupref",level:3},{value:"<code>Lockup</code>",id:"lockup",level:3},{value:"<code>Escrow</code>",id:"escrow",level:3},{value:"Step 1: Creating a Lockup",id:"step-1-creating-a-lockup",level:2},{value:"Step 2: Locking Funds into Escrow",id:"step-2-locking-funds-into-escrow",level:2},{value:"Simple Escrow",id:"simple-escrow",level:3},{value:"Time-Locked Escrow",id:"time-locked-escrow",level:3},{value:"Step 3: Releasing Funds",id:"step-3-releasing-funds",level:2},{value:"Claim by Lockup Owner",id:"claim-by-lockup-owner",level:3},{value:"Return by Lockup Owner",id:"return-by-lockup-owner",level:3},{value:"Return by Original Sender (Self-Unlock)",id:"return-by-original-sender-self-unlock",level:3},{value:"Step 4: Checking Status",id:"step-4-checking-status",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"What&#39;s Next?",id:"whats-next",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"build-an-escrow-contract",children:"Build an Escrow Contract"})}),"\n",(0,r.jsx)(n.p,{children:"In this guide, we'll walk through how escrow works by explaining its flow. We'll cover how funds are locked, released, or returned in a secure and predictable way."}),"\n",(0,r.jsx)(n.p,{children:"The escrow system supports two types of locking:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Simple escrow (manual release)"}),"\n",(0,r.jsx)(n.li,{children:"Time-locked escrow (claimable after a specific time)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"before-we-start---check-these-resources",children:"Before we start - check these resources"}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.mdxAdmonitionTitle,{children:[(0,r.jsx)(n.strong,{children:"Source code"}),": ",(0,r.jsx)(n.a,{href:"https://github.com/cedra-labs/move-contract-examples/tree/main/fa-lock",children:"GitHub \u2013 escrow module"})]})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Local dev env (",(0,r.jsx)(n.a,{href:"/",children:"ENV"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["A fungible asset (like the one from ",(0,r.jsx)(n.a,{href:"/guides/first-fa",children:"First FA"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"core-data-structures",children:"Core Data Structures"}),"\n",(0,r.jsx)(n.p,{children:"Escrow module is built around three key data types that enable object-level control over token locking. Understanding these will help you reason about how escrows are tracked and managed."}),"\n",(0,r.jsxs)(n.admonition,{title:"Move Fundamentals in Use",type:"info",children:[(0,r.jsx)(n.p,{children:"This escrow implementation leverages several Move concepts:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/move/resource",children:"Resource Management"})})," - Escrows are resources that must be explicitly handled"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/move/ownership#global-storage-borrowing",children:"Global Storage"})})," - Using ",(0,r.jsx)(n.code,{children:"borrow_global_mut"})," for lockup access"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/move/flow#pattern-matching-and-destructuring",children:"Pattern Matching"})})," - Destructuring escrow variants"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/move/flow#control-flow-patterns",children:"Time-based Logic"})})," - Implementing time locks with control flow"]}),"\n"]})]}),"\n",(0,r.jsx)(n.h3,{id:"lockupref",children:(0,r.jsx)(n.code,{children:"LockupRef"})}),"\n",(0,r.jsxs)(n.p,{children:["A small resource that lives in the user's account. It stores the address of the user's ",(0,r.jsx)(n.code,{children:"Lockup"})," object."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"/// The lookup to object for escrow in an easily addressible spot\nstruct LockupRef has key {\n    lockup_address: address,\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Why it's important"}),": it prevents multiple lockups per account and keeps the link between the account and their escrow manager explicit."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Think of it as"}),": a pointer from your wallet to your personal escrow vault."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"lockup",children:(0,r.jsx)(n.code,{children:"Lockup"})}),"\n",(0,r.jsx)(n.p,{children:"An on-chain object that manages all escrow entries for a single user."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"/// A single lockup, which has the same lockup period for all of them\nenum Lockup has key {\n    ST {\n        creator: address,\n        /// Used to control funds in the escrows\n        extend_ref: ExtendRef,\n        /// Used to cleanup the Lockup object\n        delete_ref: DeleteRef,\n        escrows: SmartTable<EscrowKey, address>\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["It has a field called ",(0,r.jsx)(n.code,{children:"escrows"}),", which is a dynamic map of all ongoing escrows the user has opened."]}),"\n",(0,r.jsxs)(n.li,{children:["It also holds ",(0,r.jsx)(n.code,{children:"extend_ref"})," and ",(0,r.jsx)(n.code,{children:"delete_ref"})," to manage storage properly."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Why it's important"}),": This is your actual escrow registry. Every deposit, claim, or refund is routed through it."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"escrow",children:(0,r.jsx)(n.code,{children:"Escrow"})}),"\n",(0,r.jsx)(n.p,{children:"This is the structure that holds the funds and defines when they can be withdrawn."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"/// An escrow object for a single user and a single FA\nenum Escrow has key {\n    Simple {\n        original_owner: address,\n        delete_ref: DeleteRef,\n    },\n    TimeUnlock {\n        original_owner: address,\n        /// Time that the funds can be unlocked\n        unlock_secs: u64,\n        delete_ref: DeleteRef,\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"It comes in two variants:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Simple"}),": can be claimed or refunded anytime."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"TimeUnlock"}),": can only be touched after a specific unlock time."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Each escrow also knows who originally sent the funds and has a ",(0,r.jsx)(n.code,{children:"delete_ref"})," for cleanup."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsx)(n.mdxAdmonitionTitle,{children:(0,r.jsx)(n.strong,{children:"Storage Management"})}),(0,r.jsxs)(n.p,{children:["Notice how each structure has a ",(0,r.jsx)(n.code,{children:"delete_ref"}),"? This enables automatic storage cleanup and refunds when escrows are completed, keeping the blockchain efficient."]})]}),"\n",(0,r.jsx)(n.h2,{id:"step-1-creating-a-lockup",children:"Step 1: Creating a Lockup"}),"\n",(0,r.jsxs)(n.p,{children:["Before a user can deposit funds into escrow, they must create their personal lockup manager. This is handled by the ",(0,r.jsx)(n.code,{children:"initialize_lockup"})," function, which sets up two key things: a ",(0,r.jsx)(n.code,{children:"Lockup"})," object stored on-chain, and a ",(0,r.jsx)(n.code,{children:"LockupRef"})," resource stored in the user\u2019s account:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"/// Initializes a lockup at an address\npublic entry fun initialize_lockup(\n    caller: &signer,\n) {\n    init_lockup(caller);\n}\n\ninline fun init_lockup(caller: &signer): Object<Lockup> {\n    let caller_address = signer::address_of(caller);\n\n    // Create the object only if it doesn't exist, otherwise quit out\n    assert!(!exists<LockupRef>(caller_address), E_LOCKUP_ALREADY_EXISTS);\n\n    // Create the object\n    let constructor_ref = object::create_object(@0x0);\n    let lockup_address = object::address_from_constructor_ref(&constructor_ref);\n    let extend_ref = object::generate_extend_ref(&constructor_ref);\n    let delete_ref = object::generate_delete_ref(&constructor_ref);\n    let obj_signer = object::generate_signer(&constructor_ref);\n    move_to(&obj_signer, Lockup::ST {\n        creator: caller_address,\n        escrows: smart_table::new(),\n        extend_ref,\n        delete_ref\n    });\n\n    // This is specifically to ensure that we don't create two lockup objects, we put a marker in the account\n    move_to(caller, LockupRef {\n        lockup_address\n    });\n    object::object_from_constructor_ref(&constructor_ref)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The function first checks whether a ",(0,r.jsx)(n.code,{children:"LockupRef"})," already exists for the caller. This ensures that users don\u2019t accidentally create multiple lockups. If one already exists, the function aborts with a clear error."]}),"\n",(0,r.jsxs)(n.p,{children:["If the check passes, a new lockup is created using Move object model. A constructor reference is generated, from which we derive the object\u2019s address and prepare two important lifecycle controls: ",(0,r.jsx)(n.code,{children:"extend_ref"})," and ",(0,r.jsx)(n.code,{children:"delete_ref"}),". These are used later to either extend the object\u2019s capabilities or clean it up and reclaim storage."]}),"\n",(0,r.jsxs)(n.p,{children:["The core of the lockup is the ",(0,r.jsx)(n.code,{children:"escrows"})," field, which is initialized as an empty ",(0,r.jsx)(n.code,{children:"SmartTable"}),". This will eventually hold mappings between each asset-user pair and the corresponding escrow object. The lockup is finalized by writing the object on-chain with the current user set as its creator."]}),"\n",(0,r.jsxs)(n.p,{children:["Lastly, a ",(0,r.jsx)(n.code,{children:"LockupRef"})," resource is stored directly in the user\u2019s account. This small but critical structure keeps track of which ",(0,r.jsx)(n.code,{children:"Lockup"})," object belongs to the account, enabling the rest of the escrow system to function correctly."]}),"\n",(0,r.jsxs)(n.admonition,{type:"warning",children:[(0,r.jsx)(n.mdxAdmonitionTitle,{children:(0,r.jsx)(n.strong,{children:"Mandatory Setup"})}),(0,r.jsxs)(n.p,{children:["This setup step is mandatory. Without it, no user can participate in the escrow system. Once complete, users can proceed to lock funds using the ",(0,r.jsx)(n.code,{children:"escrow_funds_with_no_lockup"})," or ",(0,r.jsx)(n.code,{children:"escrow_funds_with_time"})," flows."]})]}),"\n",(0,r.jsx)(n.h2,{id:"step-2-locking-funds-into-escrow",children:"Step 2: Locking Funds into Escrow"}),"\n",(0,r.jsx)(n.p,{children:"There are two ways to lock tokens:"}),"\n",(0,r.jsx)(n.h3,{id:"simple-escrow",children:"Simple Escrow"}),"\n",(0,r.jsxs)(n.p,{children:["Once you\u2019ve initialized your lockup, you can deposit funds into escrow. The ",(0,r.jsx)(n.code,{children:"escrow_funds_with_no_lockup"})," function is used when you don\u2019t want to enforce a time-based restriction."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"/// Escrows funds with no lockup time\npublic entry fun escrow_funds_with_no_lockup(\n    caller: &signer,\n    lockup_obj: Object<Lockup>,\n    fa_metadata: Object<Metadata>,\n    amount: u64,\n) acquires Lockup, Escrow {\n    let caller_address = signer::address_of(caller);\n    let lockup_address = object::object_address(&lockup_obj);\n    let lockup = &mut Lockup[lockup_address];\n\n    let lockup_key = EscrowKey::FAPerUser {\n        fa_metadata,\n        user: caller_address\n    };\n\n    let escrow_address = lockup.escrows.borrow_mut_with_default(lockup_key, @0x0);\n\n    // If we haven't found it, create a new escrow object\n    if (escrow_address == &@0x0) {\n        let constructor_ref = object::create_object(lockup_address);\n        let object_signer = object::generate_signer(&constructor_ref);\n        let object_delete_ref = object::generate_delete_ref(&constructor_ref);\n\n        // Make it a store to keep the escrow funds\n        fungible_asset::create_store(&constructor_ref, fa_metadata);\n\n        // Store the appropriate info for the funds\n        move_to(&object_signer, Escrow::Simple {\n            original_owner: caller_address,\n            delete_ref: object_delete_ref\n        });\n        // Save it to the table\n        *escrow_address = object::address_from_constructor_ref(&constructor_ref);\n    }\n\n    // Now transfer funds into the escrow\n    escrow_funds(caller, fa_metadata, *escrow_address, caller_address, amount);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["When you call this function, it starts by getting your account address and loading your existing ",(0,r.jsx)(n.code,{children:"Lockup"})," object. It then constructs a unique key based on the token you're depositing and your account. This key is used to look up or create an escrow entry for you."]}),"\n",(0,r.jsxs)(n.p,{children:["If an escrow doesn\u2019t already exist, a new object is created and set up to hold the tokens. That includes creating a ",(0,r.jsx)(n.code,{children:"FungibleStore"})," inside the object and moving an ",(0,r.jsx)(n.code,{children:"Escrow::Simple"})," resource into it. Your ownership of this escrow is recorded, along with a ",(0,r.jsx)(n.code,{children:"delete_ref"})," to support safe deletion and storage refunding later."]}),"\n",(0,r.jsx)(n.p,{children:"Once the escrow exists, the function moves the specified amount of tokens from your account into the escrow. Now the funds are locked, and the lockup manager controls what happens next."}),"\n",(0,r.jsx)(n.h3,{id:"time-locked-escrow",children:"Time-Locked Escrow"}),"\n",(0,r.jsxs)(n.p,{children:["Sometimes, you want to make sure funds stay locked until a specific time. That\u2019s what ",(0,r.jsx)(n.code,{children:"escrow_funds_with_time"})," is for. It works just like the simple escrow deposit, but adds a built-in restriction: funds can\u2019t be touched until a future timestamp is reached."]}),"\n",(0,r.jsx)(n.p,{children:"This is useful for vesting, delayed payouts, milestone-based releases, or protecting both sides in a timed exchange."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"/// Escrows funds with a user defined lockup time\npublic entry fun escrow_funds_with_time(\n    caller: &signer,\n    lockup_obj: Object<Lockup>,\n    fa_metadata: Object<Metadata>,\n    amount: u64,\n    lockup_time_secs: u64,\n) acquires Lockup, Escrow {\n    let caller_address = signer::address_of(caller);\n    let lockup_address = object::object_address(&lockup_obj);\n    let lockup = &mut Lockup[lockup_address];\n\n    let lockup_key = EscrowKey::FAPerUser {\n        fa_metadata,\n        user: caller_address\n    };\n\n    let escrow_address = lockup.escrows.borrow_mut_with_default(lockup_key, @0x0);\n    \n    let new_unlock_secs = timestamp::now_seconds() + lockup_time_secs;\n\n    // If we haven't found it, create a new escrow object\n    if (escrow_address == &@0x0) {\n        let constructor_ref = object::create_object(lockup_address);\n        let object_signer = object::generate_signer(&constructor_ref);\n        let object_delete_ref = object::generate_delete_ref(&constructor_ref);\n\n        // Make it a store to keep the escrow funds\n        fungible_asset::create_store(&constructor_ref, fa_metadata);\n\n        // Store the appropriate info for the funds\n        move_to(&object_signer, Escrow::TimeUnlock {\n            original_owner: caller_address,\n            unlock_secs: new_unlock_secs,\n            delete_ref: object_delete_ref\n        });\n        // Save it to the table\n        *escrow_address = object::address_from_constructor_ref(&constructor_ref);\n    }\n\n    // Now transfer funds into the escrow\n    escrow_funds(caller, fa_metadata, *escrow_address, caller_address, amount);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The setup starts the same way as the simple escrow - it looks up your lockup, checks if an escrow entry already exists for your (account, token) pair, and creates one if needed."}),"\n",(0,r.jsx)(n.p,{children:"What\u2019s new is how the time restriction is applied:"}),"\n",(0,r.jsxs)(n.p,{children:["When you call this function, you pass in the number of seconds the tokens should remain locked. The contract adds that to the current blockchain timestamp and stores the result as ",(0,r.jsx)(n.code,{children:"unlock_secs"})," in the escrow object."]}),"\n",(0,r.jsxs)(n.p,{children:["Once the time lock is set, the funds are transferred into the escrow object the same way as before. But now they're unclaimable until the ",(0,r.jsx)(n.code,{children:"unlock_secs"})," timestamp is reached."]}),"\n",(0,r.jsxs)(n.admonition,{type:"tip",children:[(0,r.jsx)(n.mdxAdmonitionTitle,{children:(0,r.jsx)(n.strong,{children:"Choosing Escrow Types"})}),(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.strong,{children:"Simple"})," escrow for manual control (like milestone payments), and ",(0,r.jsx)(n.strong,{children:"Time-Locked"})," escrow for automatic releases (like vesting schedules or delayed transfers)."]})]}),"\n",(0,r.jsx)(n.h2,{id:"step-3-releasing-funds",children:"Step 3: Releasing Funds"}),"\n",(0,r.jsx)(n.p,{children:"After locking funds, there are three ways they can be released:"}),"\n",(0,r.jsx)(n.h3,{id:"claim-by-lockup-owner",children:"Claim by Lockup Owner"}),"\n",(0,r.jsxs)(n.p,{children:["When the time is right - or when no time lock exists - the recipient of an escrowed payment can claim the funds using the ",(0,r.jsx)(n.code,{children:"claim_escrow"})," function. This is the standard flow for a lockup creator to collect funds that someone else deposited into escrow."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"/// Claims an escrow by the owner of the escrow\npublic entry fun claim_escrow(\n    caller: &signer,\n    lockup_obj: Object<Lockup>,\n    fa_metadata: Object<Metadata>,\n    user: address,\n) acquires Lockup, Escrow {\n    let caller_address = signer::address_of(caller);\n    let lockup = get_lockup_mut(&lockup_obj);\n    assert!(caller_address == lockup.creator, E_NOT_ORIGINAL_OR_LOCKUP_OWNER);\n    let (lockup_key, escrow_address) = lockup.get_escrow(\n        fa_metadata,\n        user\n    );\n\n    // Take funds from lockup\n    lockup.take_funds(fa_metadata, escrow_address);\n\n    // Clean up the object\n    lockup.delete_escrow(lockup_key);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["When you call ",(0,r.jsx)(n.code,{children:"claim_escrow"}),", the contract first checks that you\u2019re the creator of the lockup. This is a strict ownership rule - only the intended recipient of the escrow can claim the funds.\nOnce verified, the escrow object is looked up using the combination of token metadata and the sender\u2019s address. This identifies the specific escrow entry associated with that deposit. The function then calls an internal helper to move the escrowed funds from the escrow\u2019s ",(0,r.jsx)(n.code,{children:"FungibleStore"})," into the recipient\u2019s primary store. This is a direct transfer that respects the Move resource model."]}),"\n",(0,r.jsx)(n.p,{children:"After the funds are transferred, the escrow object is deleted. This both reclaims storage and ensures there\u2019s no lingering state tied to the now-completed escrow."}),"\n",(0,r.jsx)(n.h3,{id:"return-by-lockup-owner",children:"Return by Lockup Owner"}),"\n",(0,r.jsxs)(n.p,{children:["Sometimes, instead of claiming escrowed funds, the lockup creator may want to return them to the original sender. This is exactly what the ",(0,r.jsx)(n.code,{children:"return_user_funds"})," function is for. Use this when a deal falls through, a milestone isn\u2019t reached, or you simply want to refund the depositor."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"/// Returns funds for the user\npublic entry fun return_user_funds(\n    caller: &signer,\n    lockup_obj: Object<Lockup>,\n    fa_metadata: Object<Metadata>,\n    user: address,\n) acquires Lockup, Escrow {\n    let caller_address = signer::address_of(caller);\n    let lockup = get_lockup_mut(&lockup_obj);\n    assert!(caller_address == lockup.creator, E_NOT_ORIGINAL_OR_LOCKUP_OWNER);\n    let (lockup_key, escrow_address) = lockup.get_escrow(\n        fa_metadata,\n        user\n    );\n\n    // Determine original owner, and any conditions on returning\n    let original_owner = match (&Escrow[escrow_address]) {\n        Escrow::Simple { original_owner, .. } => {\n            *original_owner\n        }\n        Escrow::TimeUnlock { original_owner, .. } => {\n            // Note, the lockup owner can reject the unlock faster than the unlock time\n            *original_owner\n        }\n    };\n\n    lockup.return_funds(fa_metadata, escrow_address, original_owner);\n\n    // Clean up the object\n    lockup.delete_escrow(lockup_key);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["When creator call ",(0,r.jsx)(n.code,{children:"return_user_funds"}),", the function first verifies that you\u2019re authorized to manage this lockup. Then it locates the specific escrow entry by combining the token and the address of the original depositor."]}),"\n",(0,r.jsxs)(n.p,{children:["Next, it checks the type of escrow stored. Regardless of whether it\u2019s a ",(0,r.jsx)(n.code,{children:"Simple"})," or ",(0,r.jsx)(n.code,{children:"TimeUnlock"})," escrow, the function extracts the original sender\u2019s address - the person who should get the tokens back."]}),"\n",(0,r.jsx)(n.admonition,{title:"Time lock is not enforced here. The assumption is that the lockup owner is intentionally choosing to return funds, possibly even before the unlock time.",type:"note"}),"\n",(0,r.jsx)(n.p,{children:"Finally, the tokens are transferred from the escrow object back to the original sender, and the escrow entry is deleted. That deletion also cleans up the on-chain state and reclaims storage."}),"\n",(0,r.jsx)(n.h3,{id:"return-by-original-sender-self-unlock",children:"Return by Original Sender (Self-Unlock)"}),"\n",(0,r.jsxs)(n.p,{children:["In some cases, you may want to take your funds back from escrow - especially if the other party hasn't claimed them or if you're using a time-locked escrow that has expired. The ",(0,r.jsx)(n.code,{children:"return_my_funds"})," function gives the original sender a way to recover their tokens."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"/// Returns funds for the caller\npublic entry fun return_my_funds(\n    caller: &signer,\n    lockup_obj: Object<Lockup>,\n    fa_metadata: Object<Metadata>,\n) acquires Lockup, Escrow {\n    let caller_address = signer::address_of(caller);\n    let lockup = get_lockup_mut(&lockup_obj);\n    let (lockup_key, escrow_address) = lockup.get_escrow(\n        fa_metadata,\n        caller_address\n    );\n\n    // Determine original owner, and any conditions on returning\n    let original_owner = match (&Escrow[escrow_address]) {\n        Escrow::Simple { original_owner, .. } => {\n            *original_owner\n        }\n        Escrow::TimeUnlock { original_owner, unlock_secs, .. } => {\n            assert!(timestamp::now_seconds() >= *unlock_secs, E_UNLOCK_TIME_NOT_YET);\n            *original_owner\n        }\n    };\n\n    // To prevent others from being annoying, only the original owner can return funds\n    assert!(original_owner == caller_address, E_NOT_ORIGINAL_OR_LOCKUP_OWNER);\n    lockup.return_funds(fa_metadata, escrow_address, original_owner);\n\n    // Clean up the object\n    lockup.delete_escrow(lockup_key);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This function is designed to be used by the person who originally deposited funds into escrow. It looks up the escrow entry based on your account and the token type. Once it finds the escrow, the contract checks whether the funds are time-locked. If they are, it verifies that the unlock time has passed. If the time hasn't passed yet, the function aborts - this prevents users from bypassing time locks."}),"\n",(0,r.jsxs)(n.admonition,{type:"caution",children:[(0,r.jsx)(n.mdxAdmonitionTitle,{children:(0,r.jsx)(n.strong,{children:"Time lock enforcement"})}),(0,r.jsxs)(n.p,{children:["Unlike ",(0,r.jsx)(n.code,{children:"return_user_funds"}),", this function ",(0,r.jsx)(n.strong,{children:"strictly enforces"})," time locks. Original senders cannot retrieve their funds early from time-locked escrows."]})]}),"\n",(0,r.jsx)(n.p,{children:"After confirming that you're allowed to withdraw, the function double-checks that you are the original owner of the escrow. This prevents malicious callers from trying to extract someone else's deposit."}),"\n",(0,r.jsx)(n.p,{children:"Finally, the funds are moved from the escrow's storage back into your account, and the escrow object is deleted to clean up the on-chain state."}),"\n",(0,r.jsx)(n.h2,{id:"step-4-checking-status",children:"Step 4: Checking Status"}),"\n",(0,r.jsx)(n.p,{children:"As you interact with escrow contracts - whether you're locking, claiming, or returning tokens - it\u2019s important to have visibility into the state of your escrows. The module provides several view-only functions that help you do exactly that."}),"\n",(0,r.jsx)(n.p,{children:"These functions are read-only and can be used by frontends, dashboards, or scripts to show real-time escrow status without modifying the blockchain."}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"lockup_address"})," to find the on-chain ",(0,r.jsx)(n.code,{children:"Lockup"})," object address for a given user account."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[view]\n/// Tells the lockup address for the user who created the original lockup\npublic fun lockup_address(escrow_account: address): address acquires LockupRef {\n    LockupRef[escrow_account].lockup_address\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This is useful when you want to interact with someone else\u2019s lockup (e.g. you're depositing funds into their escrow), but only have their account address."}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"escrowed_funds"})," to see how many tokens are currently locked in escrow for a given (user, token) pair."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[view]\n/// Tells the amount of escrowed funds currently available\npublic fun escrowed_funds(\n    lockup_obj: Object<Lockup>,\n    fa_metadata: Object<Metadata>,\n    user: address\n): Option<u64> acquires Lockup {\n    let lockup = get_lockup(&lockup_obj);\n    let escrow_key = EscrowKey::FAPerUser {\n        fa_metadata,\n        user\n    };\n    if (lockup.escrows.contains(escrow_key)) {\n        let escrow_address = lockup.escrows.borrow(escrow_key);\n        let escrow_obj = object::address_to_object<Escrow>(*escrow_address);\n        option::some(fungible_asset::balance(escrow_obj))\n    } else {\n        option::none()\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If the escrow exists, the function returns the balance as ",(0,r.jsx)(n.code,{children:"Option<u64>"})," - otherwise it returns ",(0,r.jsx)(n.code,{children:"none"}),". You can use this in a frontend to show locked token amounts for a wallet."]}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"remaining_escrow_time"})," to check how many seconds are left before a time-locked escrow can be released."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[view]\n/// Tells the remaining time until escrow unlock\npublic fun remaining_escrow_time(\n    lockup_obj: Object<Lockup>,\n    fa_metadata: Object<Metadata>,\n    user: address\n): Option<u64> acquires Lockup, Escrow {\n    let lockup = get_lockup(&lockup_obj);\n    let escrow_key = EscrowKey::FAPerUser {\n        fa_metadata,\n        user\n    };\n    if (lockup.escrows.contains(escrow_key)) {\n        let escrow_address = lockup.escrows.borrow(escrow_key);\n        let remaining_secs = match (&Escrow[*escrow_address]) {\n            Simple { .. } => { 0 }\n            TimeUnlock { unlock_secs, .. } => {\n                let now = timestamp::now_seconds();\n                if (now >= *unlock_secs) {\n                    0\n                } else {\n                    *unlock_secs - now\n                }\n            }\n        };\n        option::some(remaining_secs)\n    } else {\n        option::none()\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If the escrow is of type ",(0,r.jsx)(n.code,{children:"Simple"}),", the function will return 0. If it's a ",(0,r.jsx)(n.code,{children:"TimeUnlock"})," escrow, it subtracts the current blockchain timestamp from the unlock timestamp."]}),"\n",(0,r.jsxs)(n.admonition,{type:"info",children:[(0,r.jsx)(n.mdxAdmonitionTitle,{children:(0,r.jsx)(n.strong,{children:"Frontend Integration"})}),(0,r.jsx)(n.p,{children:"These view functions are perfect for building dashboards and user interfaces. They don't consume gas and provide real-time escrow status without any side effects."})]}),"\n",(0,r.jsx)(n.p,{children:"You now understand escrow as a user flow - not just code."}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsxs)(n.p,{children:["At the heart of the system are three key components: ",(0,r.jsx)(n.code,{children:"LockupRef"}),", which links a user account to their lockup manager; ",(0,r.jsx)(n.code,{children:"Lockup"}),", an on-chain object that holds and manages escrow entries; and ",(0,r.jsx)(n.code,{children:"Escrow"}),", which stores actual tokens and controls how they can be claimed or returned. These abstractions separate ownership, logic, and control - giving developers and users a clean, auditable lifecycle for escrowed funds."]}),"\n",(0,r.jsxs)(n.p,{children:["Escrow flows begin with a one-time lockup initialization, which sets up a new ",(0,r.jsx)(n.code,{children:"Lockup"})," object and stores a reference to it in the user's account. From there, funds can be deposited into escrow via two entry points: a simple version with no time restrictions and a time-locked version that prevents access until a specified timestamp. Each deposit creates or reuses an ",(0,r.jsx)(n.code,{children:"Escrow"})," object tied to a unique (token, user) pair."]}),"\n",(0,r.jsx)(n.h3,{id:"whats-next",children:"What's Next?"}),"\n",(0,r.jsx)(n.p,{children:"Now that you understand how escrow works, you can:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Build your own tokens"}),": Create fungible assets using our ",(0,r.jsx)(n.a,{href:"/guides/first-fa",children:"First FA Guide"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Explore more contracts"}),": Check out other ",(0,r.jsx)(n.a,{href:"https://github.com/cedra-labs/move-contract-examples",children:"Move examples"})," for inspiration"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>i});var t=s(6540);const r={},o=t.createContext(r);function c(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);