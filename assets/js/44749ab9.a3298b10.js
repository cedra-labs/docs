"use strict";(self.webpackChunkcedra_docs=self.webpackChunkcedra_docs||[]).push([[6979],{3871:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"concepts/block-stm","title":"Block-STM: Parallel Execution Engine","description":"Cedra achieves high throughput through Block-STM, a parallel execution engine that processes transactions concurrently while maintaining deterministic results. This technology enables over 160,000 transactions per second by combining Software Transactional Memory techniques with a novel collaborative scheduler.","source":"@site/docs/concepts/block-stm.md","sourceDirName":"concepts","slug":"/concepts/block-stm","permalink":"/concepts/block-stm","draft":false,"unlisted":false,"editUrl":"https://github.com/cedra-labs/docs/edit/main/docs/concepts/block-stm.md","tags":[],"version":"current","frontMatter":{},"sidebar":"concepts","previous":{"title":"Blockchain","permalink":"/concepts/blockchain"},"next":{"title":"Understanding Accounts","permalink":"/concepts/accounts/understanding-accounts"}}');var r=i(4848),s=i(8453);const a={},c="Block-STM: Parallel Execution Engine",o={},l=[{value:"Key Concepts",id:"key-concepts",level:3},{value:"The Concurrency Challenge",id:"the-concurrency-challenge",level:2},{value:"Optimistic vs Pessimistic Concurrency",id:"optimistic-vs-pessimistic-concurrency",level:2},{value:"Pessimistic Concurrency Control (PCC)",id:"pessimistic-concurrency-control-pcc",level:3},{value:"Optimistic Concurrency Control (OCC)",id:"optimistic-concurrency-control-occ",level:3},{value:"How Block-STM Works",id:"how-block-stm-works",level:2},{value:"Transaction Ordering",id:"transaction-ordering",level:3},{value:"Multi-Version Data Structure",id:"multi-version-data-structure",level:3},{value:"Read Set Tracking",id:"read-set-tracking",level:3},{value:"Validation Process",id:"validation-process",level:3},{value:"Conflict Resolution with ESTIMATE",id:"conflict-resolution-with-estimate",level:3},{value:"The Collaborative Scheduler",id:"the-collaborative-scheduler",level:2},{value:"Avoiding Cascading Aborts",id:"avoiding-cascading-aborts",level:3},{value:"Transaction Lifecycle in Block-STM",id:"transaction-lifecycle-in-block-stm",level:2},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Why This Matters for Developers",id:"why-this-matters-for-developers",level:2},{value:"Summary",id:"summary",level:2},{value:"Learn More",id:"learn-more",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"block-stm-parallel-execution-engine",children:"Block-STM: Parallel Execution Engine"})}),"\n",(0,r.jsx)(n.p,{children:"Cedra achieves high throughput through Block-STM, a parallel execution engine that processes transactions concurrently while maintaining deterministic results. This technology enables over 160,000 transactions per second by combining Software Transactional Memory techniques with a novel collaborative scheduler."}),"\n",(0,r.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"#how-block-stm-works",children:"Parallel Execution"})}),": Running multiple transactions simultaneously"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"#optimistic-vs-pessimistic-concurrency",children:"Optimistic Concurrency Control"})}),": Execute first, validate later"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"#multi-version-data-structure",children:"Multi-version Data Structure"})}),": Track all writes with versions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"#the-collaborative-scheduler",children:"Collaborative Scheduler"})}),": Coordinate tasks across threads"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"the-concurrency-challenge",children:"The Concurrency Challenge"}),"\n",(0,r.jsx)(n.p,{children:"Smart contract execution is a major throughput bottleneck for blockchains. After proposing blocks and agreeing on their order, validators must execute the transactions and arrive at the same final state - one that corresponds to some sequential execution. This creates a fundamental tension: we want parallel execution for speed, but we need deterministic results for consensus."}),"\n",(0,r.jsx)(n.admonition,{title:"Core Principle",type:"info",children:(0,r.jsx)(n.p,{children:"Block-STM guarantees that parallel execution produces the same result as if transactions were executed sequentially in the preset order. This determinism is essential - validators executing the same block must arrive at identical final states."})}),"\n",(0,r.jsx)(n.p,{children:"Current blockchains face a difficult choice: execute sequentially (which doesn't scale) or require an embarrassingly parallel workload with no conflicts (which is unrealistic for real applications). Transactions often have significant access conflicts due to popular contracts, economic opportunities like auctions and arbitrage, or even performance attacks."}),"\n",(0,r.jsx)(n.p,{children:"Block-STM solves this by dynamically and transparently extracting the inherent parallelism from any workload, without requiring users to declare dependencies upfront."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"optimistic-vs-pessimistic-concurrency",children:"Optimistic vs Pessimistic Concurrency"}),"\n",(0,r.jsx)(n.p,{children:"There are two fundamental approaches to handling concurrent access to shared resources:"}),"\n",(0,r.jsx)(n.mermaid,{value:'graph LR\n    subgraph "Pessimistic (PCC)"\n        A1[Declare Dependencies] --\x3e A2[Acquire Locks]\n        A2 --\x3e A3[Execute]\n        A3 --\x3e A4[Release Locks]\n    end\n\n    subgraph "Optimistic (OCC)"\n        B1[Execute Speculatively] --\x3e B2[Validate Results]\n        B2 --\x3e|Valid| B3[Commit]\n        B2 --\x3e|Conflict| B4[Re-execute]\n        B4 --\x3e B2\n    end'}),"\n",(0,r.jsx)(n.h3,{id:"pessimistic-concurrency-control-pcc",children:"Pessimistic Concurrency Control (PCC)"}),"\n",(0,r.jsx)(n.p,{children:"In PCC systems like Solana, transactions are blocked if they need to access a resource already in use by another transaction. This approach requires transactions to declare upfront what portions of memory they will read from and write to, since acquiring locks on the fly leads to unserializable execution results."}),"\n",(0,r.jsx)(n.p,{children:"While PCC has historically performed well in distributed databases, it comes with significant limitations: users must specify all dependencies before execution, which constrains what transactions can do and may require complex transactions to be broken up or retried."}),"\n",(0,r.jsx)(n.h3,{id:"optimistic-concurrency-control-occ",children:"Optimistic Concurrency Control (OCC)"}),"\n",(0,r.jsx)(n.p,{children:"Block-STM uses OCC, where transactions execute on all available processing resources with no regard for conflicts. Instead of writing directly to persistent memory, transactions write to a log. After execution, each transaction is validated to ensure it didn't violate database integrity rules. If validation fails, the transaction is rolled back and rescheduled; otherwise, it commits."}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Aspect"}),(0,r.jsx)(n.th,{children:"PCC (Solana)"}),(0,r.jsx)(n.th,{children:"OCC (Block-STM)"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Dependency Declaration"})}),(0,r.jsx)(n.td,{children:"Required upfront"}),(0,r.jsx)(n.td,{children:"Not required"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Execution"})}),(0,r.jsx)(n.td,{children:"Blocked if resource locked"}),(0,r.jsx)(n.td,{children:"Proceeds optimistically"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Conflict Detection"})}),(0,r.jsx)(n.td,{children:"Before execution"}),(0,r.jsx)(n.td,{children:"After execution"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Developer Experience"})}),(0,r.jsx)(n.td,{children:"Must specify all accessed accounts"}),(0,r.jsx)(n.td,{children:"Transparent, automatic"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Arbitrary Logic"})}),(0,r.jsx)(n.td,{children:"Limited by declarations"}),(0,r.jsx)(n.td,{children:"Fully supported"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"Thanks to clever design and engineering, Block-STM performs surprisingly well, with the added benefits of allowing arbitrary logic and a superior developer experience."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"how-block-stm-works",children:"How Block-STM Works"}),"\n",(0,r.jsx)(n.p,{children:"Block-STM combines known techniques with novel ideas to achieve high-performance parallel execution:"}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TD\n    A[Transactions Ordered by Priority] --\x3e B[Schedule for Parallel Execution]\n    B --\x3e C[Execute with Multi-Version Data Structure]\n    C --\x3e D[Track Read Set During Execution]\n    D --\x3e E[Validate Against Current Values]\n    E --\x3e|Match| F[Mark Valid]\n    E --\x3e|Mismatch| G[Mark as ESTIMATE]\n    G --\x3e H[Re-execute]\n    H --\x3e D\n    F --\x3e I[All Prior Validated?]\n    I --\x3e|Yes| J[Safe to Commit]\n    I --\x3e|No| K[Wait for Prior Transactions]"}),"\n",(0,r.jsx)(n.h3,{id:"transaction-ordering",children:"Transaction Ordering"}),"\n",(0,r.jsxs)(n.p,{children:["Before execution begins, transactions are ordered by priority: ",(0,r.jsx)(n.code,{children:"tx\u2081 > tx\u2082 > tx\u2083 > ... > tx\u2099"}),". This preset order is crucial - it reduces the amount of synchronization required during execution. Where a general-purpose STM would need to solve consensus when conflicts occur, Block-STM simply follows the predetermined order: if tx\u2085 and tx\u2089 conflict, tx\u2089 waits for tx\u2085."]}),"\n",(0,r.jsx)(n.h3,{id:"multi-version-data-structure",children:"Multi-Version Data Structure"}),"\n",(0,r.jsx)(n.p,{children:"Block-STM uses a multi-version data structure to avoid write-write conflicts. All writes to the same location are stored along with their versions, which contain:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The transaction ID"}),"\n",(0,r.jsx)(n.li,{children:"The number of times the writing transaction was re-executed"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["When a transaction ",(0,r.jsx)(n.code,{children:"tx\u2c7c"})," reads a memory location, it obtains the value written by the highest-priority transaction that appears before ",(0,r.jsx)(n.code,{children:"tx\u2c7c"})," in the preset order, along with the associated version."]}),"\n",(0,r.jsx)(n.h3,{id:"read-set-tracking",children:"Read Set Tracking"}),"\n",(0,r.jsx)(n.p,{children:"During execution, each transaction records its read set - the memory locations and associated values it read. This information is essential for validation."}),"\n",(0,r.jsx)(n.h3,{id:"validation-process",children:"Validation Process"}),"\n",(0,r.jsx)(n.p,{children:"After a transaction completes execution, it's validated by comparing its read set with the current values at those memory locations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"If values match"}),": The transaction is marked valid (but not yet safe to commit)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"If values differ"}),": A higher-priority transaction modified a location that this transaction read, making the results invalid"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"conflict-resolution-with-estimate",children:"Conflict Resolution with ESTIMATE"}),"\n",(0,r.jsxs)(n.p,{children:["When validation fails, instead of deleting dirty values from the data structure, Block-STM marks them as ",(0,r.jsx)(n.code,{children:"ESTIMATE"})," and schedules the transaction for re-execution. This is a key optimization:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Values aren't deleted because re-execution will likely write to the same locations"}),"\n",(0,r.jsxs)(n.li,{children:["Any lower-priority transaction that reads an ",(0,r.jsx)(n.code,{children:"ESTIMATE"})," value waits for the dependency to be resolved"]}),"\n",(0,r.jsx)(n.li,{children:"This prevents a cascade of aborts and wasted work"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"the-collaborative-scheduler",children:"The Collaborative Scheduler"}),"\n",(0,r.jsx)(n.p,{children:"The collaborative scheduler is the performance-critical core of Block-STM. It coordinates validation and execution tasks among threads with minimal synchronization overhead."}),"\n",(0,r.jsx)(n.mermaid,{value:'graph LR\n    subgraph "Thread Pool"\n        T1[Thread 1]\n        T2[Thread 2]\n        T3[Thread 3]\n        TN[Thread N]\n    end\n\n    subgraph "Atomic Counters"\n        EC[Execution Index]\n        VC[Validation Index]\n    end\n\n    T1 --\x3e EC\n    T2 --\x3e VC\n    T3 --\x3e EC\n    TN --\x3e VC'}),"\n",(0,r.jsx)(n.p,{children:"A naive approach would use priority queues to track execution and validation tasks, but concurrent ordered sets are notoriously challenging to scale. Block-STM sidesteps this by using atomic counters that track a lower bound index for transactions needing execution or validation."}),"\n",(0,r.jsx)(n.p,{children:"Threads repeatedly:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Fetch-and-increment the counter with the lower index"}),"\n",(0,r.jsx)(n.li,{children:"Check the transaction's status"}),"\n",(0,r.jsx)(n.li,{children:"Execute or validate if the transaction is ready"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The fetch-and-increment naturally disperses threads to different indices, preventing contention on status information."}),"\n",(0,r.jsx)(n.h3,{id:"avoiding-cascading-aborts",children:"Avoiding Cascading Aborts"}),"\n",(0,r.jsxs)(n.p,{children:["When a transaction fails validation, its write set marks all its writes as ",(0,r.jsx)(n.code,{children:"ESTIMATE"})," in the multi-version data structure. When another transaction reads an ",(0,r.jsx)(n.code,{children:"ESTIMATE"})," value, it waits for the dependency to be resolved rather than proceeding blindly."]}),"\n",(0,r.jsx)(n.p,{children:"This is more efficient than pre-executing all transactions from the initial state because:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Estimates are generated only when needed"}),"\n",(0,r.jsx)(n.li,{children:"Estimates are based on a state much fresher than the block's beginning"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"transaction-lifecycle-in-block-stm",children:"Transaction Lifecycle in Block-STM"}),"\n",(0,r.jsx)(n.mermaid,{value:"stateDiagram-v2\n    [*] --\x3e Submitted: Client Request\n    Submitted --\x3e Mempool: Signature & Balance Checks\n    Mempool --\x3e Ordered: Block Proposal\n    Ordered --\x3e Executing: Scheduled\n    Executing --\x3e Executed: Complete\n    Executed --\x3e Validating: Check Read Set\n    Validating --\x3e Valid: No Conflicts\n    Validating --\x3e Executing: Conflict Detected\n    Valid --\x3e Committed: All Prior Valid\n    Committed --\x3e [*]"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Submission"}),": Client sends transaction to a fullnode or validator"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mempool"}),": Nodes verify signatures, minimum balances, and sequence numbers for replay protection"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Block Proposal"}),": Leader selects transactions and proposes an ordering"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parallel Execution"}),": Transactions execute concurrently on available threads"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validation"}),": Each transaction's read set is compared against current values"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Re-execution"}),": Invalid transactions are rescheduled with ",(0,r.jsx)(n.code,{children:"ESTIMATE"})," markers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Commitment"}),": Once all prior transactions are valid, the block commits"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"A transaction is not safe to commit until all transactions before it in the preset order have been executed and validated - a failed validation of an earlier transaction requires revalidation of all later ones."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,r.jsx)(n.p,{children:"Block-STM achieves remarkable performance by dynamically adapting to workload characteristics:"}),"\n",(0,r.jsxs)(n.admonition,{title:"Performance Results",type:"info",children:[(0,r.jsx)(n.p,{children:"With 32 threads processing 10,000 peer-to-peer Move transactions (8 reads, 5 writes each):"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Low contention"}),": 16x speedup over sequential execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"High contention"}),": 8x speedup over sequential execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sequential workload"}),": Minimal overhead"]}),"\n"]})]}),"\n",(0,r.jsx)(n.p,{children:"The system automatically extracts available parallelism without hints from users. Under low contention, it approaches the theoretical maximum speedup. Under high contention, it gracefully degrades while still providing substantial improvements over sequential execution."}),"\n",(0,r.jsx)(n.p,{children:"Importantly, when the workload is inherently sequential (worst case), Block-STM incurs only small overhead compared to sequential execution."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"why-this-matters-for-developers",children:"Why This Matters for Developers"}),"\n",(0,r.jsx)(n.p,{children:"Block-STM provides transparent parallel execution - developers write smart contracts without worrying about concurrency:"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"No Dependency Declarations"}),": Unlike systems that require upfront specification of accessed accounts, Block-STM handles everything automatically. Write your logic; the system figures out the rest."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Arbitrary Logic Supported"}),": Because dependencies are discovered at runtime, transactions can contain complex, conditional logic that accesses different resources based on state."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Better User Experience"}),": Users don't need to structure their transactions around parallelization requirements or retry failed transactions due to incorrect dependency specifications."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Consistent Results"}),": Despite parallel execution, the results are guaranteed to match sequential execution in the preset order - perfect for blockchain's determinism requirements."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"Block-STM is Cedra's parallel execution engine that achieves high throughput without sacrificing developer experience or flexibility:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimistic execution"})," proceeds without waiting for locks, validating afterward"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multi-version data structures"})," track all writes with versions for conflict detection"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ESTIMATE markers"})," prevent cascading aborts when conflicts are detected"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Collaborative scheduling"})," with atomic counters minimizes synchronization overhead"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Preset ordering"})," simplifies conflict resolution and guarantees determinism"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transparent operation"})," requires no dependency declarations from developers"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The result: over 160,000 transactions per second with the flexibility to support arbitrary smart contract logic."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"learn-more",children:"Learn More"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/concepts/blockchain",children:"Blockchain Architecture"})," - Overall system design"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/concepts/transactions/understanding-transactions",children:"Understanding Transactions"})," - Transaction structure and lifecycle"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/concepts/transactions/states",children:"States and Transitions"})," - How state evolves"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>c});var t=i(6540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);