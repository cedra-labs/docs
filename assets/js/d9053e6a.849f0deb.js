"use strict";(self.webpackChunkcedra_docs=self.webpackChunkcedra_docs||[]).push([[8],{6339:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"move/flow","title":"Conditionals, Loops, and Control Flow","description":"Master control flow in Move - from if expressions to loops and pattern matching. Learn how to write efficient, safe control structures while maintaining resource safety.","source":"@site/docs/move/flow.md","sourceDirName":"move","slug":"/move/flow","permalink":"/move/flow","draft":false,"unlisted":false,"editUrl":"https://github.com/cedra-labs/docs/edit/main/docs/move/flow.md","tags":[],"version":"current","frontMatter":{"title":"Conditionals, Loops, and Control Flow","description":"Master control flow in Move - from if expressions to loops and pattern matching. Learn how to write efficient, safe control structures while maintaining resource safety.","keywords":["move control flow","conditionals","loops","pattern matching","if expressions","while loops","move programming"]},"sidebar":"docs","previous":{"title":"Ownership & Borrowing","permalink":"/move/ownership"},"next":{"title":"Error Handling","permalink":"/move/errors"}}');var s=t(4848),r=t(8453);const o={title:"Conditionals, Loops, and Control Flow",description:"Master control flow in Move - from if expressions to loops and pattern matching. Learn how to write efficient, safe control structures while maintaining resource safety.",keywords:["move control flow","conditionals","loops","pattern matching","if expressions","while loops","move programming"]},l="Conditionals, Loops, and Control Flow",a={},c=[{value:"Basic If Expressions",id:"basic-if-expressions",level:3},{value:"If Without Else",id:"if-without-else",level:3},{value:"Complex Conditions",id:"complex-conditions",level:3},{value:"Loops: Repetition with Purpose",id:"loops-repetition-with-purpose",level:2},{value:"While Loops",id:"while-loops",level:3},{value:"Loop with Break",id:"loop-with-break",level:3},{value:"Continue in Loops",id:"continue-in-loops",level:3},{value:"Pattern Matching and Destructuring",id:"pattern-matching-and-destructuring",level:2},{value:"Struct Destructuring",id:"struct-destructuring",level:3},{value:"Destructuring with Resources",id:"destructuring-with-resources",level:3},{value:"Nested Destructuring",id:"nested-destructuring",level:3},{value:"Control Flow Patterns",id:"control-flow-patterns",level:2},{value:"Early Return Pattern",id:"early-return-pattern",level:3},{value:"Guard Clause Pattern",id:"guard-clause-pattern",level:3},{value:"State Machine Pattern",id:"state-machine-pattern",level:3},{value:"Best Practices for Control Flow",id:"best-practices-for-control-flow",level:2},{value:"Keep Conditions Simple",id:"keep-conditions-simple",level:3},{value:"Avoid Deep Nesting",id:"avoid-deep-nesting",level:3},{value:"Loop Invariants",id:"loop-invariants",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"What&#39;s Next?",id:"whats-next",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"conditionals-loops-and-control-flow",children:"Conditionals, Loops, and Control Flow"})}),"\n",(0,s.jsx)(n.p,{children:"Control flow in Move might look familiar if you've used other languages, but it has unique characteristics driven by blockchain requirements. Every conditional must be deterministic, loops must terminate, and pattern matching must be exhaustive. Let's explore how to direct program execution while maintaining Move's safety guarantees."}),"\n",(0,s.jsx)(n.h3,{id:"basic-if-expressions",children:"Basic If Expressions"}),"\n",(0,s.jsxs)(n.p,{children:["In Move, ",(0,s.jsx)(n.code,{children:"if"})," is an expression, not a statement. This means it returns a value, making your code more functional and composable."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'public fun calculate_fee(amount: u64, is_premium: bool): u64 {\n    if (is_premium) {\n        amount / 100  // 1% fee for premium users\n    } else {\n        amount / 50   // 2% fee for regular users\n    }\n}\n\npublic fun get_status_message(balance: u64): vector<u8> {\n    if (balance == 0) {\n        b"Empty account"\n    } else if (balance < 100) {\n        b"Low balance"\n    } else if (balance < 1000) {\n        b"Regular account"  \n    } else {\n        b"High value account"\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Notice the parentheses around conditions \u2013 they're required in Move. Also note that both branches of an if-else must return the same type. The compiler enforces this, preventing type mismatches."}),"\n",(0,s.jsxs)(n.p,{children:["Since ",(0,s.jsx)(n.code,{children:"if"})," is an expression, you can use it anywhere a value is expected:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'public fun process_transaction(amount: u64, is_urgent: bool) {\n    let fee = if (is_urgent) { amount / 20 } else { amount / 100 };\n    let priority = if (is_urgent) { 1 } else { 10 };\n    \n    // Using if in function arguments\n    execute_transfer(\n        amount,\n        fee,\n        if (is_urgent) { b"Urgent" } else { b"Standard" }\n    );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"if-without-else",children:"If Without Else"}),"\n",(0,s.jsxs)(n.p,{children:["When an ",(0,s.jsx)(n.code,{children:"if"})," expression doesn't have an ",(0,s.jsx)(n.code,{children:"else"})," branch, it must return unit ",(0,s.jsx)(n.code,{children:"()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun maybe_update_balance(account: &mut Account, condition: bool, amount: u64) {\n    if (condition) {\n        account.balance = account.balance + amount;\n    };  // Note the semicolon - required when no else branch\n}\n\npublic fun validate_and_proceed(value: u64) {\n    if (value < MIN_VALUE) {\n        abort ERROR_TOO_SMALL\n    };\n    \n    if (value > MAX_VALUE) {\n        abort ERROR_TOO_LARGE\n    };\n    \n    // Proceed with valid value\n    process_value(value);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The semicolon after the closing brace is crucial when there's no ",(0,s.jsx)(n.code,{children:"else"})," branch and more code follows. This tells Move to treat the ",(0,s.jsx)(n.code,{children:"if"})," as a statement that returns unit, rather than an expression that returns a value."]}),"\n",(0,s.jsx)(n.h3,{id:"complex-conditions",children:"Complex Conditions"}),"\n",(0,s.jsx)(n.p,{children:"Move supports standard boolean operators for building complex conditions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun can_withdraw(account: &Account, amount: u64, is_admin: bool): bool {\n    (account.balance >= amount && !account.locked) || is_admin\n}\n\npublic fun validate_transfer(\n    from: &Account,\n    to: &Account,\n    amount: u64\n): bool {\n    if (from.balance < amount) {\n        false\n    } else if (from.locked || to.locked) {\n        false\n    } else if (amount == 0) {\n        false\n    } else {\n        true\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Move uses short-circuit evaluation for boolean operators. In ",(0,s.jsx)(n.code,{children:"a && b"}),", if ",(0,s.jsx)(n.code,{children:"a"})," is false, ",(0,s.jsx)(n.code,{children:"b"})," is never evaluated. This is not just an optimization \u2013 it's a guarantee you can rely on:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun safe_division(numerator: u64, denominator: u64): u64 {\n    if (denominator != 0 && numerator / denominator > 10) {\n        numerator / denominator\n    } else {\n        0\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The division ",(0,s.jsx)(n.code,{children:"numerator / denominator"})," only executes if ",(0,s.jsx)(n.code,{children:"denominator != 0"}),", preventing a division-by-zero error."]}),"\n",(0,s.jsx)(n.h2,{id:"loops-repetition-with-purpose",children:"Loops: Repetition with Purpose"}),"\n",(0,s.jsxs)(n.p,{children:["Let's dive into two loop constructs: ",(0,s.jsx)(n.code,{children:"while"})," for condition-based loops and ",(0,s.jsx)(n.code,{children:"loop"})," for infinite loops with explicit breaks. Both must provably terminate to prevent infinite execution on-chain."]}),"\n",(0,s.jsx)(n.h3,{id:"while-loops",children:"While Loops"}),"\n",(0,s.jsx)(n.p,{children:"While loops execute as long as their condition is true:"}),"\n",(0,s.jsxs)(n.admonition,{title:"Real-World Loop Examples",type:"tip",children:[(0,s.jsx)(n.p,{children:"See loops in action:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/guides/fee-splitter#35-distribute-fees",children:"Fee Splitter Distribution"})," - Iterating through recipients to distribute payments"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/guides/escrow#remaining_escrow_time",children:"Escrow Time Checks"})," - Calculating remaining lock time"]}),"\n"]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun find_first_empty_slot(slots: &vector<Option<u64>>): u64 {\n    let i = 0;\n    let len = vector::length(slots);\n    \n    while (i < len) {\n        if (option::is_none(vector::borrow(slots, i))) {\n            return i\n        };\n        i = i + 1;\n    };\n    \n    len  // Return length if no empty slot found\n}\n\npublic fun calculate_compound_interest(\n    principal: u64,\n    rate: u64,\n    years: u64\n): u64 {\n    let result = principal;\n    let i = 0;\n    \n    while (i < years) {\n        result = (result * (100 + rate)) / 100;\n        i = i + 1;\n    };\n    \n    result\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"While loops are perfect for counted iterations or searching through collections. The loop condition is checked before each iteration, so if the condition is false initially, the body never executes."}),"\n",(0,s.jsx)(n.h3,{id:"loop-with-break",children:"Loop with Break"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"loop"})," construct creates an infinite loop that must be exited with ",(0,s.jsx)(n.code,{children:"break"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun find_target_value(values: &vector<u64>, target: u64): Option<u64> {\n    let i = 0;\n    let len = vector::length(values);\n    \n    loop {\n        if (i >= len) {\n            break option::none()\n        };\n        \n        if (*vector::borrow(values, i) == target) {\n            break option::some(i)\n        };\n        \n        i = i + 1;\n    }\n}\n\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"loop"})," construct is useful when the exit condition is complex or appears in the middle of the loop logic. The ",(0,s.jsx)(n.code,{children:"break"})," expression can return a value, which becomes the value of the entire loop expression."]}),"\n",(0,s.jsx)(n.h3,{id:"continue-in-loops",children:"Continue in Loops"}),"\n",(0,s.jsxs)(n.p,{children:["Move supports ",(0,s.jsx)(n.code,{children:"continue"})," to skip to the next iteration:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun process_valid_items(items: &vector<Item>): u64 {\n    let processed = 0;\n    let i = 0;\n    let len = vector::length(items);\n    \n    while (i < len) {\n        let item = vector::borrow(items, i);\n        \n        if (!is_valid(item)) {\n            i = i + 1;\n            continue\n        };\n        \n        if (item.value < MIN_VALUE) {\n            i = i + 1;\n            continue\n        };\n        \n        // Process valid item\n        process_item(item);\n        processed = processed + 1;\n        \n        i = i + 1;\n    };\n    \n    processed\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"continue"})," expression jumps to the loop condition check (in ",(0,s.jsx)(n.code,{children:"while"}),") or the beginning (in ",(0,s.jsx)(n.code,{children:"loop"}),"). It's useful for skipping iterations based on conditions without deeply nesting your code."]}),"\n",(0,s.jsxs)(n.admonition,{title:"Loop Termination",type:"warning",children:[(0,s.jsx)(n.p,{children:"Move requires that all loops must provably terminate. This means:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"No truly infinite loops"}),"\n",(0,s.jsx)(n.li,{children:"Loop bounds must be deterministic"}),"\n",(0,s.jsx)(n.li,{children:"The compiler must be able to verify termination"}),"\n"]}),(0,s.jsx)(n.p,{children:"This prevents infinite execution that would consume unlimited gas."})]}),"\n",(0,s.jsx)(n.h2,{id:"pattern-matching-and-destructuring",children:"Pattern Matching and Destructuring"}),"\n",(0,s.jsx)(n.p,{children:"Pattern matching in Move allows you to extract values from structs and handle different cases elegantly."}),"\n",(0,s.jsx)(n.h3,{id:"struct-destructuring",children:"Struct Destructuring"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"struct Point has drop {\n    x: u64,\n    y: u64\n}\n\npublic fun distance_from_origin(point: Point): u64 {\n    let Point { x, y } = point;\n    // Simple approximation for example\n    x + y\n}\n\npublic fun process_point(point: Point) {\n    let Point { x: x_coord, y: y_coord } = point;\n    // Renamed during destructuring\n    if (x_coord > y_coord) {\n        handle_x_dominant(x_coord, y_coord);\n    } else {\n        handle_y_dominant(x_coord, y_coord);\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Destructuring extracts all fields at once. You can rename fields during destructuring using the ",(0,s.jsx)(n.code,{children:"field: new_name"})," syntax. This is particularly useful when field names would conflict with existing variables."]}),"\n",(0,s.jsx)(n.h3,{id:"destructuring-with-resources",children:"Destructuring with Resources"}),"\n",(0,s.jsx)(n.p,{children:"Resource destructuring requires special care because resources can't be dropped:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"struct Wallet has store {\n    coins: u64,\n    locked: bool\n}\n\npublic fun extract_coins(wallet: Wallet): u64 {\n    let Wallet { coins, locked } = wallet;\n    assert!(!locked, ERROR_WALLET_LOCKED);\n    coins\n}\n\npublic fun split_wallet(wallet: Wallet): (Wallet, Wallet) {\n    let Wallet { coins, locked } = wallet;\n    let half = coins / 2;\n    \n    (\n        Wallet { coins: half, locked },\n        Wallet { coins: coins - half, locked }\n    )\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"When you destructure a resource, you must use all its fields to create new resources or explicitly handle them. The original resource is destroyed in the process."}),"\n",(0,s.jsx)(n.h3,{id:"nested-destructuring",children:"Nested Destructuring"}),"\n",(0,s.jsx)(n.p,{children:"You can destructure nested structures in a single pattern:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"struct Inner has drop {\n    value: u64\n}\n\nstruct Outer has drop {\n    inner: Inner,\n    multiplier: u64\n}\n\npublic fun calculate_total(outer: Outer): u64 {\n    let Outer { \n        inner: Inner { value }, \n        multiplier \n    } = outer;\n    \n    value * multiplier\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This extracts both the outer struct's fields and the inner struct's fields in one expression. It's more concise than multiple destructuring steps."}),"\n",(0,s.jsx)(n.h2,{id:"control-flow-patterns",children:"Control Flow Patterns"}),"\n",(0,s.jsx)(n.p,{children:"Certain control flow patterns appear frequently in Move programs. Understanding these helps you write cleaner, more maintainable code."}),"\n",(0,s.jsx)(n.h3,{id:"early-return-pattern",children:"Early Return Pattern"}),"\n",(0,s.jsx)(n.p,{children:"Use early returns to handle edge cases and reduce nesting:"}),"\n",(0,s.jsx)(n.admonition,{title:"Pattern in Practice",type:"success",children:(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"/guides/escrow#step-3-releasing-funds",children:"Escrow Contract"})," uses early returns extensively in its validation logic. The ",(0,s.jsx)(n.a,{href:"/guides/first-nft#3-creator-gated-mint",children:"NFT minting function"})," also demonstrates this pattern with its creator check."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun complex_validation(account: &Account, amount: u64, recipient: address): bool {\n    // Check each condition and return early if invalid\n    if (account.locked) {\n        return false\n    };\n    \n    if (account.balance < amount) {\n        return false\n    };\n    \n    if (amount < MIN_TRANSFER_AMOUNT) {\n        return false\n    };\n    \n    if (is_blacklisted(recipient)) {\n        return false\n    };\n    \n    // All validations passed\n    true\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Instead of deeply nested if-else chains, each condition that would make the operation invalid causes an early return. This keeps the code flat and makes the logic easier to follow."}),"\n",(0,s.jsx)(n.h3,{id:"guard-clause-pattern",children:"Guard Clause Pattern"}),"\n",(0,s.jsxs)(n.p,{children:["Similar to early returns but typically used with ",(0,s.jsx)(n.code,{children:"abort"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun execute_privileged_action(\n    account: &signer,\n    action: u64,\n    target: address\n) {\n    // Guards first\n    assert!(signer::address_of(account) == @admin, ERROR_NOT_ADMIN);\n    assert!(action < MAX_ACTION_ID, ERROR_INVALID_ACTION);\n    assert!(exists<Account>(target), ERROR_ACCOUNT_NOT_FOUND);\n    \n    // Main logic with all preconditions met\n    match (action) {\n        0 => freeze_account(target),\n        1 => unfreeze_account(target),\n        2 => reset_account(target),\n        _ => abort ERROR_UNKNOWN_ACTION\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Guards establish preconditions at the function's start. If any condition fails, the function aborts immediately. This pattern makes preconditions explicit and keeps the main logic uncluttered."}),"\n",(0,s.jsx)(n.h3,{id:"state-machine-pattern",children:"State Machine Pattern"}),"\n",(0,s.jsx)(n.p,{children:"Use control flow to implement state transitions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"module order::state_machine {\n    const STATE_PENDING: u8 = 0;\n    const STATE_CONFIRMED: u8 = 1;\n    const STATE_SHIPPED: u8 = 2;\n    const STATE_DELIVERED: u8 = 3;\n    const STATE_CANCELLED: u8 = 4;\n    \n    struct Order has key {\n        state: u8,\n        value: u64,\n        customer: address\n    }\n    \n    public fun transition_order(order: &mut Order, new_state: u8) {\n        let current = order.state;\n        \n        // Validate state transition\n        if (current == STATE_PENDING) {\n            assert!(\n                new_state == STATE_CONFIRMED || new_state == STATE_CANCELLED,\n                ERROR_INVALID_TRANSITION\n            );\n        } else if (current == STATE_CONFIRMED) {\n            assert!(\n                new_state == STATE_SHIPPED || new_state == STATE_CANCELLED,\n                ERROR_INVALID_TRANSITION\n            );\n        } else if (current == STATE_SHIPPED) {\n            assert!(new_state == STATE_DELIVERED, ERROR_INVALID_TRANSITION);\n        } else {\n            abort ERROR_TERMINAL_STATE\n        };\n        \n        order.state = new_state;\n        emit_state_change_event(current, new_state);\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This pattern ensures only valid state transitions occur. The control flow explicitly encodes the state machine's rules, making invalid transitions impossible."}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"\ud83d\udcda Advanced Control Flow Patterns"}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Retry Pattern with Exponential Backoff"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun retry_with_backoff(max_attempts: u64): bool {\n    let attempt = 0;\n    let delay = 1;\n    \n    loop {\n        if (attempt >= max_attempts) {\n            break false\n        };\n        \n        if (try_operation()) {\n            break true\n        };\n        \n        wait(delay);\n        delay = delay * 2;\n        attempt = attempt + 1;\n    }\n}\n"})}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Circuit Breaker Pattern"})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"struct CircuitBreaker has key {\n    failures: u64,\n    last_failure_time: u64,\n    state: u8,  // 0: closed, 1: open, 2: half-open\n}\n\npublic fun call_with_breaker(breaker: &mut CircuitBreaker): bool {\n    if (breaker.state == 1) {  // Open\n        if (timestamp::now_seconds() - breaker.last_failure_time > RECOVERY_TIME) {\n            breaker.state = 2;  // Try half-open\n        } else {\n            return false\n        }\n    };\n    \n    let success = try_operation();\n    \n    if (success) {\n        breaker.failures = 0;\n        breaker.state = 0;  // Close\n    } else {\n        breaker.failures = breaker.failures + 1;\n        breaker.last_failure_time = timestamp::now_seconds();\n        \n        if (breaker.failures >= FAILURE_THRESHOLD) {\n            breaker.state = 1;  // Open\n        }\n    };\n    \n    success\n}\n"})})]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-for-control-flow",children:"Best Practices for Control Flow"}),"\n",(0,s.jsx)(n.h3,{id:"keep-conditions-simple",children:"Keep Conditions Simple"}),"\n",(0,s.jsx)(n.p,{children:"Break complex conditions into named variables:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// \u274c Hard to read\nif ((balance >= amount && !locked) || (is_admin && override_enabled) || emergency_mode) {\n    // ...\n}\n\n// \u2705 Clear and maintainable\nlet has_sufficient_balance = balance >= amount && !locked;\nlet has_admin_override = is_admin && override_enabled;\nlet can_proceed = has_sufficient_balance || has_admin_override || emergency_mode;\n\nif (can_proceed) {\n    // ...\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Named conditions make your code self-documenting and easier to debug."}),"\n",(0,s.jsx)(n.h3,{id:"avoid-deep-nesting",children:"Avoid Deep Nesting"}),"\n",(0,s.jsx)(n.p,{children:"Flatten your control flow when possible:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// \u274c Deeply nested\npublic fun process_request(request: &Request): u64 {\n    if (is_valid(request)) {\n        if (has_permission(request.sender)) {\n            if (check_limits(request.amount)) {\n                if (!is_duplicate(request)) {\n                    return execute(request)\n                } else {\n                    abort ERROR_DUPLICATE\n                }\n            } else {\n                abort ERROR_EXCEEDS_LIMITS\n            }\n        } else {\n            abort ERROR_NO_PERMISSION\n        }\n    } else {\n        abort ERROR_INVALID_REQUEST\n    }\n}\n\n// \u2705 Flat with early exits\npublic fun process_request(request: &Request): u64 {\n    assert!(is_valid(request), ERROR_INVALID_REQUEST);\n    assert!(has_permission(request.sender), ERROR_NO_PERMISSION);\n    assert!(check_limits(request.amount), ERROR_EXCEEDS_LIMITS);\n    assert!(!is_duplicate(request), ERROR_DUPLICATE);\n    \n    execute(request)\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"loop-invariants",children:"Loop Invariants"}),"\n",(0,s.jsx)(n.p,{children:"Design loops with clear invariants:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun binary_search(sorted_vec: &vector<u64>, target: u64): Option<u64> {\n    let left = 0;\n    let right = vector::length(sorted_vec);\n    \n    while (left < right) {\n        // Invariant: target, if present, is in [left, right)\n        let mid = (left + right) / 2;\n        let mid_val = *vector::borrow(sorted_vec, mid);\n        \n        if (mid_val == target) {\n            return option::some(mid)\n        } else if (mid_val < target) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    };\n    \n    option::none()\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Clear invariants make loops easier to understand and verify correct."}),"\n",(0,s.jsx)(n.admonition,{title:"Control Flow Guidelines",type:"tip",children:(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Prefer expressions over statements"}),": Use if-else as expressions when possible"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Exit early"}),": Handle error cases first with early returns or aborts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Keep loops simple"}),": Complex loop logic often indicates a need for helper functions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Make state transitions explicit"}),": Use clear patterns for state machines"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Document non-obvious flow"}),": Comment why, not what"]}),"\n"]})}),"\n",(0,s.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsx)(n.p,{children:"Control flow in Move balances familiar constructs with blockchain-specific requirements:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Everything is deterministic"}),": No randomness or external inputs in conditions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Loops must terminate"}),": The compiler verifies this to prevent infinite execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pattern matching is exhaustive"}),": All cases must be handled"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Early exits are idiomatic"}),": Guard clauses and early returns improve readability"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource safety is maintained"}),": Control flow respects Move's ownership rules"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Understanding these patterns helps you write efficient, safe code that clearly expresses your intent."}),"\n",(0,s.jsx)(n.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,s.jsxs)(n.p,{children:["In our next article, ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/move/errors",children:"Error Handling and Assertions in Move"})}),", we'll explore how to handle failures gracefully. You'll learn about Move's abort codes, assertion patterns, and strategies for building robust error handling into your modules."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var i=t(6540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);