"use strict";(self.webpackChunkcedra_docs=self.webpackChunkcedra_docs||[]).push([[2672],{8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var t=s(6540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}},9661:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"move/basics","title":"Basic Syntax and Data Types - Building Blocks of Move","description":"Master Move\'s syntax fundamentals and type system. Learn about variables, data types, structs, and the unique ability system that makes Move perfect for blockchain development.","source":"@site/docs/move/basics.md","sourceDirName":"move","slug":"/move/basics","permalink":"/move/basics","draft":false,"unlisted":false,"editUrl":"https://github.com/cedra-labs/docs/edit/main/docs/move/basics.md","tags":[],"version":"current","frontMatter":{"title":"Basic Syntax and Data Types - Building Blocks of Move","sidebar_label":"Basic Syntax and Data Types","description":"Master Move\'s syntax fundamentals and type system. Learn about variables, data types, structs, and the unique ability system that makes Move perfect for blockchain development.","keywords":["move syntax","data types","structs","abilities","vectors","blockchain programming"]},"sidebar":"docs","previous":{"title":"Resource First Programming","permalink":"/move/introduction"},"next":{"title":"Move Modules","permalink":"/move/modules"}}');var i=s(4848),r=s(8453);const a={title:"Basic Syntax and Data Types - Building Blocks of Move",sidebar_label:"Basic Syntax and Data Types",description:"Master Move's syntax fundamentals and type system. Learn about variables, data types, structs, and the unique ability system that makes Move perfect for blockchain development.",keywords:["move syntax","data types","structs","abilities","vectors","blockchain programming"]},o="Basic Syntax and Data Types: Building Blocks of Move",c={},l=[{value:"Variable Declaration",id:"variable-declaration",level:3},{value:"Constants: Compile-Time Values",id:"constants-compile-time-values",level:3},{value:"Primitive Data Types: The Foundation",id:"primitive-data-types-the-foundation",level:2},{value:"Integer Types: Unsigned Only",id:"integer-types-unsigned-only",level:3},{value:"Boolean Type: True or False",id:"boolean-type-true-or-false",level:3},{value:"Address Type: Unique to Blockchain",id:"address-type-unique-to-blockchain",level:3},{value:"Vectors: Dynamic Collections",id:"vectors-dynamic-collections",level:2},{value:"Creating Vectors",id:"creating-vectors",level:3},{value:"Vector Operations",id:"vector-operations",level:3},{value:"Safe Vector Access",id:"safe-vector-access",level:3},{value:"Structs and Abilities: Custom Types with Superpowers",id:"structs-and-abilities-custom-types-with-superpowers",level:2},{value:"Defining Structs",id:"defining-structs",level:3},{value:"The Ability System",id:"the-ability-system",level:3},{value:"Combining Abilities",id:"combining-abilities",level:3},{value:"References: Borrowing Without Taking",id:"references-borrowing-without-taking",level:2},{value:"Immutable References",id:"immutable-references",level:3},{value:"Mutable References",id:"mutable-references",level:3},{value:"Working with Strings and Bytes",id:"working-with-strings-and-bytes",level:2},{value:"Byte Vectors and Hex Literals",id:"byte-vectors-and-hex-literals",level:3},{value:"Type Inference: Let Move Figure It Out",id:"type-inference-let-move-figure-it-out",level:2},{value:"Common Patterns and Best Practices",id:"common-patterns-and-best-practices",level:2},{value:"Naming Conventions",id:"naming-conventions",level:3},{value:"Early Returns for Cleaner Code",id:"early-returns-for-cleaner-code",level:3},{value:"Destructuring for Clarity",id:"destructuring-for-clarity",level:3},{value:"Practice Exercise",id:"practice-exercise",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"What&#39;s Next?",id:"whats-next",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"basic-syntax-and-data-types-building-blocks-of-move",children:"Basic Syntax and Data Types: Building Blocks of Move"})}),"\n",(0,i.jsx)(n.p,{children:"In Move, data immutability is the default, reflecting the blockchain's emphasis on predictable, secure state changes. This design choice prevents accidental modifications and makes code easier to reason about."}),"\n",(0,i.jsx)(n.h3,{id:"variable-declaration",children:"Variable Declaration"}),"\n",(0,i.jsxs)(n.p,{children:["Move uses the ",(0,i.jsx)(n.code,{children:"let"})," keyword to declare variables. By default, all variables are immutable \u2013 once assigned, their values cannot change. This isn't a limitation; it's a feature that prevents entire classes of bugs."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let immutable_value = 42;\nlet another_value: u64 = 100;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the first line, Move infers that ",(0,i.jsx)(n.code,{children:"immutable_value"})," is of type ",(0,i.jsx)(n.code,{children:"u64"})," because integer literals default to ",(0,i.jsx)(n.code,{children:"u64"}),". This is Move's most common integer type, perfect for balances, counts, and most numeric operations you'll encounter in blockchain development."]}),"\n",(0,i.jsxs)(n.p,{children:["The second line shows explicit type annotation using the colon syntax (",(0,i.jsx)(n.code,{children:": u64"}),"). While Move's type inference is excellent, explicit annotations are useful when you need a specific type that differs from the default, or when you want to make your intentions crystal clear to other developers."]}),"\n",(0,i.jsxs)(n.p,{children:["When you do need mutability, Move requires explicit declaration using the ",(0,i.jsx)(n.code,{children:"mut"})," keyword:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let mut counter = 0;\ncounter = counter + 1;\n\nlet mut balance = 1000;\nbalance = balance - 100;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"mut"}),' keyword serves as a bright warning sign: "This value will change!" This explicitness helps prevent bugs because you can immediately see which values might change during execution. In the counter example, we\'re incrementing a value \u2013 a common pattern for tracking iterations or counting events. The balance example shows a typical deduction operation, like you might use when processing a payment.']}),"\n",(0,i.jsx)(n.h3,{id:"constants-compile-time-values",children:"Constants: Compile-Time Values"}),"\n",(0,i.jsx)(n.p,{children:"Constants in Move are values known at compile time. They're perfect for configuration values, error codes, and any value that shouldn't change during execution:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"const MAX_SUPPLY: u64 = 1_000_000_000;\nconst FEE_PERCENTAGE: u8 = 3;\nconst ERROR_INSUFFICIENT_FUNDS: u64 = 1;\nconst MINIMUM_STAKE: u64 = 100_000;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Constants must follow strict rules:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["They require explicit type annotations (",(0,i.jsx)(n.code,{children:":u64"}),", ",(0,i.jsx)(n.code,{children:":u8"}),", etc.)"]}),"\n",(0,i.jsx)(n.li,{children:"Their names must be in SCREAMING_SNAKE_CASE"}),"\n",(0,i.jsx)(n.li,{children:"Their values must be computable at compile time"}),"\n",(0,i.jsx)(n.li,{children:"They're inlined wherever used, not stored in memory"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"MAX_SUPPLY"})," constant might represent the total supply of a token \u2013 using a constant ensures this critical value can never be accidentally modified. ",(0,i.jsx)(n.code,{children:"FEE_PERCENTAGE"})," as a ",(0,i.jsx)(n.code,{children:"u8"})," (0-255) is perfect for percentages since you rarely need values above 100. Error codes like ",(0,i.jsx)(n.code,{children:"ERROR_INSUFFICIENT_FUNDS"})," make your abort conditions self-documenting. When your code aborts with error code 1, developers can immediately see it's due to insufficient funds."]}),"\n",(0,i.jsxs)(n.p,{children:["The underscores in large numbers (",(0,i.jsx)(n.code,{children:"1_000_000_000"}),") are purely for human readability \u2013 the compiler ignores them. This feature prevents errors when dealing with large numbers common in blockchain (wei, gwei, token amounts with many decimals)."]}),"\n",(0,i.jsx)(n.h2,{id:"primitive-data-types-the-foundation",children:"Primitive Data Types: The Foundation"}),"\n",(0,i.jsx)(n.p,{children:"Move's type system is deliberately simple yet powerful. Unlike general-purpose languages with dozens of types, Move focuses on what matters for blockchain development."}),"\n",(0,i.jsx)(n.h3,{id:"integer-types-unsigned-only",children:"Integer Types: Unsigned Only"}),"\n",(0,i.jsx)(n.p,{children:"Move exclusively uses unsigned integers \u2013 there are no negative numbers in Move. This design choice eliminates an entire class of underflow bugs and aligns with blockchain's typical use cases:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let tiny: u8 = 255;\nlet small: u16 = 65_535;\nlet medium: u32 = 4_294_967_295;\nlet large: u64 = 18_446_744_073_709_551_615;\nlet huge: u128 = 340_282_366_920_938_463_463_374_607_431_768_211_455;\nlet massive: u256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Each integer type serves specific purposes:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"u8"})," (0 to 255): Perfect for percentages, small counters, or enum-like values. If you're representing a fee percentage, user level, or any value guaranteed to stay small, ",(0,i.jsx)(n.code,{children:"u8"})," saves space."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"u16"})," (0 to 65,535): Rarely used in Move, but useful for larger counters or IDs that won't exceed 65k. You might use this for item IDs in a game with a limited catalog."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"u32"})," (0 to ~4.3 billion): Good for timestamps in seconds (works until year 2106), large counters, or database-style IDs. However, ",(0,i.jsx)(n.code,{children:"u64"})," is usually preferred for future-proofing."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"u64"})," (0 to ~18.4 quintillion): The workhorse of Move. This is the default type for integer literals and perfect for token amounts, timestamps in milliseconds, and any value that might grow large. Most Cedra framework functions expect ",(0,i.jsx)(n.code,{children:"u64"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"u128"})," (0 to ~340 undecillion): Essential for intermediate calculations to prevent overflow. When multiplying large ",(0,i.jsx)(n.code,{children:"u64"})," values (like calculating rewards or interest), use ",(0,i.jsx)(n.code,{children:"u128"})," for the intermediate result, then convert back to ",(0,i.jsx)(n.code,{children:"u64"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"u256"}),": Primarily for cryptographic operations and compatibility with Ethereum-style numbers. Unless you're doing cryptography or bridging from Ethereum, you probably don't need this."]}),"\n",(0,i.jsx)(n.admonition,{title:"Choosing the Right Integer Type",type:"tip",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"u8"}),": Percentages, levels, small enums (0-255)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"u64"}),": Token amounts, timestamps, IDs (default choice)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"u128"}),": Intermediate calculations to prevent overflow"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Others"}),": Rarely needed unless interfacing with external systems"]}),"\n"]})}),"\n",(0,i.jsx)(n.h3,{id:"boolean-type-true-or-false",children:"Boolean Type: True or False"}),"\n",(0,i.jsx)(n.p,{children:"Booleans in Move work exactly as you'd expect, supporting standard logical operations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let is_active: bool = true;\nlet is_paused = false;\n\nlet can_withdraw = is_active && !is_paused;\nlet needs_action = has_expired || is_emergency;\nlet is_valid = amount > 0 && amount <= max_amount;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Boolean logic in Move follows short-circuit evaluation:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["In ",(0,i.jsx)(n.code,{children:"&&"})," (AND) operations, if the first condition is false, the second isn't evaluated"]}),"\n",(0,i.jsxs)(n.li,{children:["In ",(0,i.jsx)(n.code,{children:"||"})," (OR) operations, if the first condition is true, the second isn't evaluated"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This behavior is crucial for gas efficiency and allows patterns like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let safe_check = divisor != 0 && (total / divisor) > threshold;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here, the division only executes if ",(0,i.jsx)(n.code,{children:"divisor"})," is non-zero, preventing a division-by-zero error. The ",(0,i.jsx)(n.code,{children:"is_valid"})," example shows a common pattern for range checking \u2013 ensuring a value is positive but within bounds, essential for preventing overflow in financial operations."]}),"\n",(0,i.jsx)(n.h3,{id:"address-type-unique-to-blockchain",children:"Address Type: Unique to Blockchain"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"address"})," type is Move's special type for blockchain addresses. Addresses are 32-byte values that identify accounts and modules:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let fixed_address: address = @0x1;\nlet marketplace_address = @marketplace;\nlet user_address = @0x1234567890ABCDEF;\n\nuse std::signer;\nlet sender_address = signer::address_of(account);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Address literals (prefixed with ",(0,i.jsx)(n.code,{children:"@"}),") can be written in several forms:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"@0x1"})," - Hexadecimal form (0x followed by up to 64 hex characters)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"@marketplace"})," - Named address (defined in Move.toml)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"@0x0000000000000000000000000000000000000000000000000000000000000001"})," - Full 32-byte form"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"@0x1"})," address is special \u2013 it's where the standard library and framework modules live. When you use ",(0,i.jsx)(n.code,{children:"std::vector"}),", you're actually accessing ",(0,i.jsx)(n.code,{children:"0x1::vector"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Named addresses like ",(0,i.jsx)(n.code,{children:"@marketplace"})," improve code readability and maintainability. They're resolved from your Move.toml file:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-toml",children:'[addresses]\nmarketplace = "0x5678"\nstaking = "0x9ABC"\n'})}),"\n",(0,i.jsx)(n.h2,{id:"vectors-dynamic-collections",children:"Vectors: Dynamic Collections"}),"\n",(0,i.jsx)(n.p,{children:"Vectors are Move's only built-in collection type \u2013 a dynamic array that can grow or shrink. Understanding vectors is crucial because they're everywhere in Move code."}),"\n",(0,i.jsx)(n.admonition,{title:"Real-World Usage",type:"info",children:(0,i.jsxs)(n.p,{children:["See vectors in action in our ",(0,i.jsx)(n.a,{href:"/guides/fee-splitter",children:"Fee Splitter Guide"})," where ",(0,i.jsx)(n.code,{children:"vector<Recipient>"})," stores payment recipients, or in the ",(0,i.jsx)(n.a,{href:"/guides/escrow",children:"Escrow Contract"})," where vectors manage multiple locked funds."]})}),"\n",(0,i.jsx)(n.h3,{id:"creating-vectors",children:"Creating Vectors"}),"\n",(0,i.jsx)(n.p,{children:"Move provides multiple ways to create vectors, each suited to different scenarios:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use std::vector;\n\nlet empty = vector::empty<u64>();\nlet with_values = vector[1, 2, 3, 4, 5];\nlet single_item = vector::singleton(42);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"vector::empty<u64>()"})," function creates an empty vector that will hold ",(0,i.jsx)(n.code,{children:"u64"})," values. The type parameter ",(0,i.jsx)(n.code,{children:"<u64>"})," is mandatory \u2013 Move needs to know what type of elements the vector will contain, even when empty. This is commonly used when you'll be adding elements dynamically."]}),"\n",(0,i.jsxs)(n.p,{children:["The vector literal syntax ",(0,i.jsx)(n.code,{children:"vector[1, 2, 3, 4, 5]"})," is syntactic sugar that makes code more readable. Under the hood, Move creates an empty vector and pushes each element. This is perfect for small, known collections like initial configuration values or test data."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"vector::singleton(42)"})," creates a vector with exactly one element. This is more efficient than ",(0,i.jsx)(n.code,{children:"vector[42]"})," and clearly communicates intent \u2013 you want a vector with just one item."]}),"\n",(0,i.jsx)(n.h3,{id:"vector-operations",children:"Vector Operations"}),"\n",(0,i.jsx)(n.p,{children:"Vectors support a rich set of operations for manipulation and querying:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"public fun vector_operations_demo() {\n    let mut numbers = vector[10, 20, 30];\n    \n    vector::push_back(&mut numbers, 40);\n    \n    let length = vector::length(&numbers);\n    \n    let first = *vector::borrow(&numbers, 0);\n    let last = *vector::borrow(&numbers, length - 1);\n    \n    let removed = vector::pop_back(&mut numbers);\n    \n    let contains_20 = vector::contains(&numbers, &20);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Let's break down each operation:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"push_back"}),": Adds an element to the end of the vector. This is O(1) amortized time complexity. The ",(0,i.jsx)(n.code,{children:"&mut numbers"})," syntax passes a mutable reference, allowing the function to modify the vector. After this operation, ",(0,i.jsx)(n.code,{children:"numbers"})," is ",(0,i.jsx)(n.code,{children:"[10, 20, 30, 40]"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"length"}),": Returns the number of elements as a ",(0,i.jsx)(n.code,{children:"u64"}),". This is O(1) \u2013 vectors track their length, so this doesn't count elements. Essential for bounds checking and iteration."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"borrow"}),": Returns an immutable reference to an element at the given index. The ",(0,i.jsx)(n.code,{children:"*"})," dereferences the returned reference to get the actual value. If the index is out of bounds, the transaction aborts. Note that indexing is 0-based, just like most programming languages."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"pop_back"}),": Removes and returns the last element. This is O(1) and commonly used in stack-like patterns. If the vector is empty, this operation aborts. After popping, ",(0,i.jsx)(n.code,{children:"numbers"})," becomes ",(0,i.jsx)(n.code,{children:"[10, 20, 30]"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"contains"}),": Searches the vector for a value, returning ",(0,i.jsx)(n.code,{children:"true"})," if found. This is O(n) \u2013 it checks each element sequentially. The ",(0,i.jsx)(n.code,{children:"&20"})," syntax creates a reference to the value 20 for comparison."]}),"\n",(0,i.jsx)(n.h3,{id:"safe-vector-access",children:"Safe Vector Access"}),"\n",(0,i.jsx)(n.p,{children:"Move prevents out-of-bounds access at runtime. This function shows a safe access pattern:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"public fun safe_access(vec: &vector<u64>, index: u64): u64 {\n    if (index < vector::length(vec)) {\n        *vector::borrow(vec, index)\n    } else {\n        0\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This pattern is crucial for user-provided indices. Instead of aborting the transaction (and wasting gas), we check bounds first and return a default value for invalid indices. This is especially important in view functions that shouldn't fail."}),"\n",(0,i.jsx)(n.h2,{id:"structs-and-abilities-custom-types-with-superpowers",children:"Structs and Abilities: Custom Types with Superpowers"}),"\n",(0,i.jsx)(n.p,{children:"Structs are how you define custom data types in Move. What makes Move's structs unique is the ability system \u2013 a way to precisely control what operations are allowed on your types."}),"\n",(0,i.jsx)(n.h3,{id:"defining-structs",children:"Defining Structs"}),"\n",(0,i.jsx)(n.p,{children:"A basic struct definition looks familiar if you've used other languages:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"struct Point {\n    x: u64,\n    y: u64\n}\n\nstruct User {\n    name: vector<u8>,\n    age: u8,\n    address: address\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["These struct definitions create new types. ",(0,i.jsx)(n.code,{children:"Point"})," might represent a location in a game, with ",(0,i.jsx)(n.code,{children:"x"})," and ",(0,i.jsx)(n.code,{children:"y"})," coordinates. The ",(0,i.jsx)(n.code,{children:"User"})," struct shows a more complex type with mixed field types. Note that ",(0,i.jsx)(n.code,{children:"name"})," is ",(0,i.jsx)(n.code,{children:"vector<u8>"})," \u2013 Move doesn't have a built-in string type, so we use byte vectors for text."]}),"\n",(0,i.jsx)(n.p,{children:"Without any abilities, these structs are very limited:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"They can be created within their declaring module"}),"\n",(0,i.jsx)(n.li,{children:"They can be moved (ownership transfer)"}),"\n",(0,i.jsx)(n.li,{children:"They cannot be copied"}),"\n",(0,i.jsx)(n.li,{children:"They cannot be dropped (must be explicitly handled)"}),"\n",(0,i.jsx)(n.li,{children:"They cannot be stored in global storage"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This restrictiveness is a feature! It makes these structs perfect for representing scarce resources."}),"\n",(0,i.jsx)(n.h3,{id:"the-ability-system",children:"The Ability System"}),"\n",(0,i.jsx)(n.p,{children:"Move's abilities are like superpowers you grant to your structs. There are four abilities, each enabling specific operations:"}),"\n",(0,i.jsx)(n.admonition,{title:"See Abilities in Action",type:"tip",children:(0,i.jsxs)(n.p,{children:["Our ",(0,i.jsx)(n.a,{href:"/guides/first-fa",children:"Fungible Asset Guide"})," shows how ",(0,i.jsx)(n.code,{children:"has store"})," enables tokens to be stored in wallets, while our ",(0,i.jsx)(n.a,{href:"/guides/first-nft",children:"NFT Guide"})," demonstrates ",(0,i.jsx)(n.code,{children:"has key, store"})," for unique collectibles that can exist independently or in collections."]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"copy"})," - Allows the type to be copied:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"struct Config has copy {\n    fee_rate: u8,\n    is_paused: bool\n}\n\nlet config1 = Config { fee_rate: 5, is_paused: false };\nlet config2 = config1;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["With the ",(0,i.jsx)(n.code,{children:"copy"})," ability, ",(0,i.jsx)(n.code,{children:"config2 = config1"})," creates a full copy. Both variables now have independent copies of the data. This is perfect for configuration data, settings, or any value that should be freely duplicated."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"drop"})," - Allows the type to be discarded:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"struct TempData has drop {\n    cache: vector<u8>\n}\n\nfun use_temp_data() {\n    let temp = TempData { cache: vector[] };\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Without ",(0,i.jsx)(n.code,{children:"drop"}),', you\'d get a compiler error: "unused value without drop". The ',(0,i.jsx)(n.code,{children:"drop"})," ability tells Move it's safe to discard this value when it goes out of scope. This is essential for temporary values, caches, or any data that doesn't represent a scarce resource."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"store"})," - Allows the type to be stored in other structs:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"struct Token has store {\n    amount: u64\n}\n\nstruct Wallet has key {\n    tokens: vector<Token>\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"store"})," ability is required for any type you want to put inside containers (vectors, other structs, or global storage). Without ",(0,i.jsx)(n.code,{children:"store"}),", ",(0,i.jsx)(n.code,{children:"Token"})," couldn't be placed in the ",(0,i.jsx)(n.code,{children:"tokens"})," vector."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"key"})," - Allows the type to exist in global storage:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"struct Account has key {\n    balance: u64,\n    sequence_number: u64\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"key"})," ability is special \u2013 it allows a struct to be a top-level resource in global storage. These structs can be:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Published to an address with ",(0,i.jsx)(n.code,{children:"move_to"})]}),"\n",(0,i.jsxs)(n.li,{children:["Read with ",(0,i.jsx)(n.code,{children:"borrow_global"})," or ",(0,i.jsx)(n.code,{children:"borrow_global_mut"})]}),"\n",(0,i.jsxs)(n.li,{children:["Removed with ",(0,i.jsx)(n.code,{children:"move_from"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Only one instance of each ",(0,i.jsx)(n.code,{children:"key"})," struct can exist at each address, making them perfect for representing accounts, profiles, or unique game state."]}),"\n",(0,i.jsx)(n.h3,{id:"combining-abilities",children:"Combining Abilities"}),"\n",(0,i.jsx)(n.p,{children:"Real-world structs often need multiple abilities. The combination you choose depends on your use case:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"struct Message has copy, drop {\n    text: vector<u8>,\n    timestamp: u64\n}\n\nstruct NFT has key, store {\n    id: u64,\n    uri: vector<u8>,\n    creator: address\n}\n\nstruct Coin has store {\n    value: u64\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Message"})," with ",(0,i.jsx)(n.code,{children:"copy, drop"})," is perfect for events or notifications. It can be freely copied (sending the same message to multiple recipients) and dropped (no cleanup needed)."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"NFT"})," with ",(0,i.jsx)(n.code,{children:"key, store"})," can exist as a top-level resource (a standalone NFT at an address) OR be stored in collections (like a vector of NFTs in a gallery)."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Coin"})," with only ",(0,i.jsx)(n.code,{children:"store"})," is the classic resource pattern. It can't be copied (no duplication of money), can't be dropped (no destroying value), but can be stored in wallets or other containers."]}),"\n",(0,i.jsx)(n.admonition,{title:"Try It Yourself",type:"success",children:(0,i.jsxs)(n.p,{children:["Ready to see these patterns in action? Our ",(0,i.jsx)(n.a,{href:"/guides/first-nft",children:"NFT Guide"})," shows exactly how ",(0,i.jsx)(n.code,{children:"NFT has key, store"})," works in practice, while our ",(0,i.jsx)(n.a,{href:"/guides/first-fa",children:"Fungible Asset Guide"})," demonstrates the ",(0,i.jsx)(n.code,{children:"Coin has store"})," pattern for creating your own cryptocurrency."]})}),"\n",(0,i.jsx)(n.h2,{id:"references-borrowing-without-taking",children:"References: Borrowing Without Taking"}),"\n",(0,i.jsx)(n.p,{children:"References in Move allow you to access data without taking ownership. This is crucial for reading values or making modifications while keeping the original owner intact."}),"\n",(0,i.jsx)(n.h3,{id:"immutable-references",children:"Immutable References"}),"\n",(0,i.jsxs)(n.p,{children:["Immutable references (using ",(0,i.jsx)(n.code,{children:"&"}),") allow read-only access:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"struct Balance has key {\n    amount: u64\n}\n\npublic fun check_balance(account_addr: address): u64 acquires Balance {\n    let balance_ref = borrow_global<Balance>(account_addr);\n    balance_ref.amount\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"borrow_global<Balance>"})," function returns a reference to the ",(0,i.jsx)(n.code,{children:"Balance"})," stored at ",(0,i.jsx)(n.code,{children:"account_addr"}),". This reference allows us to read the data without removing it from storage. The ",(0,i.jsx)(n.code,{children:"acquires Balance"})," annotation tells Move that this function will access ",(0,i.jsx)(n.code,{children:"Balance"})," resources \u2013 this is required for global storage operations and helps prevent reentrancy."]}),"\n",(0,i.jsx)(n.h3,{id:"mutable-references",children:"Mutable References"}),"\n",(0,i.jsxs)(n.p,{children:["Mutable references (using ",(0,i.jsx)(n.code,{children:"&mut"}),") allow modification:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"public fun increase_balance(balance: &mut Balance, amount: u64) {\n    balance.amount = balance.amount + amount;\n}\n\npublic fun transfer_between(from: &mut Balance, to: &mut Balance, amount: u64) {\n    assert!(from.amount >= amount, ERROR_INSUFFICIENT_FUNDS);\n    from.amount = from.amount - amount;\n    to.amount = to.amount + amount;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"&mut Balance"})," parameter type indicates this function will modify the balance. Inside the function, we can assign to fields through the reference. This modification affects the original data \u2013 there's no copying involved."]}),"\n",(0,i.jsxs)(n.admonition,{title:"Reference Safety Rules",type:"warning",children:[(0,i.jsx)(n.p,{children:"Move enforces strict rules to prevent data races:"}),(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"You can have either one mutable reference OR any number of immutable references"}),"\n",(0,i.jsx)(n.li,{children:"References cannot outlive the data they point to"}),"\n",(0,i.jsx)(n.li,{children:"References cannot be stored in structs (unless the struct is never stored)"}),"\n"]})]}),"\n",(0,i.jsx)(n.h2,{id:"working-with-strings-and-bytes",children:"Working with Strings and Bytes"}),"\n",(0,i.jsxs)(n.p,{children:["Move doesn't have a built-in string type. Instead, it uses byte vectors (",(0,i.jsx)(n.code,{children:"vector<u8>"}),") with UTF-8 encoding. The standard library provides a String module for convenience:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use std::string::{Self, String};\n\npublic fun string_examples() {\n    let hello = string::utf8(b"Hello, Move!");\n    \n    let mut greeting = string::utf8(b"Hello");\n    string::append(&mut greeting, string::utf8(b" World"));\n    \n    let bytes = string::bytes(&greeting);\n    let length = string::length(&greeting);\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"string::utf8()"})," function creates a ",(0,i.jsx)(n.code,{children:"String"})," from a byte literal. The ",(0,i.jsx)(n.code,{children:'b"Hello, Move!"'})," syntax creates a byte vector from ASCII text. The function validates that the bytes are valid UTF-8 \u2013 if you pass invalid UTF-8, the transaction aborts."]}),"\n",(0,i.jsx)(n.h3,{id:"byte-vectors-and-hex-literals",children:"Byte Vectors and Hex Literals"}),"\n",(0,i.jsx)(n.p,{children:"Move supports several ways to create byte vectors:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let byte_string = b"Hello";\nlet hex_data = x"48656C6C6F";\nlet empty_bytes = vector::empty<u8>();\n\nlet address_bytes = x"0000000000000000000000000000000000000000000000000000000000000001";\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:'b"Hello"'})," creates a byte vector from ASCII text. Each character becomes one byte. This is the most readable format for text data."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:'x"48656C6C6F"'})," creates the same byte vector using hexadecimal. Each pair of hex digits becomes one byte. ",(0,i.jsx)(n.code,{children:"48"})," is 'H', ",(0,i.jsx)(n.code,{children:"65"})," is 'e', etc. This format is perfect for binary data or when you need exact byte values."]}),"\n",(0,i.jsx)(n.h2,{id:"type-inference-let-move-figure-it-out",children:"Type Inference: Let Move Figure It Out"}),"\n",(0,i.jsx)(n.p,{children:"Move's type inference is smart enough to figure out types in most situations, making code cleaner and easier to write:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let inferred = 42;\nlet also_inferred = vector[1, 2, 3];\nlet struct_inferred = Point { x: 10, y: 20 };\n\nlet explicit: u8 = 42;\nlet small_number = 42u8;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For ",(0,i.jsx)(n.code,{children:"inferred"}),", Move sees the integer literal 42 and assigns it type ",(0,i.jsx)(n.code,{children:"u64"})," (the default). For ",(0,i.jsx)(n.code,{children:"also_inferred"}),", it sees a vector of integer literals and infers ",(0,i.jsx)(n.code,{children:"vector<u64>"}),". For ",(0,i.jsx)(n.code,{children:"struct_inferred"}),", it knows from the field names that this must be a ",(0,i.jsx)(n.code,{children:"Point"})," struct."]}),"\n",(0,i.jsx)(n.p,{children:"Type inference works through function calls too:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"public fun create_pair<T>(first: T, second: T): vector<T> {\n    vector[first, second]\n}\n\nlet numbers = create_pair(10, 20);\nlet addresses = create_pair(@0x1, @0x2);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The generic function ",(0,i.jsx)(n.code,{children:"create_pair<T>"})," works with any type ",(0,i.jsx)(n.code,{children:"T"}),". When called with integers, Move infers ",(0,i.jsx)(n.code,{children:"T = u64"}),". When called with addresses, it infers ",(0,i.jsx)(n.code,{children:"T = address"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"common-patterns-and-best-practices",children:"Common Patterns and Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"naming-conventions",children:"Naming Conventions"}),"\n",(0,i.jsx)(n.p,{children:"Move follows Rust-style naming conventions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"const MAX_SUPPLY: u64 = 1_000_000;\nlet user_balance = 1000;\nstruct UserAccount has key { }\nfun calculate_fee() { }\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Constants: SCREAMING_SNAKE_CASE"}),"\n",(0,i.jsx)(n.li,{children:"Variables and functions: snake_case"}),"\n",(0,i.jsx)(n.li,{children:"Types (structs): PascalCase"}),"\n",(0,i.jsx)(n.li,{children:"Module names: snake_case"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"early-returns-for-cleaner-code",children:"Early Returns for Cleaner Code"}),"\n",(0,i.jsx)(n.p,{children:"Use early returns to handle edge cases and keep the main logic unindented:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"public fun safe_divide(numerator: u64, denominator: u64): u64 {\n    if (denominator == 0) {\n        abort ERROR_DIVISION_BY_ZERO\n    };\n    \n    numerator / denominator\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"This pattern, called \"guard clauses\", handles exceptional cases first. The main logic isn't nested in an else block, each condition is independent and clear, and it's easier to add new conditions without restructuring."}),"\n",(0,i.jsx)(n.h3,{id:"destructuring-for-clarity",children:"Destructuring for Clarity"}),"\n",(0,i.jsx)(n.p,{children:"Move supports pattern matching and destructuring:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"struct Pair has drop {\n    first: u64,\n    second: u64\n}\n\npublic fun sum_pair(pair: Pair): u64 {\n    let Pair { first, second } = pair;\n    first + second\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Destructuring extracts field values in one statement. The pattern ",(0,i.jsx)(n.code,{children:"Pair { first, second }"})," must match the struct's fields exactly."]}),"\n",(0,i.jsx)(n.h2,{id:"practice-exercise",children:"Practice Exercise"}),"\n",(0,i.jsxs)(n.admonition,{title:"Try This: Design a Token System",type:"note",children:[(0,i.jsx)(n.p,{children:"Create a simple token system with these requirements:"}),(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"A Token struct that represents fungible tokens"}),"\n",(0,i.jsx)(n.li,{children:"A Wallet struct that can hold tokens"}),"\n",(0,i.jsx)(n.li,{children:"Functions to create, transfer, and check balance"}),"\n"]}),(0,i.jsx)(n.p,{children:"Think about:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Which abilities does each struct need?"}),"\n",(0,i.jsx)(n.li,{children:"How to prevent token duplication?"}),"\n",(0,i.jsx)(n.li,{children:"How to ensure safe transfers?"}),"\n"]})]}),"\n",(0,i.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,i.jsx)(n.p,{children:"You now have a solid foundation in Move's syntax and type system. Every concept we've covered serves Move's goal of safe, predictable asset management:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Immutability by default"})," prevents accidental state changes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unsigned integers only"})," eliminates underflow vulnerabilities"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"The ability system"})," gives precise control over resource behavior"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"References"})," enable efficient access without ownership transfer"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type inference"})," reduces boilerplate while maintaining safety"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,i.jsxs)(n.p,{children:["In our next article, ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/move/modules",children:"Move Modules: Understanding Modular Programming"})}),", we'll explore how to organize code into modules, control visibility with public and friend functions, and build larger applications with proper separation of concerns."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);