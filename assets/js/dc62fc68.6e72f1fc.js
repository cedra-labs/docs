"use strict";(self.webpackChunkcedra_docs=self.webpackChunkcedra_docs||[]).push([[6239],{6696:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"move/ownership","title":"Move Ownership and Borrowing","description":"Master Move\'s ownership system and borrowing rules. Learn how references enable efficient access to resources without taking ownership, and discover patterns for safe resource manipulation.","source":"@site/docs/move/ownership.md","sourceDirName":"move","slug":"/move/ownership","permalink":"/move/ownership","draft":false,"unlisted":false,"editUrl":"https://github.com/cedra-labs/docs/edit/main/docs/move/ownership.md","tags":[],"version":"current","frontMatter":{"title":"Move Ownership and Borrowing","description":"Master Move\'s ownership system and borrowing rules. Learn how references enable efficient access to resources without taking ownership, and discover patterns for safe resource manipulation.","keywords":["move ownership","borrowing","references","mutable references","resource access","move programming"]},"sidebar":"docs","previous":{"title":"Resource Types","permalink":"/move/resource"},"next":{"title":"Conditionals, Loops, and Control Flow","permalink":"/move/flow"}}');var o=t(4848),a=t(8453);const s={title:"Move Ownership and Borrowing",description:"Master Move's ownership system and borrowing rules. Learn how references enable efficient access to resources without taking ownership, and discover patterns for safe resource manipulation.",keywords:["move ownership","borrowing","references","mutable references","resource access","move programming"]},c="Move Ownership and Borrowing",i={},l=[{value:"References: Borrowing Without Taking",id:"references-borrowing-without-taking",level:2},{value:"Immutable References (&amp;T)",id:"immutable-references-t",level:3},{value:"Creating References",id:"creating-references",level:3},{value:"Mutable References (&amp;mut T)",id:"mutable-references-mut-t",level:3},{value:"Borrowing Rules: Safety Through Restrictions",id:"borrowing-rules-safety-through-restrictions",level:2},{value:"Rule 1: Exclusive Mutable Access",id:"rule-1-exclusive-mutable-access",level:3},{value:"Rule 2: References Cannot Outlive Their Data",id:"rule-2-references-cannot-outlive-their-data",level:3},{value:"Rule 3: Reference Restrictions in Structs",id:"rule-3-reference-restrictions-in-structs",level:3},{value:"Global Storage Borrowing",id:"global-storage-borrowing",level:2},{value:"Borrowing Patterns and Best Practices",id:"borrowing-patterns-and-best-practices",level:2},{value:"The Read-Then-Write Pattern",id:"the-read-then-write-pattern",level:3},{value:"The Helper Function Pattern",id:"the-helper-function-pattern",level:3},{value:"The Field Extraction Pattern",id:"the-field-extraction-pattern",level:3},{value:"Common Pitfalls and Solutions",id:"common-pitfalls-and-solutions",level:2},{value:"Attempting to Return References",id:"attempting-to-return-references",level:3},{value:"Conflicting Borrows",id:"conflicting-borrows",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"What&#39;s Next?",id:"whats-next",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"move-ownership-and-borrowing",children:"Move Ownership and Borrowing"})}),"\n",(0,o.jsx)(n.p,{children:"In Move, every value has exactly one owner at any given time. When you create a value, you own it. When you pass it to a function or assign it to another variable, ownership transfers. This isn't just a convention \u2013 it's enforced by the compiler."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct Token has store {\n    amount: u64\n}\n\npublic fun demonstrate_ownership() {\n    let token = Token { amount: 100 };  // 'token' owns the Token\n    let my_token = token;               // Ownership moves to 'my_token'\n    // Can't use 'token' anymore - it no longer owns anything\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["After the assignment ",(0,o.jsx)(n.code,{children:"my_token = token"}),", the original ",(0,o.jsx)(n.code,{children:"token"})," variable is no longer valid. This isn't a copy \u2013 it's a move. The Token resource physically moves from one owner to another. If you try to use ",(0,o.jsx)(n.code,{children:"token"}),' after the move, the compiler will stop you with an error like "use of moved value".']}),"\n",(0,o.jsx)(n.p,{children:"This ownership model solves a fundamental problem in resource management: how do you ensure a resource exists in exactly one place? By making ownership exclusive and transfers explicit, Move eliminates entire categories of bugs like double-spending or resource leaks."}),"\n",(0,o.jsx)(n.h2,{id:"references-borrowing-without-taking",children:"References: Borrowing Without Taking"}),"\n",(0,o.jsx)(n.p,{children:"While ownership transfer is powerful, sometimes you need to access data without taking ownership. This is where references come in. References let you borrow access to a value without becoming its owner."}),"\n",(0,o.jsx)(n.h3,{id:"immutable-references-t",children:"Immutable References (&T)"}),"\n",(0,o.jsx)(n.p,{children:"An immutable reference gives you read-only access to a value. You can look but not touch:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct Account has key {\n    balance: u64,\n    locked: bool\n}\n\npublic fun check_account_status(account: &Account): (u64, bool) {\n    (account.balance, account.locked)\n}\n\npublic fun is_account_valid(account: &Account): bool {\n    account.balance >= 100 && !account.locked\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"&Account"})," parameter type means the function borrows the account for reading. The function can access all fields of the account but cannot modify them. When the function returns, the borrow ends and the original owner still has their account."]}),"\n",(0,o.jsx)(n.p,{children:"Multiple functions can hold immutable references to the same value simultaneously. This is safe because no one can modify the data \u2013 there's no risk of one function seeing inconsistent state caused by another."}),"\n",(0,o.jsx)(n.h3,{id:"creating-references",children:"Creating References"}),"\n",(0,o.jsxs)(n.p,{children:["You create references using the ",(0,o.jsx)(n.code,{children:"&"})," operator:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"public fun reference_examples() {\n    let account = Account { balance: 1000, locked: false };\n    \n    let balance_ref = &account.balance;     // Reference to a field\n    let account_ref = &account;             // Reference to the whole struct\n    \n    let balance_copy = *balance_ref;        // Dereference to get the value\n    let is_valid = check_validity(account_ref);\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"&"})," operator creates a reference without transferring ownership. The original ",(0,o.jsx)(n.code,{children:"account"})," variable remains valid and owns the Account. References are lightweight \u2013 they're just pointers to the original data, not copies."]}),"\n",(0,o.jsxs)(n.p,{children:["To get the value from a reference, you use the dereference operator ",(0,o.jsx)(n.code,{children:"*"}),". However, Move often does this automatically for field access, so ",(0,o.jsx)(n.code,{children:"account_ref.balance"})," works without explicit dereferencing."]}),"\n",(0,o.jsx)(n.h3,{id:"mutable-references-mut-t",children:"Mutable References (&mut T)"}),"\n",(0,o.jsx)(n.p,{children:"Mutable references allow you to modify borrowed values:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"public fun deposit(account: &mut Account, amount: u64) {\n    account.balance = account.balance + amount;\n}\n\npublic fun lock_account(account: &mut Account) {\n    account.locked = true;\n}\n\npublic fun process_transaction(account: &mut Account, amount: u64) {\n    assert!(!account.locked, ERROR_ACCOUNT_LOCKED);\n    assert!(account.balance >= amount, ERROR_INSUFFICIENT_FUNDS);\n    \n    account.balance = account.balance - amount;\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"&mut Account"})," parameter type creates a mutable borrow. The function can read and modify the account. Changes made through the reference affect the original value \u2013 there's no copying involved."]}),"\n",(0,o.jsx)(n.p,{children:"Mutable references are exclusive. While a mutable reference exists, no other references (mutable or immutable) can exist to the same value. This exclusivity prevents data races and ensures consistency."}),"\n",(0,o.jsx)(n.h2,{id:"borrowing-rules-safety-through-restrictions",children:"Borrowing Rules: Safety Through Restrictions"}),"\n",(0,o.jsx)(n.p,{children:"Move enforces strict rules about references to ensure memory safety and prevent data races. These rules are checked at compile time \u2013 if your code compiles, it's safe."}),"\n",(0,o.jsx)(n.h3,{id:"rule-1-exclusive-mutable-access",children:"Rule 1: Exclusive Mutable Access"}),"\n",(0,o.jsx)(n.p,{children:"You can have either one mutable reference OR any number of immutable references, never both:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"public fun invalid_borrows() {\n    let mut account = Account { balance: 1000, locked: false };\n    \n    let ref1 = &account;           // OK: First immutable reference\n    let ref2 = &account;           // OK: Multiple immutable references\n    \n    let mut_ref = &mut account;    // ERROR: Can't create mutable while immutable exist\n}\n\npublic fun valid_borrows() {\n    let mut account = Account { balance: 1000, locked: false };\n    \n    let balance = {\n        let account_ref = &account;\n        account_ref.balance         // Immutable borrow ends here\n    };\n    \n    let mut_ref = &mut account;    // OK: No other references exist\n    mut_ref.balance = 2000;\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"This rule prevents confusion about what value a reference sees. If both mutable and immutable references existed simultaneously, immutable references might see values change unexpectedly, breaking assumptions and causing bugs."}),"\n",(0,o.jsx)(n.h3,{id:"rule-2-references-cannot-outlive-their-data",children:"Rule 2: References Cannot Outlive Their Data"}),"\n",(0,o.jsx)(n.p,{children:"References must not exist longer than the values they reference:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct Container has drop {\n    value: u64\n}\n\n// This won't compile\npublic fun invalid_lifetime(): &u64 {\n    let container = Container { value: 42 };\n    &container.value  // ERROR: Reference would outlive container\n}\n\n// This is valid\npublic fun valid_lifetime(container: &Container): &u64 {\n    &container.value  // OK: Reference lifetime tied to parameter\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This rule prevents dangling references \u2013 pointers to memory that has been freed. In the invalid example, ",(0,o.jsx)(n.code,{children:"container"})," would be dropped at the end of the function, but we're trying to return a reference to its field. The compiler catches this and prevents undefined behavior."]}),"\n",(0,o.jsx)(n.h3,{id:"rule-3-reference-restrictions-in-structs",children:"Rule 3: Reference Restrictions in Structs"}),"\n",(0,o.jsx)(n.p,{children:"Structs can only store references if they will never be stored themselves:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"// This won't compile\nstruct Invalid has store {\n    reference: &u64  // ERROR: Can't store references in storable structs\n}\n\n// This is valid during execution but can't be stored\nstruct Temporary {\n    reference: &u64  // OK: Struct has no abilities\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This restriction ensures that references don't escape their intended lifetime. Since structs with ",(0,o.jsx)(n.code,{children:"store"})," or ",(0,o.jsx)(n.code,{children:"key"})," abilities can be saved to global storage or put in containers, allowing them to contain references would violate lifetime rules."]}),"\n",(0,o.jsxs)(n.admonition,{title:"Reference Safety",type:"warning",children:[(0,o.jsx)(n.p,{children:"Move's reference rules might seem restrictive, but they eliminate entire categories of bugs:"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"No null pointer dereferences"}),"\n",(0,o.jsx)(n.li,{children:"No use-after-free errors"}),"\n",(0,o.jsx)(n.li,{children:"No data races"}),"\n",(0,o.jsx)(n.li,{children:"No dangling references"}),"\n"]}),(0,o.jsx)(n.p,{children:"These guarantees come at compile time with zero runtime cost!"})]}),"\n",(0,o.jsx)(n.h2,{id:"global-storage-borrowing",children:"Global Storage Borrowing"}),"\n",(0,o.jsx)(n.p,{children:"Move provides special functions for borrowing from global storage, where resources live at addresses:"}),"\n",(0,o.jsxs)(n.admonition,{title:"See It in Practice",type:"tip",children:[(0,o.jsx)(n.p,{children:"Our guides use global storage extensively:"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/guides/first-fa#211-init_module---bootstrap",children:"FA Token Storage"})," - How tokens are stored using ",(0,o.jsx)(n.code,{children:"move_to"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/guides/escrow#step-1-creating-a-lockup",children:"Escrow Lockup Management"})," - Complex borrowing patterns with ",(0,o.jsx)(n.code,{children:"borrow_global_mut"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.a,{href:"/guides/first-nft#63-get-collection-metadata",children:"NFT Collection Access"})," - Safe reading with ",(0,o.jsx)(n.code,{children:"borrow_global"})]}),"\n"]})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct Vault has key {\n    coins: u64,\n    admin: address\n}\n\npublic fun read_vault(vault_address: address): u64 acquires Vault {\n    let vault = borrow_global<Vault>(vault_address);\n    vault.coins\n}\n\npublic fun add_to_vault(vault_address: address, amount: u64) acquires Vault {\n    let vault = borrow_global_mut<Vault>(vault_address);\n    vault.coins = vault.coins + amount;\n}\n\npublic fun complex_vault_operation(\n    vault_address: address,\n    new_admin: address\n) acquires Vault {\n    let vault = borrow_global_mut<Vault>(vault_address);\n    \n    // Multiple operations on the same borrow\n    assert!(vault.admin == @admin, ERROR_NOT_ADMIN);\n    vault.admin = new_admin;\n    vault.coins = vault.coins + 100; // Admin change bonus\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"borrow_global<T>"})," function returns an immutable reference to the T resource stored at the given address. Similarly, ",(0,o.jsx)(n.code,{children:"borrow_global_mut<T>"})," returns a mutable reference. These borrows last for the current function scope."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"acquires"})," annotation is crucial here. It tells Move which resources this function might access from global storage. This information helps prevent reentrancy and makes resource access explicit. If you forget the ",(0,o.jsx)(n.code,{children:"acquires"})," annotation, the compiler will remind you."]}),"\n",(0,o.jsx)(n.h2,{id:"borrowing-patterns-and-best-practices",children:"Borrowing Patterns and Best Practices"}),"\n",(0,o.jsx)(n.p,{children:"Understanding common patterns helps you write efficient, safe code that makes the most of Move's borrowing system. Structure your code to minimize borrow conflicts:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"public fun update_multiple_fields(account: &mut Account, new_balance: u64) {\n    // Don't do this - multiple borrows of same struct\n    let balance_ref = &mut account.balance;\n    let locked_ref = &mut account.locked;\n    \n    // Do this - single borrow, multiple updates\n    account.balance = new_balance;\n    account.locked = new_balance < 100;\n}\n\npublic fun process_accounts(account1: &mut Account, account2: &mut Account) {\n    // Can borrow multiple different values mutably\n    account1.balance = account1.balance - 100;\n    account2.balance = account2.balance + 100;\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Instead of creating multiple references to fields of the same struct, use a single reference to the struct and access fields through it. This avoids borrow checker conflicts and is often more efficient."}),"\n",(0,o.jsx)(n.h3,{id:"the-read-then-write-pattern",children:"The Read-Then-Write Pattern"}),"\n",(0,o.jsx)(n.p,{children:"When you need to read a value before modifying it, structure the borrows carefully:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"public fun double_if_greater(\n    account: &mut Account,\n    threshold: u64\n) {\n    let should_double = {\n        let balance = &account.balance;  // Immutable borrow\n        *balance > threshold\n    };  // Immutable borrow ends here\n    \n    if (should_double) {\n        account.balance = account.balance * 2;  // Mutable borrow\n    }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"By using a block expression, we limit the scope of the immutable borrow. Once the block ends, we can create a mutable borrow. This pattern is useful when you need to make decisions based on current state before modifying it."}),"\n",(0,o.jsx)(n.h3,{id:"the-helper-function-pattern",children:"The Helper Function Pattern"}),"\n",(0,o.jsx)(n.p,{children:"Break complex operations into smaller functions that take references:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"fun validate_transfer(from: &Account, to: &Account, amount: u64) {\n    assert!(!from.locked, ERROR_SENDER_LOCKED);\n    assert!(!to.locked, ERROR_RECIPIENT_LOCKED);\n    assert!(from.balance >= amount, ERROR_INSUFFICIENT_FUNDS);\n}\n\nfun execute_transfer(from: &mut Account, to: &mut Account, amount: u64) {\n    from.balance = from.balance - amount;\n    to.balance = to.balance + amount;\n}\n\npublic fun safe_transfer(\n    from: &mut Account,\n    to: &mut Account,\n    amount: u64\n) {\n    // First validate with immutable borrows\n    validate_transfer(from, to, amount);\n    \n    // Then execute with mutable borrows\n    execute_transfer(from, to, amount);\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"This pattern separates validation (needs only immutable references) from mutation (needs mutable references). It makes code more modular and easier to test."}),"\n",(0,o.jsx)(n.h3,{id:"the-field-extraction-pattern",children:"The Field Extraction Pattern"}),"\n",(0,o.jsx)(n.p,{children:"Sometimes it's cleaner to extract fields rather than passing references:"}),"\n",(0,o.jsx)(n.admonition,{title:"Pattern Usage",type:"info",children:(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.a,{href:"/guides/fee-splitter#35-distribute-fees",children:"Fee Splitter"})," shows this pattern when iterating through recipients - it extracts values from the struct rather than passing multiple references around."]})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"struct ComplexData has drop {\n    values: vector<u64>,\n    metadata: vector<u8>\n}\n\n// Instead of passing references to internal fields\nfun process_with_refs(values: &vector<u64>, metadata: &vector<u8>) {\n    // Process...\n}\n\n// Consider extracting if ownership allows\nfun process_with_values(data: ComplexData) {\n    let ComplexData { values, metadata } = data;\n    // Now you own values and metadata directly\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"If you're going to consume the data anyway, taking ownership and destructuring can be cleaner than managing multiple references."}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"\ud83d\udcd8 Advanced Borrowing Patterns"}),(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Conditional Borrowing"}),": Borrow only when needed"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"public fun maybe_update(account: &mut Account, should_update: bool, amount: u64) {\n    if (should_update) {\n        account.balance = account.balance + amount;\n    }\n    // No borrow conflict when should_update is false\n}\n"})}),(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Scoped Borrowing"}),": Use blocks to limit borrow scope"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"public fun complex_operation(account: &mut Account) {\n    let old_balance = account.balance;\n    \n    {\n        let temp_ref = &account.locked;\n        // Use temp_ref here\n    }  // Borrow ends\n    \n    account.balance = calculate_new_balance(old_balance);\n}\n"})})]}),"\n",(0,o.jsx)(n.h2,{id:"common-pitfalls-and-solutions",children:"Common Pitfalls and Solutions"}),"\n",(0,o.jsx)(n.h3,{id:"attempting-to-return-references",children:"Attempting to Return References"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"// \u274c Wrong - trying to return a reference\npublic fun get_balance_ref(addr: address): &u64 acquires Account {\n    let account = borrow_global<Account>(addr);\n    &account.balance  // ERROR: Reference would outlive borrow\n}\n\n// \u2705 Correct - return the value\npublic fun get_balance(addr: address): u64 acquires Account {\n    let account = borrow_global<Account>(addr);\n    account.balance  // Copy the value\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"References cannot escape the function where they're created. If you need to return data, return a copy of the value, not a reference to it."}),"\n",(0,o.jsx)(n.h3,{id:"conflicting-borrows",children:"Conflicting Borrows"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"// \u274c Wrong - conflicting borrows\npublic fun transfer_bad(from: &mut Account, to: &mut Account, amount: u64) {\n    let from_ref = &from.balance;  // Immutable borrow of from\n    to.balance = to.balance + amount;\n    \n    if (*from_ref >= amount) {  // Still using immutable borrow\n        from.balance = from.balance - amount;  // ERROR: Can't mutably borrow\n    }\n}\n\n// \u2705 Correct - complete operations sequentially  \npublic fun transfer_good(from: &mut Account, to: &mut Account, amount: u64) {\n    assert!(from.balance >= amount, ERROR_INSUFFICIENT_FUNDS);\n    from.balance = from.balance - amount;\n    to.balance = to.balance + amount;\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Avoid creating references that you'll need to violate later. Structure your code to complete operations with one type of borrow before needing another."}),"\n",(0,o.jsxs)(n.admonition,{title:"Borrow Checker Wisdom",type:"tip",children:[(0,o.jsx)(n.p,{children:"When fighting the borrow checker, ask yourself:"}),(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Do I really need this reference, or can I copy the value?"}),"\n",(0,o.jsx)(n.li,{children:"Can I restructure to avoid overlapping borrows?"}),"\n",(0,o.jsx)(n.li,{children:"Would smaller functions with clearer borrowing patterns help?"}),"\n",(0,o.jsx)(n.li,{children:"Am I trying to do too much in one function?"}),"\n"]})]}),"\n",(0,o.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,o.jsx)(n.p,{children:"Move's ownership and borrowing system provides safety without sacrificing performance:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Single ownership"}),": Each value has exactly one owner"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Explicit transfers"}),": Ownership moves are visible in code"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Safe borrowing"}),": References allow access without ownership"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Compile-time safety"}),": No runtime overhead for these guarantees"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Clear patterns"}),": Consistent approaches to common scenarios"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The borrow checker might seem strict at first, but it's catching real bugs. Every error it reports represents a potential runtime failure in other languages."}),"\n",(0,o.jsx)(n.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,o.jsxs)(n.p,{children:["In our next article, ",(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.a,{href:"/move/flow",children:"Conditionals, Loops, and Control Flow"})}),", we'll explore how to control program execution in Move. You'll learn about if expressions, loops, pattern matching, and how to write efficient control flow while maintaining resource safety."]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var r=t(6540);const o={},a=r.createContext(o);function s(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);