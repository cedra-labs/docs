"use strict";(self.webpackChunkcedra_docs=self.webpackChunkcedra_docs||[]).push([[6492],{6224:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>u});const i=JSON.parse('{"id":"concepts/accounts/authentication","title":"Account Authentication","description":"Authentication on Cedra is more flexible than most blockchains. The separation between address and authentication key means you can rotate your keys without changing your account identity - similar to changing a password without creating a new username. Cedra also supports multiple cryptographic schemes and native multisig, all built into the protocol rather than implemented through smart contracts.","source":"@site/docs/concepts/accounts/authentication.md","sourceDirName":"concepts/accounts","slug":"/concepts/accounts/authentication","permalink":"/concepts/accounts/authentication","draft":false,"unlisted":false,"editUrl":"https://github.com/cedra-labs/docs/edit/main/docs/concepts/accounts/authentication.md","tags":[],"version":"current","frontMatter":{},"sidebar":"concepts","previous":{"title":"Understanding Accounts","permalink":"/concepts/accounts/understanding-accounts"},"next":{"title":"Resources","permalink":"/concepts/accounts/resources"}}');var s=n(4848),a=n(8453);const o={},r="Account Authentication",c={},u=[{value:"Authentication Key vs Address",id:"authentication-key-vs-address",level:3},{value:"Authentication Schemes",id:"authentication-schemes",level:2},{value:"Ed25519 (Default)",id:"ed25519-default",level:3},{value:"Secp256k1 ECDSA",id:"secp256k1-ecdsa",level:3},{value:"MultiEd25519 (K-of-N Multisig)",id:"multied25519-k-of-n-multisig",level:3},{value:"Native Multisig Support",id:"native-multisig-support",level:2},{value:"Key Rotation",id:"key-rotation",level:2},{value:"Next Steps",id:"next-steps",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"account-authentication",children:"Account Authentication"})}),"\n",(0,s.jsx)(t.p,{children:"Authentication on Cedra is more flexible than most blockchains. The separation between address and authentication key means you can rotate your keys without changing your account identity - similar to changing a password without creating a new username. Cedra also supports multiple cryptographic schemes and native multisig, all built into the protocol rather than implemented through smart contracts."}),"\n",(0,s.jsx)(t.admonition,{title:"Navigation",type:"tip",children:(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Previous:"})," ",(0,s.jsx)(t.a,{href:"/concepts/accounts/understanding-accounts",children:"Understanding Accounts"}),"\n",(0,s.jsx)(t.strong,{children:"You are here:"})," Authentication\n",(0,s.jsx)(t.strong,{children:"Next:"})," ",(0,s.jsx)(t.a,{href:"/concepts/accounts/resources",children:"Resources"})]})}),"\n",(0,s.jsx)(t.h3,{id:"authentication-key-vs-address",children:"Authentication Key vs Address"}),"\n",(0,s.jsx)(t.p,{children:"When you first create an account, your authentication key becomes your address. But here's the key insight: while the address is permanent, the authentication key can change."}),"\n",(0,s.jsx)(t.p,{children:"The authentication key is what proves you own the account - it's derived from your public key and verified when you sign transactions. If your private key is compromised or you simply want better security, you can rotate to a new authentication key while keeping your existing address, balances, and resources."}),"\n",(0,s.jsx)(t.mermaid,{value:'graph LR\n    subgraph "Initial State"\n        A[Auth Key] --\x3e|equals| B[Address]\n    end\n\n    subgraph "After Rotation"\n        C[New Auth Key] --\x3e|authenticates| D[Same Address]\n    end\n\n    B --\x3e D'}),"\n",(0,s.jsx)(t.p,{children:"The network maintains an on-chain mapping that tracks these rotations, so it knows which authentication key currently controls each address."}),"\n",(0,s.jsx)(t.h2,{id:"authentication-schemes",children:"Authentication Schemes"}),"\n",(0,s.jsx)(t.p,{children:"Cedra supports multiple cryptographic schemes for signing transactions. Each scheme uses a different algorithm to derive the authentication key from the public key."}),"\n",(0,s.jsx)(t.h3,{id:"ed25519-default",children:"Ed25519 (Default)"}),"\n",(0,s.jsx)(t.p,{children:"The most common choice, using the Ed25519 elliptic curve. The authentication key is computed as:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"auth_key = sha3-256(public_key | 0x00)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"0x00"})," suffix is the scheme identifier that distinguishes Ed25519 from other schemes. Ed25519 offers fast signature verification and is well-suited for most use cases."]}),"\n",(0,s.jsx)(t.h3,{id:"secp256k1-ecdsa",children:"Secp256k1 ECDSA"}),"\n",(0,s.jsx)(t.p,{children:"The same curve used by Bitcoin and Ethereum. If you're migrating from those ecosystems or want compatibility with existing tooling, Secp256k1 is available:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"auth_key = sha3-256(0x01 | public_key | 0x02)\n"})}),"\n",(0,s.jsx)(t.h3,{id:"multied25519-k-of-n-multisig",children:"MultiEd25519 (K-of-N Multisig)"}),"\n",(0,s.jsx)(t.p,{children:"For accounts requiring multiple signatures, Cedra supports K-of-N multisig natively. You specify N public keys and require K of them to sign any transaction:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"auth_key = sha3-256(pubkey_1 | pubkey_2 | ... | pubkey_n | K | 0x01)\n"})}),"\n",(0,s.jsx)(t.p,{children:"For example, a 2-of-3 multisig would have three public keys concatenated, followed by the threshold value 2, then the scheme identifier."}),"\n",(0,s.jsx)(t.h2,{id:"native-multisig-support",children:"Native Multisig Support"}),"\n",(0,s.jsx)(t.p,{children:"Unlike Ethereum where multisig requires deploying a smart contract, Cedra's multisig is built into the protocol. This means:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Lower gas costs"})," - No contract deployment or extra execution overhead"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Simpler setup"})," - Just combine public keys and set a threshold"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Mixed key types"})," - Combine Ed25519, Secp256k1, WebAuthn in one multisig"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"No contract risk"})," - No smart contract bugs to worry about"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"A transaction from a multisig account includes multiple signatures. The network verifies that at least K of the N authorized keys have signed before accepting the transaction."}),"\n",(0,s.jsx)(t.mermaid,{value:'graph TD\n    subgraph "2-of-3 Multisig"\n        A[Transaction] --\x3e B{Collect Signatures}\n        B --\x3e C[Signer 1: Ed25519]\n        B --\x3e D[Signer 2: Secp256k1]\n        B --\x3e E[Signer 3: Ed25519]\n        C --\x3e F{K signatures?}\n        D --\x3e F\n        F --\x3e|Yes, 2 of 3| G[Valid Transaction]\n    end'}),"\n",(0,s.jsx)(t.h2,{id:"key-rotation",children:"Key Rotation"}),"\n",(0,s.jsx)(t.p,{children:"Key rotation lets you change the authentication key controlling your account while keeping the same address. This is essential for:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Compromised keys"})," - If you suspect your private key was exposed, rotate immediately"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Security upgrades"})," - Move from a single key to multisig, or upgrade to a hardware wallet"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Organizational changes"})," - When team members change, rotate the controlling keys"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["The rotation process uses the ",(0,s.jsx)(t.code,{children:"account::rotate_authentication_key"})," function. You sign the rotation request with your current key to prove ownership, and specify the new authentication key that should take over."]}),"\n",(0,s.jsx)(t.mermaid,{value:"sequenceDiagram\n    participant Owner\n    participant Account\n    participant Network\n\n    Owner->>Account: Sign rotation with current key\n    Owner->>Account: Specify new auth key\n    Account->>Network: Submit rotation transaction\n    Network->>Network: Verify current key signature\n    Network->>Network: Update auth key mapping\n    Network->>Owner: Confirmation\n    Note over Owner,Network: Old key no longer works<br/>New key now controls account"}),"\n",(0,s.jsx)(t.p,{children:"After rotation, the old key can no longer sign transactions for this account. The address remains unchanged, so all your resources, module references, and history stay intact."}),"\n",(0,s.jsx)(t.admonition,{title:"Rotation Tracking",type:"info",children:(0,s.jsxs)(t.p,{children:["The network maintains an on-chain ",(0,s.jsx)(t.code,{children:"OriginatingAddress"})," table that maps authentication keys to their original addresses. This ensures that even after multiple rotations, the account's identity remains consistent."]})}),"\n",(0,s.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"/concepts/accounts/resources",children:"Resources"})," - How Move resources are stored within accounts"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"/concepts/accounts/understanding-accounts",children:"Understanding Accounts"})," - Account fundamentals"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"/concepts/transactions/understanding-transactions",children:"Transactions"})," - How authenticated accounts interact with the network"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var i=n(6540);const s={},a=i.createContext(s);function o(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);