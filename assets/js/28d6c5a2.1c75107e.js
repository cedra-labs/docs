"use strict";(self.webpackChunkcedra_docs=self.webpackChunkcedra_docs||[]).push([[9894],{3169:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"move/testing","title":"Move Unit Testing","description":"Unit testing is essential for Move smart contracts where bugs can lead to significant financial losses. Move provides three test annotations that are excluded from compiled bytecode unless compiled for testing.","source":"@site/docs/move/testing.md","sourceDirName":"move","slug":"/move/testing","permalink":"/move/testing","draft":false,"unlisted":false,"editUrl":"https://github.com/cedra-labs/docs/edit/main/docs/move/testing.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"\ud83d\ude80 Deploying Large Packages","permalink":"/large-packages"},"next":{"title":"Move Programming Language","permalink":"/move/"}}');var i=s(4848),o=s(8453);const r={},a="Move Unit Testing",c={},l=[{value:"Testing Expected Failures",id:"testing-expected-failures",level:2},{value:"Working with Signers",id:"working-with-signers",level:2},{value:"Running Tests",id:"running-tests",level:2},{value:"Complete Example",id:"complete-example",level:2},{value:"Organizing Your Tests",id:"organizing-your-tests",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"move-unit-testing",children:"Move Unit Testing"})}),"\n",(0,i.jsx)(n.p,{children:"Unit testing is essential for Move smart contracts where bugs can lead to significant financial losses. Move provides three test annotations that are excluded from compiled bytecode unless compiled for testing."}),"\n",(0,i.jsxs)(n.admonition,{title:"Prerequisites",type:"tip",children:[(0,i.jsx)(n.p,{children:"Before writing tests, ensure you have:"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.a,{href:"/getting-started/cli",children:"Cedra CLI installed"})]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.a,{href:"/move/basics",children:"Basic Move knowledge"})]}),"\n",(0,i.jsxs)(n.li,{children:["\u2705 ",(0,i.jsx)(n.a,{href:"/move/modules",children:"Understanding of modules"})]}),"\n"]})]}),"\n",(0,i.jsxs)(n.p,{children:["The simplest way to create a test is with the ",(0,i.jsx)(n.code,{children:"#[test]"})," annotation. Any function marked with this attribute becomes a test case that runs when you execute ",(0,i.jsx)(n.code,{children:"cedra move test"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"module 0x42::example {\n    #[test]\n    fun this_is_a_test() {\n        // Test logic here\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Often you'll need code that only exists for testing purposes - helper functions, mock data structures, or debug imports. The ",(0,i.jsx)(n.code,{children:"#[test_only]"})," annotation marks code that should be excluded from production bytecode. You can apply it to entire modules, individual functions, structs, or even use statements:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[test_only]\nmodule 0x42::test_helpers {\n    // This entire module only exists during testing\n}\n\nmodule 0x42::my_module {\n    #[test_only]\n    use std::debug;\n\n    #[test_only]\n    struct TestStruct { value: u64 }\n\n    #[test_only]\n    fun helper_function(): u64 { 42 }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"testing-expected-failures",children:"Testing Expected Failures"}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes you need to verify that your code fails correctly. The ",(0,i.jsx)(n.code,{children:"#[expected_failure]"})," annotation lets you test that a function aborts under specific conditions:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[test]\n#[expected_failure(abort_code = 0, location = Self)]\nfun test_zero_coin_fails() {\n    let coin = MyCoin { value: 0 };\n    make_sure_non_zero_coin(coin);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This test passes only if the function aborts with code ",(0,i.jsx)(n.code,{children:"0"})," from the current module (",(0,i.jsx)(n.code,{children:"Self"}),"). You can also test for failures from other modules using ",(0,i.jsx)(n.code,{children:"location = other::module"}),", or test for specific error types like ",(0,i.jsx)(n.code,{children:"arithmetic_error"})," for overflow/underflow, ",(0,i.jsx)(n.code,{children:"vector_error"})," with ",(0,i.jsx)(n.code,{children:"minor_status = 1"})," for index out of bounds, or ",(0,i.jsx)(n.code,{children:"out_of_gas"})," for gas exhaustion."]}),"\n",(0,i.jsx)(n.h2,{id:"working-with-signers",children:"Working with Signers"}),"\n",(0,i.jsxs)(n.p,{children:["Most Move functions that modify state require a ",(0,i.jsx)(n.code,{children:"signer"})," argument. You can inject test signers directly in the test annotation:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[test(a = @0x1, b = @0x2)]\nfun test_with_signers(a: signer, b: signer) {\n    publish_coin(&a);\n    assert!(has_coin(@0x1), 0);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The annotation creates signer values for each specified address, which are then passed to the test function as arguments. Named addresses from your ",(0,i.jsx)(n.code,{children:"Move.toml"})," work too:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[test(admin = @admin)]\nfun test_admin_only(admin: signer) {\n    // admin signer is bound to the 'admin' named address\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"running-tests",children:"Running Tests"}),"\n",(0,i.jsx)(n.p,{children:"Run all tests in your package with:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cedra move test\n"})}),"\n",(0,i.jsx)(n.p,{children:"You'll see output showing which tests passed or failed:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Running Move unit tests\n[ PASS    ] 0x42::my_module::make_sure_non_zero_coin_passes\n[ PASS    ] 0x42::my_module::make_sure_zero_coin_fails\n[ PASS    ] 0x42::my_module::test_has_coin\nTest result: OK. Total tests: 3; passed: 3; failed: 0\n"})}),"\n",(0,i.jsx)(n.p,{children:'To run only specific tests, use the filter flag. This runs any test containing "zero_coin" in its name:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cedra move test -f zero_coin\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For code coverage information, add the ",(0,i.jsx)(n.code,{children:"--coverage"})," flag and then run ",(0,i.jsx)(n.code,{children:"cedra move coverage"})," for a detailed breakdown. Other useful flags include ",(0,i.jsx)(n.code,{children:"--gas-limit"})," to set gas limits per test and ",(0,i.jsx)(n.code,{children:"-v"})," for verbose output."]}),"\n",(0,i.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,i.jsx)(n.p,{children:"Here's a full module demonstrating all the testing concepts together:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"module 0x1::my_module {\n    struct MyCoin has key { value: u64 }\n\n    const E_ZERO_COIN: u64 = 0;\n\n    public fun make_sure_non_zero_coin(coin: MyCoin): MyCoin {\n        assert!(coin.value > 0, E_ZERO_COIN);\n        coin\n    }\n\n    public fun has_coin(addr: address): bool {\n        exists<MyCoin>(addr)\n    }\n\n    // ========== Tests ==========\n\n    #[test]\n    fun make_sure_non_zero_coin_passes() {\n        let coin = MyCoin { value: 1 };\n        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = E_ZERO_COIN, location = Self)]\n    fun make_sure_zero_coin_fails() {\n        let coin = MyCoin { value: 0 };\n        let MyCoin { value: _ } = make_sure_non_zero_coin(coin);\n    }\n\n    #[test_only]\n    fun publish_coin(account: &signer) {\n        move_to(account, MyCoin { value: 1 })\n    }\n\n    #[test(a = @0x1, b = @0x2)]\n    fun test_has_coin(a: signer, b: signer) {\n        publish_coin(&a);\n        publish_coin(&b);\n        assert!(has_coin(@0x1), 0);\n        assert!(has_coin(@0x2), 1);\n        assert!(!has_coin(@0x3), 1);\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"organizing-your-tests",children:"Organizing Your Tests"}),"\n",(0,i.jsxs)(n.p,{children:["Tests can live in the same file as your production code (convenient for small modules) or in a separate ",(0,i.jsx)(n.code,{children:"tests/"})," directory (better for larger projects):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"my_project/\n\u251c\u2500\u2500 Move.toml\n\u251c\u2500\u2500 sources/\n\u2502   \u2514\u2500\u2500 my_module.move      # Can include inline tests\n\u2514\u2500\u2500 tests/\n    \u2514\u2500\u2500 my_module_tests.move  # Or separate test files\n"})}),"\n",(0,i.jsxs)(n.p,{children:["For naming, use ",(0,i.jsx)(n.code,{children:"test_"})," prefix for test functions (like ",(0,i.jsx)(n.code,{children:"test_increment"}),"), add ",(0,i.jsx)(n.code,{children:"_fails"})," suffix for expected failures (like ",(0,i.jsx)(n.code,{children:"test_zero_balance_fails"}),"), and name test files as ",(0,i.jsx)(n.code,{children:"<module>_tests.move"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.p,{children:["Structure your tests using the ",(0,i.jsx)(n.strong,{children:"Arrange \u2192 Act \u2192 Assert"})," pattern. First set up the test state, then perform the action you're testing, and finally verify the results:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[test(account = @0x1)]\nfun test_counter_increment(account: signer) {\n    // Arrange\n    initialize(&account);\n\n    // Act\n    increment(&account);\n    increment(&account);\n\n    // Assert\n    assert!(get_count(@0x1) == 2, 0);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Each test should focus on one behavior. When a test fails, you want to know exactly what broke. Instead of a single ",(0,i.jsx)(n.code,{children:"test_everything"})," function, write separate tests like ",(0,i.jsx)(n.code,{children:"test_increment_from_zero"})," and ",(0,i.jsx)(n.code,{children:"test_increment_from_nonzero"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Tests should be independent - each one sets up its own state rather than relying on side effects from other tests. This makes tests reliable and order-independent."}),"\n",(0,i.jsxs)(n.p,{children:["Cover all paths through your code: the happy path where everything works, error cases where things fail correctly, and edge cases like zero values or maximum limits. Use descriptive names that explain both what's being tested and what should happen, like ",(0,i.jsx)(n.code,{children:"test_transfer_insufficient_balance_fails"})," or ",(0,i.jsx)(n.code,{children:"test_mint_updates_total_supply"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Finally, keep test setup DRY by extracting common setup logic into ",(0,i.jsx)(n.code,{children:"#[test_only]"})," helper functions that multiple tests can share."]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/move/errors",children:"Error Handling"})," - Define and test abort codes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/getting-started/counter",children:"Counter Tutorial"})," - Complete example with tests"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/cli/usage",children:"CLI Usage"})," - More testing commands"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var t=s(6540);const i={},o=t.createContext(i);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);