"use strict";(self.webpackChunkcedra_docs=self.webpackChunkcedra_docs||[]).push([[342],{7477:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"guides/dex/price-protection","title":"Adding Price Protection Mechanisms","description":"Price protection is crucial for DEX users to avoid unexpected losses from price movements and MEV attacks. This tutorial teaches you how to implement slippage tolerance and price impact limits to create a safer trading experience on Cedra.","source":"@site/docs/guides/dex/price-protection.md","sourceDirName":"guides/dex","slug":"/guides/dex/price-protection","permalink":"/guides/dex/price-protection","draft":false,"unlisted":false,"editUrl":"https://github.com/cedra-labs/docs/edit/main/docs/guides/dex/price-protection.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Building Your First Trading Pair","permalink":"/guides/dex/first-trading-pair"},"next":{"title":"Multi-hop Routing for Optimal Execution","permalink":"/guides/dex/multi-hop-routing"}}');var a=n(4848),s=n(8453);const r={},c="Adding Price Protection Mechanisms",l={},o=[{value:"What You&#39;ll Learn",id:"what-youll-learn",level:4},{value:"Price Impact vs Slippage: Key Differences",id:"price-impact-vs-slippage-key-differences",level:2},{value:"Understanding the Slippage Module",id:"understanding-the-slippage-module",level:2},{value:"Working with Basis Points",id:"working-with-basis-points",level:2},{value:"Calculating Price Impact",id:"calculating-price-impact",level:3},{value:"Real-World Calculation Example",id:"real-world-calculation-example",level:4},{value:"Implementing Slippage Protection",id:"implementing-slippage-protection",level:2},{value:"Slippage Calculation Logic",id:"slippage-calculation-logic",level:3},{value:"Practical Example",id:"practical-example",level:4},{value:"The Safe Swap Function",id:"the-safe-swap-function",level:2},{value:"Next Steps",id:"next-steps",level:2},{value:"Multi-hop Routing for Optimal Execution",id:"multi-hop-routing-for-optimal-execution",level:3},{value:"DEX Client Integration Guide",id:"dex-client-integration-guide",level:3}];function p(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"adding-price-protection-mechanisms",children:"Adding Price Protection Mechanisms"})}),"\n",(0,a.jsx)(t.p,{children:"Price protection is crucial for DEX users to avoid unexpected losses from price movements and MEV attacks. This tutorial teaches you how to implement slippage tolerance and price impact limits to create a safer trading experience on Cedra."}),"\n",(0,a.jsx)(t.h4,{id:"what-youll-learn",children:"What You'll Learn"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Understanding price impact vs slippage"}),"\n",(0,a.jsx)(t.li,{children:"Calculating price movements in real-time"}),"\n",(0,a.jsx)(t.li,{children:"Implementing protection mechanisms"}),"\n",(0,a.jsx)(t.li,{children:"Best practices for user safety"}),"\n"]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"price-impact-vs-slippage-key-differences",children:"Price Impact vs Slippage: Key Differences"}),"\n",(0,a.jsx)(t.p,{children:"Price Impact is a difference between spot price and execution price due to trade size."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"Price Impact = (Execution Price - Spot Price) / Spot Price\n"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Example"}),":"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Pool: 1,000 ETH / 2,000,000 USDC (spot price: 2,000 USDC/ETH)"}),"\n",(0,a.jsx)(t.li,{children:"Trade: Buy 100 ETH"}),"\n",(0,a.jsx)(t.li,{children:"Execution price: ~2,227 USDC/ETH"}),"\n",(0,a.jsx)(t.li,{children:"Price impact: (2,227 - 2,000) / 2,000 = 11.35%"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Slippage the difference between expected and actual output due to other trades."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"Slippage = (Expected Output - Actual Output) / Expected Output\n"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Example"}),":"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Expected: 1,980 USDC for 1 ETH"}),"\n",(0,a.jsx)(t.li,{children:"Actual: 1,950 USDC (someone traded first)"}),"\n",(0,a.jsx)(t.li,{children:"Slippage: (1,980 - 1,950) / 1,980 = 1.52%"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"understanding-the-slippage-module",children:"Understanding the Slippage Module"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"const MAX_SLIPPAGE_BPS: u64 = 500;      // 5% maximum slippage\nconst MAX_PRICE_IMPACT_BPS: u64 = 300;  // 3% maximum price impact\n"})}),"\n",(0,a.jsx)(t.p,{children:"These constants protect users from:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Large price movements"}),": 3% max impact prevents manipulation"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Sandwich attacks"}),": 5% max slippage limits MEV profitability"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"working-with-basis-points",children:"Working with Basis Points"}),"\n",(0,a.jsx)(t.p,{children:"Financial systems avoid floating-point arithmetic due to precision errors that can compound over millions of transactions. Instead, we use basis points - a standard unit in finance that represents one hundredth of a percent. This approach gives us the precision needed for accurate calculations while using only integer math, making our contracts both efficient and deterministic."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"const MAX_SLIPPAGE_BPS: u64 = 500;      // 5% maximum slippage\nconst MAX_PRICE_IMPACT_BPS: u64 = 300;  // 3% maximum price impact\n"})}),"\n",(0,a.jsx)(t.p,{children:"Understanding basis points is crucial for DEX development. When a user sets 1% slippage tolerance, we represent this as 100 basis points. This granularity allows users to fine-tune their risk tolerance - someone might choose 50 basis points (0.5%) for stable pairs but 300 basis points (3%) for volatile tokens. The conversion is straightforward: multiply percentages by 100 to get basis points, or divide basis points by 100 to get percentages."}),"\n",(0,a.jsx)(t.admonition,{title:"Production Consideration",type:"warning",children:(0,a.jsx)(t.p,{children:"In production, consider making these limits configurable per pool. Stable pairs might use 10 bps limits while volatile pairs might need 1000 bps to function effectively."})}),"\n",(0,a.jsx)(t.h3,{id:"calculating-price-impact",children:"Calculating Price Impact"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"public fun calculate_price_impact(\n    amount_in: u64,\n    reserve_in: u64,\n    reserve_out: u64\n): u64\n"})}),"\n",(0,a.jsx)(t.admonition,{title:"View Source",type:"tip",children:(0,a.jsxs)(t.p,{children:["Full implementation: ",(0,a.jsx)(t.a,{href:"https://github.com/cedra-labs/move-contract-examples/blob/main/dex/sources/3-slippage.move#L25-L44",children:(0,a.jsx)(t.code,{children:"calculate_price_impact"})})]})}),"\n",(0,a.jsx)(t.p,{children:"Let's examine how price impact calculation works under the hood. This implementation compares the spot price (current pool ratio) with the execution price (actual price paid after the swap) to determine how much a trade moves the market. By calculating this in basis points, we avoid floating-point arithmetic while maintaining precision - critical for financial calculations on\nblockchain."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"// 1. Calculate actual output after fees\nlet amount_out = math_amm::get_amount_out(amount_in, reserve_in, reserve_out);\n\n// 2. Calculate spot price (current pool price)\n// Multiply by 10000 for basis point precision\nlet spot_price = (reserve_out as u128) * 10000u128 / (reserve_in as u128);\n\n// 3. Calculate execution price (what user pays)\nlet execution_price = (amount_in as u128) * 10000u128 / (amount_out as u128);\n\n// 4. Calculate price impact in basis points\nif (execution_price > spot_price) {\n    ((execution_price - spot_price) * 10000u128 / spot_price as u64)\n} else {\n    0  // No negative impact (favorable to user)\n}\n"})}),"\n",(0,a.jsx)(t.h4,{id:"real-world-calculation-example",children:"Real-World Calculation Example"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"// Pool: 1,000 ETH / 2,000,000 USDC\nlet reserve_eth = 1_000_000_000;    // 1,000 ETH (6 decimals)\nlet reserve_usdc = 2_000_000_000_000; // 2,000,000 USDC (6 decimals)\n\n// Trade: Buy 10 ETH\nlet eth_to_buy = 10_000_000; // 10 ETH\n\n// Step 1: Calculate USDC needed (amount_in)\nlet usdc_needed = math_amm::get_amount_in(eth_to_buy, reserve_usdc, reserve_eth);\n// Result: ~20,261 USDC\n\n// Step 2: Calculate price impact\nlet impact = calculate_price_impact(usdc_needed, reserve_usdc, reserve_eth);\n// Spot price: 2,000 USDC/ETH\n// Execution price: 2,026.1 USDC/ETH\n// Impact: 131 bps (1.31%)\n"})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"implementing-slippage-protection",children:"Implementing Slippage Protection"}),"\n",(0,a.jsx)(t.p,{children:"The slippage validation ensures users receive at least their minimum acceptable output, protecting against price movements between quote and execution. This calculation measures the percentage difference between what the user expected and what they actually received. If the difference exceeds the user's tolerance, the transaction reverts - preventing losses from front-running or sudden market movements."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"public fun validate_slippage(\n    expected_output: u64,\n    actual_output: u64,\n    max_slippage_bps: u64\n)\n"})}),"\n",(0,a.jsx)(t.p,{children:"This function ensures the actual output meets user expectations within tolerance."}),"\n",(0,a.jsx)(t.h3,{id:"slippage-calculation-logic",children:"Slippage Calculation Logic"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"let slippage = if (expected_output > actual_output) {\n    // Calculate percentage difference\n    ((expected_output - actual_output) as u128) * 10000u128 / (expected_output as u128)\n} else {\n    0u128  // Favorable slippage (user gets more)\n};\n\n// Verify within tolerance\nassert!((slippage as u64) <= max_slippage_bps, ERROR_SLIPPAGE_TOO_HIGH);\n"})}),"\n",(0,a.jsx)(t.admonition,{title:"View Source",type:"tip",children:(0,a.jsxs)(t.p,{children:["See validation logic: ",(0,a.jsx)(t.a,{href:"https://github.com/cedra-labs/move-contract-examples/blob/main/dex/sources/3-slippage.move#L49-L59",children:(0,a.jsx)(t.code,{children:"validate_slippage"})})]})}),"\n",(0,a.jsx)(t.h4,{id:"practical-example",children:"Practical Example"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"// User expects 1,980 USDC for 1 ETH\nlet expected = 1_980_000_000;  // 1,980 USDC\nlet actual = 1_950_000_000;    // 1,950 USDC (pool changed)\n\n// Calculate slippage\nlet slippage_bps = ((1_980 - 1_950) * 10000) / 1_980;\n// Result: 151 bps (1.51%)\n\n// Validate against user's tolerance (e.g., 2%)\nvalidate_slippage(expected, actual, 200); // 200 bps = 2%\n"})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"the-safe-swap-function",children:"The Safe Swap Function"}),"\n",(0,a.jsx)(t.p,{children:"The safe swap function combines all our protection mechanisms into a single, user-friendly entry point. It performs comprehensive checks before executing any trade: first validating that the price impact won't exceed safe limits, then ensuring the output meets the user's minimum requirements, and finally executing the swap only if all protections pass."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"public entry fun safe_swap(\n    user: &signer,\n    lp_metadata: Object<Metadata>,\n    x_metadata: Object<Metadata>,\n    y_metadata: Object<Metadata>,\n    amount_in: u64,\n    min_amount_out: u64,\n    max_slippage_bps: u64\n)\n\n// 1. Get current pool state\nlet (reserve_x, reserve_y) = swap::reserves(lp_metadata);\n\n// 2. Calculate and validate price impact\nlet price_impact = calculate_price_impact(amount_in, reserve_x, reserve_y);\nassert!(price_impact <= MAX_PRICE_IMPACT_BPS, ERROR_PRICE_IMPACT_TOO_HIGH);\n\n// 3. Calculate expected output\nlet expected_output = math_amm::get_amount_out(amount_in, reserve_x, reserve_y);\n\n// 4. Validate slippage tolerance\nvalidate_slippage(expected_output, min_amount_out, max_slippage_bps);\n\n// 5. Execute swap if all checks pass\nswap::swap_exact_input(\n    user, \n    lp_metadata,\n    x_metadata,\n    y_metadata,\n    amount_in, \n    min_amount_out\n);\n\n"})}),"\n",(0,a.jsx)(t.admonition,{title:"View Source",type:"tip",children:(0,a.jsxs)(t.p,{children:["Complete safe swap implementation: ",(0,a.jsx)(t.a,{href:"https://github.com/cedra-labs/move-contract-examples/blob/main/dex/sources/3-slippage.move#L61-L94",children:(0,a.jsx)(t.code,{children:"safe_swap"})})]})}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Price Impact Check"}),": Ensures trade won't move price too much"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Slippage Validation"}),": Confirms output meets user expectations"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Atomic Execution"}),": All checks pass or transaction reverts"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsx)(t.p,{children:"You've learned how to implement comprehensive price protection:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Price Impact Calculation"}),": Measure true cost of trades"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Slippage Protection"}),": Ensure users get expected outputs"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Safe Swap Function"}),": Combine all protections atomically"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"multi-hop-routing-for-optimal-execution",children:(0,a.jsx)(t.a,{href:"./multi-hop-routing",children:"Multi-hop Routing for Optimal Execution"})}),"\n",(0,a.jsx)(t.p,{children:"Build a router that finds the best path through multiple pools for optimal trade execution."}),"\n",(0,a.jsx)(t.h3,{id:"dex-client-integration-guide",children:(0,a.jsx)(t.a,{href:"./client-integration",children:"DEX Client Integration Guide"})}),"\n",(0,a.jsx)(t.p,{children:"Create a TypeScript/React frontend that interacts with your DEX smart contracts."})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>c});var i=n(6540);const a={},s=i.createContext(a);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);