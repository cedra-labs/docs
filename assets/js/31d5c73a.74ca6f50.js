"use strict";(self.webpackChunkcedra_docs=self.webpackChunkcedra_docs||[]).push([[576],{7697:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"guides/dex/first-trading-pair","title":"Building Your First Trading Pair on Cedra","description":"In this tutorial, you\'ll build and deploy your first trading pair using Cedra\'s DEX infrastructure. We\'ll create a liquidity pool, add initial liquidity, and execute your first swap - all while understanding the mechanics behind each operation.","source":"@site/docs/guides/dex/first-trading-pair.md","sourceDirName":"guides/dex","slug":"/guides/dex/first-trading-pair","permalink":"/guides/dex/first-trading-pair","draft":false,"unlisted":false,"editUrl":"https://github.com/cedra-labs/docs/edit/main/docs/guides/dex/first-trading-pair.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Understanding Automated Market Makers","permalink":"/guides/dex/understanding-amm"},"next":{"title":"Adding Price Protection Mechanisms","permalink":"/guides/dex/price-protection"}}');var r=i(4848),a=i(8453);const s={},d="Building Your First Trading Pair on Cedra",o={},l=[{value:"What You&#39;ll Learn",id:"what-youll-learn",level:3},{value:"What is a Trading Pair?",id:"what-is-a-trading-pair",level:2},{value:"Step 1: Creating a Trading Pair",id:"step-1-creating-a-trading-pair",level:3},{value:"Step 2: Adding Liquidity",id:"step-2-adding-liquidity",level:3},{value:"Step 3: Executing Swaps",id:"step-3-executing-swaps",level:3},{value:"Step 4: Monitoring Pool State",id:"step-4-monitoring-pool-state",level:3},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2},{value:"Adding Price Protection Mechanisms",id:"adding-price-protection-mechanisms",level:3},{value:"Multi-hop Routing for Optimal Execution",id:"multi-hop-routing-for-optimal-execution",level:3},{value:"DEX Client Integration Guide",id:"dex-client-integration-guide",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"building-your-first-trading-pair-on-cedra",children:"Building Your First Trading Pair on Cedra"})}),"\n",(0,r.jsx)(n.p,{children:"In this tutorial, you'll build and deploy your first trading pair using Cedra's DEX infrastructure. We'll create a liquidity pool, add initial liquidity, and execute your first swap - all while understanding the mechanics behind each operation."}),"\n",(0,r.jsx)(n.h3,{id:"what-youll-learn",children:"What You'll Learn"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"How to create a trading pair with LP tokens"}),"\n",(0,r.jsx)(n.li,{children:"Understanding liquidity provision mechanics"}),"\n",(0,r.jsx)(n.li,{children:"Executing token swaps with slippage protection"}),"\n",(0,r.jsx)(n.li,{children:"Managing pool reserves and ratios"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"what-is-a-trading-pair",children:"What is a Trading Pair?"}),"\n",(0,r.jsxs)(n.p,{children:["A trading pair isn't just a container for tokens - it's a sophisticated financial instrument that manages reserves, tracks ownership, and enables atomic operations. Each field in the ",(0,r.jsx)(n.code,{children:"TradingPair"})," struct serves a critical purpose in maintaining the integrity and functionality of the liquidity pool."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"struct TradingPair has key {\n    reserve_x: Object<FungibleStore>,    // Token A reserves\n    reserve_y: Object<FungibleStore>,    // Token B reserves\n    mint_ref: fungible_asset::MintRef,   // For creating LP tokens\n    burn_ref: fungible_asset::BurnRef,   // For burning LP tokens\n    extend_ref: ExtendRef,               // For managing the pair\n    reserve_x_ref: ExtendRef,            // For managing reserve X\n    reserve_y_ref: ExtendRef             // For managing reserve Y\n}\n"})}),"\n",(0,r.jsx)(n.admonition,{title:"Architecture Decision",type:"info",children:(0,r.jsxs)(n.p,{children:["The use of separate ",(0,r.jsx)(n.code,{children:"ExtendRef"})," objects for each reserve might seem redundant, but it follows the principle of least privilege. Each reference grants specific permissions, making the contract's intentions explicit and auditable."]})}),"\n",(0,r.jsx)(n.p,{children:"The separation of reserves into distinct FungibleStore objects prevents any possibility of token mixing or confusion - a critical safety feature when handling user funds. The mint and burn references provide controlled access to LP token supply, ensuring that tokens can only be created when liquidity is added and destroyed when it's removed."}),"\n",(0,r.jsx)(n.admonition,{title:"View Source",type:"tip",children:(0,r.jsxs)(n.p,{children:["See the complete struct definition: ",(0,r.jsx)(n.a,{href:"https://github.com/cedra-labs/move-contract-examples/blob/main/dex/sources/2-swap.move#L20-L28",children:(0,r.jsx)(n.code,{children:"TradingPair"})})]})}),"\n",(0,r.jsx)(n.p,{children:"Each component serves a specific purpose:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reserves"}),": Separate stores for each token prevent conflicts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mint/Burn refs"}),": Control LP token supply"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Extend refs"}),": Enable programmatic management of reserves"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"step-1-creating-a-trading-pair",children:"Step 1: Creating a Trading Pair"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"public fun create_pair(\n    lp_creator: &signer, \n    x_metadata: Object<Metadata>, \n    y_metadata: Object<Metadata>\n): Object<Metadata>\n"})}),"\n",(0,r.jsx)(n.p,{children:"This function:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Creates a new object for the trading pair"}),"\n",(0,r.jsx)(n.li,{children:"Initializes LP token with metadata"}),"\n",(0,r.jsx)(n.li,{children:"Sets up separate reserve stores"}),"\n",(0,r.jsx)(n.li,{children:"Returns LP token metadata for future operations"}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{title:"View Source",type:"tip",children:(0,r.jsxs)(n.p,{children:["Complete implementation: ",(0,r.jsx)(n.a,{href:"https://github.com/cedra-labs/move-contract-examples/blob/main/dex/sources/2-swap.move#L31-L71",children:(0,r.jsx)(n.code,{children:"create_pair"})})]})}),"\n",(0,r.jsx)(n.p,{children:"You can see real example below:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"{\n    use simple_dex::swap;\n    use std::signer;\n    \n    fun create_eth_usdc_pair(admin: &signer) {\n        // Assume ETH and USDC metadata objects exist\n        let eth_metadata = @0x123::tokens::eth_metadata();\n        let usdc_metadata = @0x456::tokens::usdc_metadata();\n        \n        // Create the trading pair\n        let lp_metadata = swap::create_pair(\n            admin,\n            eth_metadata,\n            usdc_metadata\n        );\n        \n        // Store LP metadata for future use\n        // In production, emit an event or store in registry\n    }\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"step-2-adding-liquidity",children:"Step 2: Adding Liquidity"}),"\n",(0,r.jsxs)(n.p,{children:["When adding liquidity, you must maintain the current pool ratio to ensure fair pricing. The ",(0,r.jsx)(n.code,{children:"add_liquidity"})," function handles this automatically."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"public entry fun add_liquidity(\n    user: &signer,\n    lp_metadata: Object<Metadata>,\n    x_metadata: Object<Metadata>,\n    y_metadata: Object<Metadata>,\n    amount_x_desired: u64,\n    amount_y_desired: u64,\n    amount_x_min: u64,\n    amount_y_min: u64\n)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Parameters explained:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"amount_x_desired, amount_y_desired"}),": Maximum amounts you're willing to provide"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"amount_x_min, amount_y_min"}),": Minimum amounts to protect against slippage"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For the first liquidity provider:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"if (reserve_x == 0 && reserve_y == 0) {\n    // Use exact amounts provided\n    (amount_x_desired, amount_y_desired)\n    \n    // LP tokens minted = sqrt(amount_x * amount_y)\n    let lp_amount = std::math64::sqrt(amount_x * amount_y);\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"step-3-executing-swaps",children:"Step 3: Executing Swaps"}),"\n",(0,r.jsx)(n.p,{children:"To execute swap you should:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Validates input amount is non-zero"}),"\n",(0,r.jsx)(n.li,{children:"Calculates output using AMM formula"}),"\n",(0,r.jsx)(n.li,{children:"Checks output meets minimum requirement"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"public entry fun swap_exact_input(\n    user: &signer,\n    lp_metadata: Object<Metadata>,\n    x_metadata: Object<Metadata>,\n    _y_metadata: Object<Metadata>,\n    amount_in: u64,\n    min_amount_out: u64\n)\n"})}),"\n",(0,r.jsx)(n.admonition,{title:"View Source",type:"tip",children:(0,r.jsxs)(n.p,{children:["See the swap implementation: ",(0,r.jsx)(n.a,{href:"https://github.com/cedra-labs/move-contract-examples/blob/main/dex/sources/2-swap.move#L74-L103",children:(0,r.jsx)(n.code,{children:"swap_exact_input"})})]})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"step-4-monitoring-pool-state",children:"Step 4: Monitoring Pool State"}),"\n",(0,r.jsx)(n.p,{children:"The swap module provides several view functions for monitoring that we can use:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// Get current reserves\nlet (reserve_x, reserve_y) = swap::reserves(lp_metadata);\n\n// Check if pair exists\nlet exists = swap::pair_exists(lp_metadata);\n\n// Get comprehensive pair info\nlet (exists, reserve_x, reserve_y) = swap::get_pair_info(lp_metadata);\n"})}),"\n",(0,r.jsx)(n.admonition,{title:"Complete Swap Module",type:"tip",children:(0,r.jsxs)(n.p,{children:["Explore the full trading pair implementation: ",(0,r.jsx)(n.a,{href:"https://github.com/cedra-labs/move-contract-examples/blob/main/dex/sources/2-swap.move",children:(0,r.jsx)(n.code,{children:"swap.move"})})]})}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"You've learned how to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Create a trading pair with LP token generation"}),"\n",(0,r.jsx)(n.li,{children:"Add liquidity while maintaining pool ratios"}),"\n",(0,r.jsx)(n.li,{children:"Execute swaps with slippage protection"}),"\n",(0,r.jsx)(n.li,{children:"Monitor and interact with pool state"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Your trading pair is now ready for use!"}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(n.p,{children:"You've learned how AMMs use the x*y=k formula to enable decentralized trading. Key takeaways:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Constant product formula maintains market equilibrium"}),"\n",(0,r.jsx)(n.li,{children:"Trading fees compensate liquidity providers"}),"\n",(0,r.jsx)(n.li,{children:"Price impact increases with trade size"}),"\n",(0,r.jsx)(n.li,{children:"LP tokens represent proportional pool ownership"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"adding-price-protection-mechanisms",children:(0,r.jsx)(n.a,{href:"./price-protection",children:"Adding Price Protection Mechanisms"})}),"\n",(0,r.jsx)(n.p,{children:"Implement slippage protection, minimum output amounts, and deadline checks to protect users."}),"\n",(0,r.jsx)(n.h3,{id:"multi-hop-routing-for-optimal-execution",children:(0,r.jsx)(n.a,{href:"./multi-hop-routing",children:"Multi-hop Routing for Optimal Execution"})}),"\n",(0,r.jsx)(n.p,{children:"Build a router that finds the best path through multiple pools for optimal trade execution."}),"\n",(0,r.jsx)(n.h3,{id:"dex-client-integration-guide",children:(0,r.jsx)(n.a,{href:"./client-integration",children:"DEX Client Integration Guide"})}),"\n",(0,r.jsx)(n.p,{children:"Create a TypeScript/React frontend that interacts with your DEX smart contracts."})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>d});var t=i(6540);const r={},a=t.createContext(r);function s(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);