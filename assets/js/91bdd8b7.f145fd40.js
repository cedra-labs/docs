"use strict";(self.webpackChunkcedra_docs=self.webpackChunkcedra_docs||[]).push([[7770],{7181:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"move-package-upgrades","title":"Move Package Upgrades","description":"Move code on the Cedra blockchain can be upgraded. This allows code owners and module developers to update and evolve their contracts under a single, stable, well-known account address that doesn\'t change. When a module upgrade happens, all consumers of that module will automatically receive the latest version of the code the next time they interact with it.","source":"@site/docs/move-package-upgrades.md","sourceDirName":".","slug":"/move-package-upgrades","permalink":"/move-package-upgrades","draft":false,"unlisted":false,"editUrl":"https://github.com/cedra-labs/docs/edit/main/docs/move-package-upgrades.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"\ud83d\udce6 Package Management","permalink":"/move-package-management"},"next":{"title":"\ud83d\ude80 Deploying Large Packages","permalink":"/large-packages"}}');var r=s(4848),a=s(8453);const t={},l="Move Package Upgrades",c={},d=[{value:"How Package Upgrades Work",id:"how-package-upgrades-work",level:3},{value:"Compatible (default)",id:"compatible-default",level:4},{value:"Immutable",id:"immutable",level:4},{value:"Policy Strength Hierarchy",id:"policy-strength-hierarchy",level:3},{value:"Performing an Upgrade",id:"performing-an-upgrade",level:3},{value:"Compatibility Rules",id:"compatibility-rules",level:2},{value:"Struct Rules",id:"struct-rules",level:4},{value:"Function Rules",id:"function-rules",level:4},{value:"Friend Function Rules",id:"friend-function-rules",level:4},{value:"Ability Rules",id:"ability-rules",level:4},{value:"Next Steps",id:"next-steps",level:2}];function o(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"move-package-upgrades",children:"Move Package Upgrades"})}),"\n",(0,r.jsx)(n.p,{children:"Move code on the Cedra blockchain can be upgraded. This allows code owners and module developers to update and evolve their contracts under a single, stable, well-known account address that doesn't change. When a module upgrade happens, all consumers of that module will automatically receive the latest version of the code the next time they interact with it."}),"\n",(0,r.jsxs)(n.admonition,{title:"Prerequisites",type:"tip",children:[(0,r.jsx)(n.p,{children:"Before upgrading packages, ensure you have:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.a,{href:"/getting-started/cli",children:"Cedra CLI installed"})]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.a,{href:"/move-package-management",children:"An existing deployed package"})]}),"\n",(0,r.jsxs)(n.li,{children:["\u2705 ",(0,r.jsx)(n.a,{href:"/move-package-management#configuring-movetoml",children:"Understanding of Move.toml configuration"})]}),"\n"]})]}),"\n",(0,r.jsx)(n.h3,{id:"how-package-upgrades-work",children:"How Package Upgrades Work"}),"\n",(0,r.jsxs)(n.p,{children:["The Cedra blockchain natively supports different upgrade policies, which allow Move developers to explicitly define the constraints around how their Move code can be upgraded. The default policy is ",(0,r.jsx)(n.strong,{children:"backwards compatible"})," - code upgrades are accepted only if they guarantee that no existing resource storage or public APIs are broken by the upgrade. This compatibility checking is possible because of Move's strongly typed bytecode semantics."]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["Even compatible upgrades can have hazardous effects on applications and dependent Move code. For example, if the semantics of the underlying module are modified. Developers should be careful when depending on third-party Move code that can be upgraded on-chain. See ",(0,r.jsx)(n.a,{href:"#security-considerations-for-dependencies",children:"Security Considerations"})," for more details."]})}),"\n",(0,r.jsx)(n.p,{children:"There are two upgrade policies supported by Cedra:"}),"\n",(0,r.jsx)(n.h4,{id:"compatible-default",children:"Compatible (default)"}),"\n",(0,r.jsx)(n.p,{children:"Upgrades must be backwards compatible:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"For storage:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"All old struct declarations must be the same in the new code"}),"\n",(0,r.jsx)(n.li,{children:"This ensures existing state of storage is correctly interpreted by the new code"}),"\n",(0,r.jsx)(n.li,{children:"New struct declarations can be added"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"For APIs:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"All existing public functions must have the same signature as before"}),"\n",(0,r.jsx)(n.li,{children:"New functions (including public and entry functions) can be added"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"immutable",children:"Immutable"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The code is not upgradeable"}),"\n",(0,r.jsx)(n.li,{children:"Guaranteed to stay the same forever"}),"\n",(0,r.jsx)(n.li,{children:"Use this when you want to give users maximum trust guarantees"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"policy-strength-hierarchy",children:"Policy Strength Hierarchy"}),"\n",(0,r.jsxs)(n.p,{children:["Policies are ordered by strength: ",(0,r.jsx)(n.code,{children:"compatible"})," < ",(0,r.jsx)(n.code,{children:"immutable"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The policy of a package on-chain can only get ",(0,r.jsx)(n.strong,{children:"stronger"}),", not weaker"]}),"\n",(0,r.jsxs)(n.li,{children:["All dependencies of a package must have policies that are ",(0,r.jsx)(n.strong,{children:"equal to or stronger than"})," the package itself"]}),"\n",(0,r.jsxs)(n.li,{children:["For example, an ",(0,r.jsx)(n.code,{children:"immutable"})," package cannot refer directly or indirectly to a ",(0,r.jsx)(n.code,{children:"compatible"})," package"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{title:"Framework Exception",type:"info",children:(0,r.jsxs)(n.p,{children:["Framework packages installed at addresses ",(0,r.jsx)(n.code,{children:"0x1"})," to ",(0,r.jsx)(n.code,{children:"0xa"})," are exempted from the dependency check. This is necessary so you can define an ",(0,r.jsx)(n.code,{children:"immutable"})," package based on the standard libraries, which have the ",(0,r.jsx)(n.code,{children:"compatible"})," policy to allow critical upgrades and fixes."]})}),"\n",(0,r.jsx)(n.h3,{id:"performing-an-upgrade",children:"Performing an Upgrade"}),"\n",(0,r.jsxs)("div",{className:"flow-steps",children:[(0,r.jsxs)("div",{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"1"})," \xa0 ",(0,r.jsx)(n.strong,{children:"Make changes to your code"})]}),(0,r.jsxs)(n.p,{children:["Update your Move modules in the ",(0,r.jsx)(n.code,{children:"sources/"})," directory. Ensure your changes follow the ",(0,r.jsx)(n.a,{href:"#compatibility-rules",children:"compatibility rules"})," for your upgrade policy."]})]}),(0,r.jsx)(n.hr,{}),(0,r.jsxs)("div",{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"2"})," \xa0 ",(0,r.jsx)(n.strong,{children:"Recompile your package"})]}),(0,r.jsx)(n.p,{children:"Compile with the same named addresses as your original deployment:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"cedra move compile --named-addresses my_app=default\n"})}),(0,r.jsx)(n.p,{children:"The compiler will verify your changes are valid Move code."})]}),(0,r.jsx)(n.hr,{}),(0,r.jsxs)("div",{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"3"})," \xa0 ",(0,r.jsx)(n.strong,{children:"Republish to the same address"})]}),(0,r.jsx)(n.p,{children:"Deploy the updated package to the same address where it was originally published:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"cedra move publish --named-addresses my_app=default\n"})}),(0,r.jsx)(n.p,{children:"The CLI will simulate first, checking compatibility. If compatible, confirm to deploy."}),(0,r.jsx)("br",{}),(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Done!"})," Your upgraded module is now live on-chain."]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"compatibility-rules",children:"Compatibility Rules"}),"\n",(0,r.jsxs)(n.p,{children:["When using the ",(0,r.jsx)(n.code,{children:"compatible"})," upgrade policy, updates to existing modules must follow these rules:"]}),"\n",(0,r.jsx)(n.h4,{id:"struct-rules",children:"Struct Rules"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["All existing struct fields ",(0,r.jsx)(n.strong,{children:"cannot be updated"})]}),"\n",(0,r.jsx)(n.li,{children:"No new fields can be added to existing structs"}),"\n",(0,r.jsx)(n.li,{children:"Existing fields cannot be modified or removed"}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"New structs can be added"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// Original\nstruct MyStruct has key {\n    value: u64,\n}\n\n// INVALID upgrade - cannot add field\nstruct MyStruct has key {\n    value: u64,\n    new_field: bool,  // Not allowed!\n}\n\n// VALID - adding a new struct is fine\nstruct AnotherStruct has key {\n    data: vector<u8>,\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"function-rules",children:"Function Rules"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Public functions"})," (",(0,r.jsx)(n.code,{children:"public fun"}),") cannot change their signature (argument types, type arguments, return types)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Entry functions"})," (",(0,r.jsx)(n.code,{children:"entry fun"}),", ",(0,r.jsx)(n.code,{children:"public entry fun"}),") cannot change their signature"]}),"\n",(0,r.jsxs)(n.li,{children:["Argument ",(0,r.jsx)(n.strong,{children:"names"})," can change (only types matter)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"New public and entry functions"})," can be added"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// Original\npublic fun transfer(from: address, to: address, amount: u64) { ... }\n\n// INVALID - cannot change signature\npublic fun transfer(from: address, to: address, amount: u128) { ... }\n\n// VALID - new function\npublic fun transfer_with_memo(from: address, to: address, amount: u64, memo: vector<u8>) { ... }\n"})}),"\n",(0,r.jsx)(n.h4,{id:"friend-function-rules",children:"Friend Function Rules"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"public(friend)"})," functions are treated as private for compatibility purposes:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Their signatures ",(0,r.jsx)(n.strong,{children:"can"})," change arbitrarily"]}),"\n",(0,r.jsx)(n.li,{children:"This is safe because only modules in the same package can call friend functions"}),"\n",(0,r.jsx)(n.li,{children:"Those modules are updated together and must handle any signature changes"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"ability-rules",children:"Ability Rules"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Existing abilities on a struct/enum type ",(0,r.jsx)(n.strong,{children:"cannot be removed"})]}),"\n",(0,r.jsxs)(n.li,{children:["Abilities ",(0,r.jsx)(n.strong,{children:"can be added"})]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"// Original\nstruct Token has store { value: u64 }\n\n// VALID - adding ability\nstruct Token has store, copy { value: u64 }\n\n// INVALID - removing ability\nstruct Token { value: u64 }  // Removed 'store' - not allowed!\n"})}),"\n",(0,r.jsxs)(n.p,{children:["With these rules in mind, you're ready to safely upgrade your packages. If you're unsure whether your changes are compatible, compile with ",(0,r.jsx)(n.code,{children:"cedra move compile"})," first\u2014the compiler will catch compatibility violations before you attempt to publish."]}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Learn the basics in ",(0,r.jsx)(n.a,{href:"/move-package-management",children:"Package Management"})]}),"\n",(0,r.jsxs)(n.li,{children:["Handle large contracts with ",(0,r.jsx)(n.a,{href:"/large-packages",children:"Deploying Large Packages"})]}),"\n",(0,r.jsxs)(n.li,{children:["Dive into ",(0,r.jsx)(n.a,{href:"/move/basics",children:"Move Programming"})]}),"\n",(0,r.jsxs)(n.li,{children:["Understand ",(0,r.jsx)(n.a,{href:"/move/modules",children:"Move Modules"})," and ",(0,r.jsx)(n.a,{href:"/move/functions",children:"Functions"})]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>l});var i=s(6540);const r={},a=i.createContext(r);function t(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);