"use strict";(self.webpackChunkcedra_docs=self.webpackChunkcedra_docs||[]).push([[4843],{186:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>o,default:()=>l,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"concepts/accounts/understanding-accounts","title":"Understanding Accounts","description":"Accounts on Cedra represent access control over assets stored as Move resources. Unlike Ethereum where accounts exist implicitly once someone sends funds to an address, Cedra requires explicit account creation before any transactions can be executed. This design enables powerful features like key rotation and native multisig support.","source":"@site/docs/concepts/accounts/understanding-accounts.md","sourceDirName":"concepts/accounts","slug":"/concepts/accounts/understanding-accounts","permalink":"/concepts/accounts/understanding-accounts","draft":false,"unlisted":false,"editUrl":"https://github.com/cedra-labs/docs/edit/main/docs/concepts/accounts/understanding-accounts.md","tags":[],"version":"current","frontMatter":{},"sidebar":"concepts","previous":{"title":"Block-STM Parallel Execution","permalink":"/concepts/block-stm"},"next":{"title":"Authentication","permalink":"/concepts/accounts/authentication"}}');var c=t(4848),a=t(8453);const r={},o="Understanding Accounts",i={},d=[{value:"Account Addresses",id:"account-addresses",level:3},{value:"Account Types",id:"account-types",level:2},{value:"Standard Accounts",id:"standard-accounts",level:3},{value:"Resource Accounts",id:"resource-accounts",level:3},{value:"Objects",id:"objects",level:3},{value:"Creating an Account",id:"creating-an-account",level:2},{value:"Sequence Numbers",id:"sequence-numbers",level:2},{value:"Account State",id:"account-state",level:2},{value:"Access Control with Signers",id:"access-control-with-signers",level:2},{value:"Next Steps",id:"next-steps",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.header,{children:(0,c.jsx)(n.h1,{id:"understanding-accounts",children:"Understanding Accounts"})}),"\n",(0,c.jsx)(n.p,{children:"Accounts on Cedra represent access control over assets stored as Move resources. Unlike Ethereum where accounts exist implicitly once someone sends funds to an address, Cedra requires explicit account creation before any transactions can be executed. This design enables powerful features like key rotation and native multisig support."}),"\n",(0,c.jsx)(n.admonition,{title:"Navigation",type:"tip",children:(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"You are here:"})," Understanding Accounts\n",(0,c.jsx)(n.strong,{children:"Next:"})," ",(0,c.jsx)(n.a,{href:"/concepts/accounts/authentication",children:"Authentication"})," | ",(0,c.jsx)(n.a,{href:"/concepts/accounts/resources",children:"Resources"}),"\n",(0,c.jsx)(n.strong,{children:"Overview:"})," ",(0,c.jsx)(n.a,{href:"/concepts/blockchain",children:"Blockchain Architecture"})]})}),"\n",(0,c.jsx)(n.h3,{id:"account-addresses",children:"Account Addresses"}),"\n",(0,c.jsxs)(n.p,{children:["Every account is identified by a 32-byte address, displayed as a 64-character hexadecimal string prefixed with ",(0,c.jsx)(n.code,{children:"0x"}),". When you see short addresses like ",(0,c.jsx)(n.code,{children:"0x1"})," for framework modules, they're simply padded with leading zeros - ",(0,c.jsx)(n.code,{children:"0x1"})," becomes ",(0,c.jsx)(n.code,{children:"0x0000000000000000000000000000000000000000000000000000000000000001"}),"."]}),"\n",(0,c.jsx)(n.mermaid,{value:'graph LR\n    subgraph "Address Format"\n        A[32 bytes] --\x3e B[64 hex characters]\n        B --\x3e C["0x prefix"]\n    end\n\n    subgraph "Example"\n        D["0x1"] --\x3e E["0x000...001"]\n    end'}),"\n",(0,c.jsx)(n.p,{children:"The address is permanent and never changes, even when authentication keys are rotated. Think of it as your unchanging identifier on the network, similar to a username that stays constant even when you change your password."}),"\n",(0,c.jsx)(n.h2,{id:"account-types",children:"Account Types"}),"\n",(0,c.jsx)(n.p,{children:"Cedra supports three distinct account types, each serving different purposes."}),"\n",(0,c.jsx)(n.h3,{id:"standard-accounts",children:"Standard Accounts"}),"\n",(0,c.jsx)(n.p,{children:"The most common account type, controlled by a public/private key pair. When you create a wallet, you're creating a standard account. You sign transactions with your private key, and the network verifies them against your public key."}),"\n",(0,c.jsx)(n.h3,{id:"resource-accounts",children:"Resource Accounts"}),"\n",(0,c.jsx)(n.p,{children:"These are autonomous accounts with no private key - nobody can sign transactions on their behalf. Developers use resource accounts to store modules and resources that need to exist independently of any user. For example, a DEX might deploy its liquidity pool logic to a resource account so the code persists regardless of the original deployer."}),"\n",(0,c.jsx)(n.h3,{id:"objects",children:"Objects"}),"\n",(0,c.jsx)(n.p,{children:"Objects represent complex assets at a single address, useful when you need to group related resources together. Unlike standard accounts, objects are designed to represent single entities like NFTs or complex on-chain structures."}),"\n",(0,c.jsx)(n.mermaid,{value:'graph TD\n    subgraph "Standard Account"\n        A[Private Key] --\x3e B[Public Key]\n        B --\x3e C[Signs Transactions]\n    end\n\n    subgraph "Resource Account"\n        D[No Private Key]\n        D --\x3e E[Autonomous]\n        E --\x3e F[Stores Modules/Resources]\n    end\n\n    subgraph "Object"\n        G[Single Address]\n        G --\x3e H[Groups Related Resources]\n    end'}),"\n",(0,c.jsx)(n.h2,{id:"creating-an-account",children:"Creating an Account"}),"\n",(0,c.jsx)(n.p,{children:"Account creation follows a deterministic process that derives the address from your chosen authentication scheme."}),"\n",(0,c.jsx)(n.p,{children:"First, you select an authentication scheme - either Ed25519 (the default and most common) or Secp256k1 ECDSA. Then you generate a key pair for that scheme. From the public key, you derive a 32-byte authentication key using a hash function. This authentication key becomes your initial account address."}),"\n",(0,c.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant User\n    participant KeyGen\n    participant Hash\n    participant Network\n\n    User->>KeyGen: Select auth scheme (Ed25519/Secp256k1)\n    KeyGen->>KeyGen: Generate key pair\n    KeyGen->>Hash: Public key + scheme identifier\n    Hash->>Hash: SHA3-256\n    Hash->>User: 32-byte auth key\n    User->>Network: Create account with auth key as address"}),"\n",(0,c.jsx)(n.p,{children:"The relationship between authentication key and address is what enables key rotation - you can change your auth key later while keeping the same address."}),"\n",(0,c.jsx)(n.h2,{id:"sequence-numbers",children:"Sequence Numbers"}),"\n",(0,c.jsx)(n.p,{children:"Every account maintains a sequence number that acts as a transaction counter. When you submit a transaction, it must include your current sequence number. After successful execution, the sequence number increments by one."}),"\n",(0,c.jsx)(n.p,{children:"This mechanism serves a critical security purpose: replay protection. Without sequence numbers, an attacker could capture a valid signed transaction and submit it repeatedly. With sequence numbers, each transaction is valid exactly once - the second attempt would fail because the sequence number would no longer match."}),"\n",(0,c.jsx)(n.admonition,{title:"Multi-Agent Transactions",type:"info",children:(0,c.jsx)(n.p,{children:"In transactions involving multiple signers, only the primary signer's sequence number is checked and incremented. Secondary signers don't need to worry about sequence number coordination."})}),"\n",(0,c.jsx)(n.h2,{id:"account-state",children:"Account State"}),"\n",(0,c.jsx)(n.p,{children:"Each account can hold two types of on-chain data: Move modules and Move resources."}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"Modules"})," are compiled smart contract code. When you deploy a Move package, the bytecode is stored as modules under your account. Other accounts can then call functions from these modules."]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"Resources"})," are structured data that follows Move's ownership rules. Your CED balance, NFT collections, and any other on-chain assets exist as resources stored within your account."]}),"\n",(0,c.jsx)(n.p,{children:"An account can hold an arbitrary number of both modules and resources. This per-account storage model is fundamentally different from Ethereum's contract-centric approach, and it's what enables Cedra's parallel execution - transactions touching different accounts can run simultaneously without conflicts."}),"\n",(0,c.jsx)(n.h2,{id:"access-control-with-signers",children:"Access Control with Signers"}),"\n",(0,c.jsxs)(n.p,{children:["Move uses the ",(0,c.jsx)(n.code,{children:"signer"})," type to implement access control. When a function requires a ",(0,c.jsx)(n.code,{children:"signer"})," parameter, only the account owner can call it - they must sign the transaction to prove ownership."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-move",children:"module 0x1::coin {\n    /// Only the account owner can withdraw from their balance\n    public fun withdraw(account: &signer, amount: u64): Coin {\n        // signer proves ownership of the account\n        let balance = borrow_global_mut<Balance>(signer::address_of(account));\n        // ... withdraw logic\n    }\n\n    /// Anyone can check a balance - no signer required\n    public fun balance(addr: address): u64 {\n        borrow_global<Balance>(addr).value\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["Functions without a ",(0,c.jsx)(n.code,{children:"signer"})," parameter are open to anyone. In the example above, ",(0,c.jsx)(n.code,{children:"withdraw"})," requires the account owner's signature, but ",(0,c.jsx)(n.code,{children:"balance"})," can be called by anyone to view any account's balance. This pattern - signer for writes, address for reads - appears throughout Move development."]}),"\n",(0,c.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.a,{href:"/concepts/accounts/authentication",children:"Authentication"})," - Learn about auth schemes, multisig, and key rotation"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.a,{href:"/concepts/accounts/resources",children:"Resources"})," - Understand how Move resources are stored and accessed"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.a,{href:"/concepts/transactions/understanding-transactions",children:"Transactions"})," - See how accounts interact with the network"]}),"\n"]})]})}function l(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(6540);const c={},a=s.createContext(c);function r(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);