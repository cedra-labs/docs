"use strict";(self.webpackChunkcedra_docs=self.webpackChunkcedra_docs||[]).push([[7764],{6731:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"move/errors","title":"Error Handling and Assertions in Move","description":"Master error handling in Move - from assertions and abort codes to advanced patterns. Learn how to build robust modules that fail gracefully and provide clear error messages.","source":"@site/docs/move/errors.md","sourceDirName":"move","slug":"/move/errors","permalink":"/move/errors","draft":false,"unlisted":false,"editUrl":"https://github.com/cedra-labs/docs/edit/main/docs/move/errors.md","tags":[],"version":"current","frontMatter":{"title":"Error Handling and Assertions in Move","sidebar_label":"Error Handling","description":"Master error handling in Move - from assertions and abort codes to advanced patterns. Learn how to build robust modules that fail gracefully and provide clear error messages.","keywords":["move error handling","assertions","abort codes","error patterns","move programming","blockchain errors"]},"sidebar":"docs","previous":{"title":"Conditionals, Loops, and Control Flow","permalink":"/move/flow"},"next":{"title":"CLI Reference","permalink":"/cli/usage"}}');var s=r(4848),i=r(8453);const a={title:"Error Handling and Assertions in Move",sidebar_label:"Error Handling",description:"Master error handling in Move - from assertions and abort codes to advanced patterns. Learn how to build robust modules that fail gracefully and provide clear error messages.",keywords:["move error handling","assertions","abort codes","error patterns","move programming","blockchain errors"]},o="Error Handling and Assertions in Move",l={},c=[{value:"Assert: Your Guardian at the Gate",id:"assert-your-guardian-at-the-gate",level:2},{value:"The Anatomy of Good Error Handling",id:"the-anatomy-of-good-error-handling",level:2},{value:"Beyond Simple Assertions: Error Handling Patterns",id:"beyond-simple-assertions-error-handling-patterns",level:2},{value:"The Option Pattern: When Missing Isn&#39;t Failing",id:"the-option-pattern-when-missing-isnt-failing",level:3},{value:"The Validation Pattern: Separating Checks from Actions",id:"the-validation-pattern-separating-checks-from-actions",level:3},{value:"The Result Pattern: Handling Multiple Failure Modes",id:"the-result-pattern-handling-multiple-failure-modes",level:3},{value:"Organizing Errors in Large Projects",id:"organizing-errors-in-large-projects",level:2},{value:"The Centralized Error Module Approach",id:"the-centralized-error-module-approach",level:3},{value:"Error Namespacing for Very Large Projects",id:"error-namespacing-for-very-large-projects",level:3},{value:"Common Pitfalls and How to Avoid Them",id:"common-pitfalls-and-how-to-avoid-them",level:2},{value:"The Silent Failure Trap",id:"the-silent-failure-trap",level:3},{value:"The Overly Generic Error Problem",id:"the-overly-generic-error-problem",level:3},{value:"The Late Validation Anti-Pattern",id:"the-late-validation-anti-pattern",level:3},{value:"Testing Your Error Handling",id:"testing-your-error-handling",level:2},{value:"Testing Complex Error Scenarios",id:"testing-complex-error-scenarios",level:3},{value:"Advanced Error Handling Patterns",id:"advanced-error-handling-patterns",level:2},{value:"The Retry Pattern with Exponential Backoff",id:"the-retry-pattern-with-exponential-backoff",level:3},{value:"The Circuit Breaker Pattern",id:"the-circuit-breaker-pattern",level:3},{value:"The Saga Pattern for Distributed Transactions",id:"the-saga-pattern-for-distributed-transactions",level:3},{value:"Best Practices and Guidelines",id:"best-practices-and-guidelines",level:2},{value:"1. Design Your Error Codes Thoughtfully",id:"1-design-your-error-codes-thoughtfully",level:3},{value:"2. Fail Fast, Fail Descriptively",id:"2-fail-fast-fail-descriptively",level:3},{value:"3. Provide Safe Alternatives",id:"3-provide-safe-alternatives",level:3},{value:"4. Test Error Paths Thoroughly",id:"4-test-error-paths-thoroughly",level:3},{value:"5. Document Error Conditions",id:"5-document-error-conditions",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"What&#39;s Next?",id:"whats-next",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{Details:r}=n;return r||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"error-handling-and-assertions-in-move",children:"Error Handling and Assertions in Move"})}),"\n",(0,s.jsx)(n.p,{children:"Traditional error handling is like carefully backing out of a parking space when you realize it's too small. Move's approach is like never entering the space at all if it won't fit. The latter is simpler, safer, and leaves no room for getting stuck halfway."}),"\n",(0,s.jsx)(n.p,{children:"Here's what happens when a Move transaction encounters an error:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"The execution immediately stops"}),"\n",(0,s.jsx)(n.li,{children:"All changes made during the transaction are discarded"}),"\n",(0,s.jsx)(n.li,{children:"The blockchain state remains unchanged"}),"\n",(0,s.jsx)(n.li,{children:"Gas fees are still charged (to prevent denial-of-service attacks)"}),"\n",(0,s.jsx)(n.li,{children:"An error code is returned to indicate what went wrong"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This might seem wasteful \u2013 why charge gas for failed transactions? But this design prevents attackers from spamming the network with deliberately failing transactions. Every computation costs something, whether it succeeds or fails."}),"\n",(0,s.jsx)(n.h2,{id:"assert-your-guardian-at-the-gate",children:"Assert: Your Guardian at the Gate"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"assert!"})," macro is Move's primary tool for error handling. It's deceptively simple: check a condition, and if it's false, abort with an error code. But don't let its simplicity fool you \u2013 it's the foundation of all safety checks in Move."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"module 0x42::bank {\n    const E_INSUFFICIENT_FUNDS: u64 = 1;\n    \n    public fun withdraw(account: &mut Account, amount: u64) {\n        assert!(account.balance >= amount, E_INSUFFICIENT_FUNDS);\n        account.balance = account.balance - amount;\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"assert!"})," fails, it's like hitting an emergency stop button. Everything halts immediately. No partial execution, no corrupted state, no need for cleanup. The transaction simply never happened from the blockchain's perspective."]}),"\n",(0,s.jsxs)(n.p,{children:["But why use error codes instead of error messages? This is another blockchain optimization. Storing strings on-chain is expensive, and error messages would bloat the blockchain. Numbers are compact and efficient. The error code ",(0,s.jsx)(n.code,{children:"1"}),' might mean "insufficient funds" in your module, and developers can look up what each code means in your documentation.']}),"\n",(0,s.jsx)(n.h2,{id:"the-anatomy-of-good-error-handling",children:"The Anatomy of Good Error Handling"}),"\n",(0,s.jsx)(n.p,{children:"Let's build up a complete example to see how error handling patterns emerge naturally from Move's constraints. We'll create a simple marketplace where users can list items for sale."}),"\n",(0,s.jsx)(n.p,{children:"First, let's think about what could go wrong:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The seller might not own the item"}),"\n",(0,s.jsx)(n.li,{children:"The price might be invalid (zero or too high)"}),"\n",(0,s.jsx)(n.li,{children:"The item might already be listed"}),"\n",(0,s.jsx)(n.li,{children:"The marketplace might be paused for maintenance"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Here's how we structure these errors:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"module 0x42::marketplace {\n    // Error constants grouped by category\n    \n    // Authorization errors (1-99)\n    const E_NOT_ITEM_OWNER: u64 = 1;\n    const E_MARKETPLACE_PAUSED: u64 = 2;\n    \n    // Validation errors (100-199)\n    const E_INVALID_PRICE: u64 = 100;\n    const E_PRICE_TOO_HIGH: u64 = 101;\n    \n    // State errors (200-299)\n    const E_ITEM_ALREADY_LISTED: u64 = 200;\n    const E_ITEM_NOT_FOUND: u64 = 201;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Notice the grouping? This isn't just organization \u2013 it's a debugging tool. When you see error 101, you immediately know it's a validation issue related to pricing. Error 201? That's a state problem. This systematic approach becomes invaluable as your project grows."}),"\n",(0,s.jsxs)(n.admonition,{title:"Real-World Error Organization",type:"tip",children:[(0,s.jsx)(n.p,{children:"See how our guides organize errors:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/guides/first-fa#5-debug-cheatsheet",children:"Fungible Asset Errors"})," - Standard abort codes for token operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/guides/escrow#core-data-structures",children:"Escrow Error Categories"})," - Grouped by operation type"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/guides/fee-splitter#32-constants--errors",children:"Fee Splitter Validation"})," - Clear error constants with descriptive names"]}),"\n"]})]}),"\n",(0,s.jsx)(n.p,{children:"Now let's implement the listing function:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun list_item(\n    seller: &signer,\n    item_id: u64,\n    price: u64\n) acquires ItemRegistry, ListingRegistry, MarketplaceConfig {\n    // First, check if marketplace is operational\n    let config = borrow_global<MarketplaceConfig>(@marketplace);\n    assert!(!config.is_paused, E_MARKETPLACE_PAUSED);\n    \n    // Verify ownership\n    let seller_addr = signer::address_of(seller);\n    let registry = borrow_global<ItemRegistry>(@marketplace);\n    assert!(\n        table::contains(&registry.items, item_id),\n        E_ITEM_NOT_FOUND\n    );\n    \n    let item = table::borrow(&registry.items, item_id);\n    assert!(item.owner == seller_addr, E_NOT_ITEM_OWNER);\n    \n    // Validate price\n    assert!(price > 0, E_INVALID_PRICE);\n    assert!(price <= MAX_LISTING_PRICE, E_PRICE_TOO_HIGH);\n    \n    // Check if already listed\n    let listings = borrow_global<ListingRegistry>(@marketplace);\n    assert!(\n        !table::contains(&listings.active, item_id),\n        E_ITEM_ALREADY_LISTED\n    );\n    \n    // All checks passed - create the listing\n    create_listing_internal(seller_addr, item_id, price);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Look at the flow: we check the broadest conditions first (is the marketplace even running?), then narrow down to specific validations. Each assertion acts as a guardian, ensuring the next step is safe to execute. By the time we reach ",(0,s.jsx)(n.code,{children:"create_listing_internal"}),", we know with certainty that:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The marketplace is operational"}),"\n",(0,s.jsx)(n.li,{children:"The item exists and belongs to the seller"}),"\n",(0,s.jsx)(n.li,{children:"The price is valid"}),"\n",(0,s.jsx)(n.li,{children:"The item isn't already listed"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This pattern \u2013 validate everything before modifying anything \u2013 is fundamental to Move programming."}),"\n",(0,s.jsx)(n.h2,{id:"beyond-simple-assertions-error-handling-patterns",children:"Beyond Simple Assertions: Error Handling Patterns"}),"\n",(0,s.jsxs)(n.p,{children:["While ",(0,s.jsx)(n.code,{children:"assert!"})," is powerful, real-world applications need more sophisticated patterns. Let's explore how Move developers handle complex error scenarios."]}),"\n",(0,s.jsx)(n.h3,{id:"the-option-pattern-when-missing-isnt-failing",children:"The Option Pattern: When Missing Isn't Failing"}),"\n",(0,s.jsxs)(n.p,{children:["Sometimes the absence of data isn't an error \u2013 it's just a possibility to handle. Move's ",(0,s.jsx)(n.code,{children:"Option<T>"}),' type represents values that might or might not exist. This is perfect for queries where "not found" is a normal outcome:']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun find_listing(item_id: u64): Option<Listing> acquires ListingRegistry {\n    let listings = borrow_global<ListingRegistry>(@marketplace);\n    \n    if (table::contains(&listings.active, item_id)) {\n        let listing = table::borrow(&listings.active, item_id);\n        option::some(*listing)\n    } else {\n        option::none()\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Why return ",(0,s.jsx)(n.code,{children:"Option<Listing>"})," instead of asserting the listing exists? Because callers might want to check if an item is listed without aborting if it isn't:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun get_listing_price(item_id: u64): u64 acquires ListingRegistry {\n    let listing_opt = find_listing(item_id);\n    \n    if (option::is_some(&listing_opt)) {\n        let listing = option::borrow(&listing_opt);\n        listing.price\n    } else {\n        0  // Return 0 for unlisted items\n    }\n}\n\npublic fun buy_item(buyer: &signer, item_id: u64) acquires ListingRegistry {\n    let listing_opt = find_listing(item_id);\n    \n    // Here we DO want to abort if not listed\n    assert!(option::is_some(&listing_opt), E_ITEM_NOT_LISTED);\n    \n    let listing = option::extract(&mut listing_opt);\n    process_purchase(buyer, listing);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["See the flexibility? The same ",(0,s.jsx)(n.code,{children:"find_listing"})," function serves different purposes. ",(0,s.jsx)(n.code,{children:"get_listing_price"})," handles missing listings gracefully, while ",(0,s.jsx)(n.code,{children:"buy_item"})," treats them as errors. The Option pattern lets callers decide what's an error and what isn't."]}),"\n",(0,s.jsx)(n.h3,{id:"the-validation-pattern-separating-checks-from-actions",children:"The Validation Pattern: Separating Checks from Actions"}),"\n",(0,s.jsx)(n.p,{children:"Complex operations often require multiple validations. Separating validation logic from execution logic makes code cleaner and more testable:"}),"\n",(0,s.jsx)(n.admonition,{title:"Pattern Implementation",type:"info",children:(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"/guides/first-nft#3-creatorgated-mint",children:"NFT minting"})," shows this pattern with its creator validation. The ",(0,s.jsx)(n.a,{href:"/guides/escrow#step-3-releasing-funds",children:"Escrow contract"})," demonstrates comprehensive validation before fund release."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Pure validation function - returns bool, never aborts\npublic fun is_valid_purchase(\n    buyer_addr: address,\n    listing: &Listing,\n    payment_amount: u64\n): bool {\n    let has_funds = get_balance(buyer_addr) >= payment_amount;\n    let price_matches = payment_amount == listing.price;\n    let not_own_item = buyer_addr != listing.seller;\n    let not_expired = timestamp::now_seconds() < listing.expiry;\n    \n    has_funds && price_matches && not_own_item && not_expired\n}\n\n// Validation with specific error codes - aborts on failure\npublic fun validate_purchase(\n    buyer_addr: address,\n    listing: &Listing,\n    payment_amount: u64\n) {\n    assert!(\n        get_balance(buyer_addr) >= payment_amount,\n        E_INSUFFICIENT_FUNDS\n    );\n    assert!(\n        payment_amount == listing.price,\n        E_INCORRECT_PAYMENT\n    );\n    assert!(\n        buyer_addr != listing.seller,\n        E_CANNOT_BUY_OWN_ITEM\n    );\n    assert!(\n        timestamp::now_seconds() < listing.expiry,\n        E_LISTING_EXPIRED\n    );\n}\n\n// Main function uses validation\npublic entry fun purchase_item(\n    buyer: &signer,\n    item_id: u64,\n    payment_amount: u64\n) acquires ListingRegistry {\n    let listing = get_listing(item_id);  // This asserts listing exists\n    let buyer_addr = signer::address_of(buyer);\n    \n    // Validate everything upfront\n    validate_purchase(buyer_addr, &listing, payment_amount);\n    \n    // Execute with confidence\n    transfer_payment(buyer, listing.seller, payment_amount);\n    transfer_item(listing.seller, buyer_addr, item_id);\n    remove_listing(item_id);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This pattern has several benefits:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The boolean version (",(0,s.jsx)(n.code,{children:"is_valid_purchase"}),") lets you check without aborting"]}),"\n",(0,s.jsxs)(n.li,{children:["The asserting version (",(0,s.jsx)(n.code,{children:"validate_purchase"}),") provides specific error codes"]}),"\n",(0,s.jsxs)(n.li,{children:["The main function (",(0,s.jsx)(n.code,{children:"purchase_item"}),") stays focused on the happy path"]}),"\n",(0,s.jsx)(n.li,{children:"Tests can verify each validation rule independently"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"the-result-pattern-handling-multiple-failure-modes",children:"The Result Pattern: Handling Multiple Failure Modes"}),"\n",(0,s.jsx)(n.p,{children:"Sometimes you need to handle errors without immediately aborting. Maybe you want to try several approaches or provide detailed feedback about what went wrong. The Result pattern brings Try-Catch style error handling to Move:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"struct Result<T> has drop {\n    success: bool,\n    value: Option<T>,\n    error_code: u64,\n}\n\n// Constructor functions for convenience\npublic fun ok<T>(value: T): Result<T> {\n    Result {\n        success: true,\n        value: option::some(value),\n        error_code: 0,\n    }\n}\n\npublic fun err<T>(error_code: u64): Result<T> {\n    Result {\n        success: false,\n        value: option::none(),\n        error_code,\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Here's how you might use it for an operation that can fail in multiple ways:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun try_auto_purchase(\n    buyer: address,\n    max_price: u64,\n    preferred_sellers: vector<address>\n): Result<PurchaseReceipt> acquires ListingRegistry {\n    let listings = borrow_global<ListingRegistry>(@marketplace);\n    \n    // First try: preferred sellers\n    let i = 0;\n    while (i < vector::length(&preferred_sellers)) {\n        let seller = *vector::borrow(&preferred_sellers, i);\n        let result = try_purchase_from_seller(buyer, seller, max_price);\n        \n        if (result.success) {\n            return result  // Found a match!\n        };\n        \n        i = i + 1;\n    };\n    \n    // Second try: any seller within budget\n    let all_listings = get_listings_under_price(max_price);\n    if (vector::is_empty(&all_listings)) {\n        return err<PurchaseReceipt>(E_NO_LISTINGS_IN_BUDGET)\n    };\n    \n    // Try the cheapest option\n    let cheapest = find_cheapest_listing(&all_listings);\n    try_purchase_listing(buyer, cheapest)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The Result pattern shines when you have fallback strategies or want to collect multiple errors before deciding what to do."}),"\n",(0,s.jsx)(n.h2,{id:"organizing-errors-in-large-projects",children:"Organizing Errors in Large Projects"}),"\n",(0,s.jsx)(n.p,{children:"As your project grows from a single module to a complex system, error organization becomes crucial. A well-organized error system helps developers understand failures quickly and maintains consistency across teams."}),"\n",(0,s.jsx)(n.h3,{id:"the-centralized-error-module-approach",children:"The Centralized Error Module Approach"}),"\n",(0,s.jsx)(n.p,{children:"For large projects, consider centralizing error definitions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"module marketplace::errors {\n    // ===== Global Errors (1-999) =====\n    const E_UNAUTHORIZED: u64 = 1;\n    const E_INVALID_ARGUMENT: u64 = 2;\n    const E_NOT_FOUND: u64 = 3;\n    const E_ALREADY_EXISTS: u64 = 4;\n    \n    // ===== Token Module Errors (1000-1999) =====\n    const E_INSUFFICIENT_BALANCE: u64 = 1000;\n    const E_TOKEN_NOT_REGISTERED: u64 = 1001;\n    const E_MINT_EXCEEDS_SUPPLY: u64 = 1002;\n    const E_TRANSFER_TO_SELF: u64 = 1003;\n    \n    // ===== Market Module Errors (2000-2999) =====\n    const E_INVALID_PRICE: u64 = 2000;\n    const E_LISTING_EXPIRED: u64 = 2001;\n    const E_ALREADY_SOLD: u64 = 2002;\n    const E_MARKET_PAUSED: u64 = 2003;\n    \n    // ===== Auction Module Errors (3000-3999) =====\n    const E_AUCTION_NOT_STARTED: u64 = 3000;\n    const E_AUCTION_ENDED: u64 = 3001;\n    const E_BID_TOO_LOW: u64 = 3002;\n    const E_WINNER_CANNOT_BID: u64 = 3003;\n    \n    // Accessor functions for use in other modules\n    public fun unauthorized(): u64 { E_UNAUTHORIZED }\n    public fun invalid_argument(): u64 { E_INVALID_ARGUMENT }\n    public fun insufficient_balance(): u64 { E_INSUFFICIENT_BALANCE }\n    // ... more accessors\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now other modules import and use these standardized errors:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"module marketplace::token {\n    use marketplace::errors;\n    \n    public fun transfer(from: &signer, to: address, amount: u64) {\n        let from_balance = get_balance(signer::address_of(from));\n        assert!(from_balance >= amount, errors::insufficient_balance());\n        \n        // Transfer logic\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This approach has several advantages:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consistency"}),": All modules use the same error codes for similar situations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Documentation"}),": One place to document what each error means"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Avoid conflicts"}),": No accidental reuse of error codes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Easy updates"}),": Change an error code in one place"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"error-namespacing-for-very-large-projects",children:"Error Namespacing for Very Large Projects"}),"\n",(0,s.jsx)(n.p,{children:"For enterprise-scale projects with dozens of modules, consider a hierarchical error numbering scheme:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Format: [System:1][Module:2][Category:1][Specific:2]\n// Example: 102034 = System 1, Module 02, Category 0, Error 34\n\nmodule megaproject::lending_errors {\n    // System 1: DeFi Platform\n    // Module 01: Collateral Management\n    const E_INSUFFICIENT_COLLATERAL: u64 = 101001;\n    const E_COLLATERAL_NOT_SUPPORTED: u64 = 101002;\n    const E_COLLATERAL_PRICE_STALE: u64 = 101003;\n    \n    // Module 02: Lending Pool\n    const E_BORROW_EXCEEDS_LIMIT: u64 = 102001;\n    const E_HEALTH_FACTOR_TOO_LOW: u64 = 102002;\n    \n    // Module 03: Interest Calculation\n    const E_RATE_OVERFLOW: u64 = 103001;\n    const E_NEGATIVE_INTEREST: u64 = 103002;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"With this scheme, error 102002 immediately tells you:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It's from the DeFi platform (1)"}),"\n",(0,s.jsx)(n.li,{children:"Specifically the lending pool module (02)"}),"\n",(0,s.jsx)(n.li,{children:"It's a validation error (0)"}),"\n",(0,s.jsx)(n.li,{children:"The specific issue is health factor (02)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"common-pitfalls-and-how-to-avoid-them",children:"Common Pitfalls and How to Avoid Them"}),"\n",(0,s.jsx)(n.p,{children:"Let's explore mistakes that even experienced developers make when handling errors in Move."}),"\n",(0,s.jsx)(n.h3,{id:"the-silent-failure-trap",children:"The Silent Failure Trap"}),"\n",(0,s.jsx)(n.p,{children:"One of the most dangerous patterns is swallowing errors:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// \u274c DANGEROUS: Returns default value on error\npublic fun get_user_balance(addr: address): u64 acquires UserAccount {\n    if (!exists<UserAccount>(addr)) {\n        return 0  // Silently pretending user has zero balance!\n    };\n    \n    borrow_global<UserAccount>(addr).balance\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Why is this dangerous? Imagine this scenario:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"A user tries to check their balance"}),"\n",(0,s.jsx)(n.li,{children:"Due to a bug, their account wasn't created properly"}),"\n",(0,s.jsx)(n.li,{children:"The function returns 0 instead of indicating an error"}),"\n",(0,s.jsx)(n.li,{children:"The user thinks they have no funds when they might have millions"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Here's the safer approach:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// \u2705 SAFE: Caller decides how to handle missing accounts\npublic fun try_get_balance(addr: address): Option<u64> acquires UserAccount {\n    if (exists<UserAccount>(addr)) {\n        let account = borrow_global<UserAccount>(addr);\n        option::some(account.balance)\n    } else {\n        option::none()\n    }\n}\n\n// \u2705 SAFE: Clear error when account must exist\npublic fun get_user_balance(addr: address): u64 acquires UserAccount {\n    assert!(exists<UserAccount>(addr), E_ACCOUNT_NOT_FOUND);\n    borrow_global<UserAccount>(addr).balance\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"the-overly-generic-error-problem",children:"The Overly Generic Error Problem"}),"\n",(0,s.jsx)(n.p,{children:"Generic errors make debugging a nightmare:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// \u274c BAD: What exactly is invalid?\npublic fun process_transaction(tx: &Transaction) {\n    assert!(is_valid_transaction(tx), E_INVALID_TRANSACTION);\n}\n\n// \u2705 GOOD: Specific errors for each validation\npublic fun process_transaction(tx: &Transaction) {\n    assert!(tx.amount > 0, E_ZERO_AMOUNT);\n    assert!(tx.amount <= MAX_AMOUNT, E_AMOUNT_TOO_LARGE);\n    assert!(exists<Account>(tx.sender), E_SENDER_NOT_FOUND);\n    assert!(exists<Account>(tx.recipient), E_RECIPIENT_NOT_FOUND);\n    assert!(tx.deadline > timestamp::now_seconds(), E_TRANSACTION_EXPIRED);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Specific errors serve as documentation. When transaction processing fails with ",(0,s.jsx)(n.code,{children:"E_TRANSACTION_EXPIRED"}),", developers immediately know the deadline passed. With ",(0,s.jsx)(n.code,{children:"E_INVALID_TRANSACTION"}),", they have to dig through code to understand what went wrong."]}),"\n",(0,s.jsx)(n.h3,{id:"the-late-validation-anti-pattern",children:"The Late Validation Anti-Pattern"}),"\n",(0,s.jsx)(n.p,{children:"Validating after expensive operations wastes gas:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// \u274c BAD: Wastes computation on invalid data\npublic fun expensive_operation(user: &signer, data: vector<u8>) {\n    let processed = complex_transformation(data);        // Expensive!\n    let validated = validate_format(processed);          // Also expensive!\n    let result = apply_business_logic(validated);        // Very expensive!\n    \n    // Only NOW we check if user can do this?!\n    assert!(is_authorized(signer::address_of(user)), E_UNAUTHORIZED);\n    \n    save_result(result);\n}\n\n// \u2705 GOOD: Fail fast, fail cheap\npublic fun expensive_operation(user: &signer, data: vector<u8>) {\n    // Check authorization first - cheap!\n    assert!(is_authorized(signer::address_of(user)), E_UNAUTHORIZED);\n    \n    // Basic validation - still cheap!\n    assert!(vector::length(&data) > 0, E_EMPTY_DATA);\n    assert!(vector::length(&data) <= MAX_SIZE, E_DATA_TOO_LARGE);\n    \n    // Only process if all checks pass\n    let processed = complex_transformation(data);\n    let validated = validate_format(processed);\n    let result = apply_business_logic(validated);\n    save_result(result);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Remember: on blockchain, failed transactions still cost gas. Check the cheap conditions first to minimize costs when things go wrong."}),"\n",(0,s.jsx)(n.h2,{id:"testing-your-error-handling",children:"Testing Your Error Handling"}),"\n",(0,s.jsx)(n.p,{children:"Robust code tests both success and failure paths. Move provides excellent tools for testing that your functions fail correctly:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[test_only]\nmodule marketplace::market_tests {\n    use marketplace::market;\n    \n    #[test]\n    fun test_successful_listing() {\n        let seller = @0x123;\n        create_test_account(seller, 1000);\n        create_test_item(seller, 1);\n        \n        // Should succeed\n        market::list_item(create_signer_for_test(seller), 1, 500);\n        \n        let listing = market::get_listing(1);\n        assert!(listing.price == 500, 0);\n    }\n    \n    #[test]\n    #[expected_failure(abort_code = market::E_NOT_ITEM_OWNER)]\n    fun test_list_item_not_owner() {\n        let owner = @0x123;\n        let other = @0x456;\n        \n        create_test_item(owner, 1);\n        \n        // Should fail - other doesn't own item\n        market::list_item(create_signer_for_test(other), 1, 500);\n    }\n    \n    #[test]\n    #[expected_failure(abort_code = market::E_INVALID_PRICE)]\n    fun test_list_item_zero_price() {\n        let seller = @0x123;\n        create_test_item(seller, 1);\n        \n        // Should fail - price is zero\n        market::list_item(create_signer_for_test(seller), 1, 0);\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"#[expected_failure]"})," annotation is powerful \u2013 it ensures your function not only fails but fails with the exact error code you expect. This catches bugs where functions fail for the wrong reason."]}),"\n",(0,s.jsx)(n.h3,{id:"testing-complex-error-scenarios",children:"Testing Complex Error Scenarios"}),"\n",(0,s.jsx)(n.p,{children:"For functions with multiple failure modes, test each path:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[test_only]\npublic fun test_all_purchase_failures() {\n    // Setup\n    let seller = @0x123;\n    let buyer = @0x456;\n    let item_id = 1;\n    let price = 1000;\n    \n    create_test_item(seller, item_id);\n    market::list_item(create_signer_for_test(seller), item_id, price);\n    \n    // Test 1: Insufficient funds\n    create_test_account(buyer, 500);  // Only 500, need 1000\n    let result = market::try_purchase(buyer, item_id, 500);\n    assert!(!result.success, 0);\n    assert!(result.error_code == market::E_INSUFFICIENT_FUNDS, 1);\n    \n    // Test 2: Wrong payment amount\n    update_balance(buyer, 2000);  // Now has enough\n    let result = market::try_purchase(buyer, item_id, 999);  // Wrong amount\n    assert!(!result.success, 2);\n    assert!(result.error_code == market::E_INCORRECT_PAYMENT, 3);\n    \n    // Test 3: Buying own item\n    let result = market::try_purchase(seller, item_id, price);\n    assert!(!result.success, 4);\n    assert!(result.error_code == market::E_CANNOT_BUY_OWN_ITEM, 5);\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-error-handling-patterns",children:"Advanced Error Handling Patterns"}),"\n",(0,s.jsxs)(r,{children:[(0,s.jsx)("summary",{children:"\ud83d\udcda Advanced Error Handling Patterns"}),(0,s.jsx)(n.h3,{id:"the-retry-pattern-with-exponential-backoff",children:"The Retry Pattern with Exponential Backoff"}),(0,s.jsx)(n.p,{children:"When dealing with operations that might temporarily fail:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"const MAX_RETRIES: u64 = 3;\nconst E_MAX_RETRIES_EXCEEDED: u64 = 9001;\n\nstruct RetryResult<T> has drop {\n    success: bool,\n    value: Option<T>,\n    attempts: u64,\n    last_error: u64,\n}\n\npublic fun with_retry<T: drop>(\n    max_attempts: u64,\n    operation: |u64| -> Result<T>\n): RetryResult<T> {\n    let attempts = 0;\n    let last_error = 0;\n    \n    while (attempts < max_attempts) {\n        let result = operation(attempts);\n        \n        if (result.success) {\n            return RetryResult {\n                success: true,\n                value: result.value,\n                attempts: attempts + 1,\n                last_error: 0,\n            }\n        };\n        \n        last_error = result.error_code;\n        attempts = attempts + 1;\n        \n        // In real implementation, you might add delays here\n    };\n    \n    RetryResult {\n        success: false,\n        value: option::none(),\n        attempts,\n        last_error,\n    }\n}\n"})}),(0,s.jsx)(n.h3,{id:"the-circuit-breaker-pattern",children:"The Circuit Breaker Pattern"}),(0,s.jsx)(n.p,{children:"Prevent cascading failures by temporarily disabling problematic operations:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"struct CircuitBreaker has key {\n    failure_count: u64,\n    failure_threshold: u64,\n    last_failure_time: u64,\n    cooldown_period: u64,\n    is_open: bool,\n}\n\npublic fun call_with_circuit_breaker<T>(\n    breaker: &mut CircuitBreaker,\n    operation: || -> Result<T>\n): Result<T> {\n    // Check if circuit is open\n    if (breaker.is_open) {\n        let time_since_failure = timestamp::now_seconds() - breaker.last_failure_time;\n        \n        if (time_since_failure < breaker.cooldown_period) {\n            return err<T>(E_CIRCUIT_BREAKER_OPEN)\n        };\n        \n        // Try to close the circuit\n        breaker.is_open = false;\n        breaker.failure_count = 0;\n    };\n    \n    // Try the operation\n    let result = operation();\n    \n    if (!result.success) {\n        breaker.failure_count = breaker.failure_count + 1;\n        breaker.last_failure_time = timestamp::now_seconds();\n        \n        if (breaker.failure_count >= breaker.failure_threshold) {\n            breaker.is_open = true;\n        };\n    } else if (breaker.failure_count > 0) {\n        // Reset on success\n        breaker.failure_count = 0;\n    };\n    \n    result\n}\n"})}),(0,s.jsx)(n.h3,{id:"the-saga-pattern-for-distributed-transactions",children:"The Saga Pattern for Distributed Transactions"}),(0,s.jsx)(n.p,{children:"When you need to coordinate multiple operations that might fail:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"struct SagaStep has drop {\n    execute: |&mut SagaContext| -> Result<()>,\n    compensate: |&mut SagaContext| -> Result<()>,\n}\n\nstruct SagaContext has drop {\n    data: SimpleMap<String, u64>,\n    completed_steps: vector<u64>,\n}\n\npublic fun execute_saga(steps: vector<SagaStep>): Result<()> {\n    let context = SagaContext {\n        data: simple_map::create(),\n        completed_steps: vector::empty(),\n    };\n    \n    let i = 0;\n    while (i < vector::length(&steps)) {\n        let step = vector::borrow(&steps, i);\n        let result = (step.execute)(&mut context);\n        \n        if (!result.success) {\n            // Compensate in reverse order\n            compensate_saga(&steps, &context, i);\n            return result\n        };\n        \n        vector::push_back(&mut context.completed_steps, i);\n        i = i + 1;\n    };\n    \n    ok(())\n}\n\nfun compensate_saga(\n    steps: &vector<SagaStep>,\n    context: &SagaContext,\n    failed_at: u64\n) {\n    let i = failed_at;\n    \n    while (i > 0) {\n        i = i - 1;\n        \n        if (vector::contains(&context.completed_steps, &i)) {\n            let step = vector::borrow(steps, i);\n            let _ = (step.compensate)(context);  // Best effort\n        };\n    };\n}\n"})})]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-and-guidelines",children:"Best Practices and Guidelines"}),"\n",(0,s.jsx)(n.p,{children:"After working with Move's error handling system, certain patterns emerge as best practices:"}),"\n",(0,s.jsx)(n.h3,{id:"1-design-your-error-codes-thoughtfully",children:"1. Design Your Error Codes Thoughtfully"}),"\n",(0,s.jsx)(n.p,{children:"Your error codes are part of your API. Once deployed, changing them can break integrations. Spend time organizing them well:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"module myproject::errors {\n    // Reserve ranges for future use\n    // 1-999: Global errors\n    // 1000-1999: Module A\n    // 2000-2999: Module B\n    // ...\n    // 9000-9999: System errors\n    \n    // Document each error clearly\n    /// Thrown when user tries to withdraw more than their balance\n    const E_INSUFFICIENT_FUNDS: u64 = 1001;\n    \n    /// Thrown when user tries to withdraw from a frozen account\n    const E_ACCOUNT_FROZEN: u64 = 1002;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-fail-fast-fail-descriptively",children:"2. Fail Fast, Fail Descriptively"}),"\n",(0,s.jsx)(n.p,{children:"Check conditions as early as possible and make errors specific:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun complex_operation(\n    user: &signer,\n    param1: u64,\n    param2: vector<u8>,\n    param3: address\n) {\n    // Authorization checks first (cheapest)\n    let user_addr = signer::address_of(user);\n    assert!(is_authorized(user_addr), E_UNAUTHORIZED);\n    \n    // Parameter validation (still cheap)\n    assert!(param1 > 0, E_PARAM1_ZERO);\n    assert!(param1 <= MAX_VALUE, E_PARAM1_TOO_LARGE);\n    assert!(!vector::is_empty(&param2), E_PARAM2_EMPTY);\n    \n    // State checks (more expensive)\n    assert!(exists<Registry>(param3), E_REGISTRY_NOT_FOUND);\n    \n    // Only then do expensive operations\n    perform_operation(param1, param2, param3);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-provide-safe-alternatives",children:"3. Provide Safe Alternatives"}),"\n",(0,s.jsx)(n.p,{children:"For every aborting function, consider providing a non-aborting alternative:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Aborting version for when balance MUST exist\npublic fun get_balance(addr: address): u64 acquires Balance {\n    assert!(exists<Balance>(addr), E_NO_BALANCE);\n    borrow_global<Balance>(addr).amount\n}\n\n// Safe version for checking\npublic fun get_balance_or_zero(addr: address): u64 acquires Balance {\n    if (exists<Balance>(addr)) {\n        borrow_global<Balance>(addr).amount\n    } else {\n        0\n    }\n}\n\n// Option version for flexibility\npublic fun try_get_balance(addr: address): Option<u64> acquires Balance {\n    if (exists<Balance>(addr)) {\n        option::some(borrow_global<Balance>(addr).amount)\n    } else {\n        option::none()\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-test-error-paths-thoroughly",children:"4. Test Error Paths Thoroughly"}),"\n",(0,s.jsx)(n.p,{children:"Every assertion in your code should have a corresponding test:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[test]\nfun test_all_error_conditions() {\n    test_unauthorized_access();\n    test_insufficient_funds();\n    test_invalid_parameters();\n    test_expired_operations();\n    // ... test every E_ constant\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"5-document-error-conditions",children:"5. Document Error Conditions"}),"\n",(0,s.jsx)(n.p,{children:"Make it clear when and why functions might fail:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"/// Transfers tokens from one account to another\n/// \n/// # Arguments\n/// * `from` - The account to transfer from\n/// * `to` - The account to transfer to  \n/// * `amount` - The amount to transfer\n///\n/// # Errors\n/// * `E_INSUFFICIENT_FUNDS` - If from account has less than amount\n/// * `E_ACCOUNT_FROZEN` - If either account is frozen\n/// * `E_AMOUNT_ZERO` - If amount is 0\n/// * `E_SAME_ACCOUNT` - If from and to are the same\npublic fun transfer(from: &signer, to: address, amount: u64) {\n    // Implementation\n}\n"})}),"\n",(0,s.jsxs)(n.admonition,{title:"Error Handling Checklist",type:"tip",children:[(0,s.jsx)(n.p,{children:"Before deploying, ensure:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\u2705 All error codes are unique within your module"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Error codes are organized systematically"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Every assertion has a test case"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Authorization checks come before expensive operations"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Safe alternatives exist for common operations"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Error conditions are documented"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 No silent failures (returning defaults on error)"}),"\n"]})]}),"\n",(0,s.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsx)(n.p,{children:"Move's error handling might seem restrictive at first, but it's designed for the unique requirements of blockchain:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Atomicity is non-negotiable"}),": Transactions either succeed completely or fail completely"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Assert early and often"}),": Validate everything before making state changes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error codes are your API"}),": Design them thoughtfully and document them well"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Patterns provide flexibility"}),": Option, Result, and validation patterns handle complex scenarios"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Testing is crucial"}),": Every error path needs verification"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Organization scales"}),": Systematic error numbering helps large projects"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The simplicity of Move's error model \u2013 abort on any error \u2013 actually makes programs more reliable. There's no confusion about partial states, no complex error propagation, no unexpected exception paths. When something goes wrong, the blockchain stays consistent, and developers get clear feedback about what happened."}),"\n",(0,s.jsx)(n.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,s.jsx)(n.p,{children:"You've now completed the Move fundamentals series! With your understanding of resources, modules, functions, control flow, and error handling, you're ready to build real applications."}),"\n",(0,s.jsxs)(n.p,{children:["Check out our ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/real-world-guides",children:"Real World Guides"})})," to put your knowledge into practice:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Build your first token with the ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/guides/first-fa",children:"Fungible Asset Guide"})})]}),"\n",(0,s.jsxs)(n.li,{children:["Create unique collectibles with the ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/guides/first-nft",children:"NFT Contract Walkthrough"})})]}),"\n",(0,s.jsxs)(n.li,{children:["Implement secure payments with the ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/guides/escrow",children:"Escrow Contract Guide"})})]}),"\n",(0,s.jsxs)(n.li,{children:["Set up revenue sharing with the ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/guides/fee-splitter",children:"Fee Splitter Module"})})]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var t=r(6540);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);